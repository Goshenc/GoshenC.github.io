<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解析JSON格式数据示例</title>
      <link href="/2025/03/30/%E8%A7%A3%E6%9E%90JSON%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/30/%E8%A7%A3%E6%9E%90JSON%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>书上P444讲的更好</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，常用于 Web API 交互。Kotlin 提供了多种解析 JSON 数据的方法，其中 <code>org.json.JSONObject</code> 和 <code>Gson</code> 是常见的选择。</p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h2><ul><li><strong>解析网络请求返回的 JSON 数据</strong></li><li><strong>存储和读取本地 JSON 配置文件</strong></li><li><strong>序列化&#x2F;反序列化 Kotlin 数据类</strong></li></ul><h2 id="3-JSON-示例"><a href="#3-JSON-示例" class="headerlink" title="3. JSON 示例"></a>3. JSON 示例</h2><p>假设有如下 JSON 数据 <code>sample.json</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 1,</span><br><span class="line">      &quot;name&quot;: &quot;MyApp&quot;,</span><br><span class="line">      &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 2,</span><br><span class="line">      &quot;name&quot;: &quot;AnotherApp&quot;,</span><br><span class="line">      &quot;version&quot;: &quot;2.3.4&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-解析方式"><a href="#4-解析方式" class="headerlink" title="4. 解析方式"></a>4. 解析方式</h2><h3 id="4-1-使用-org-json-解析-JSON"><a href="#4-1-使用-org-json-解析-JSON" class="headerlink" title="4.1 使用 org.json 解析 JSON"></a><strong>4.1 使用 org.json 解析 JSON</strong></h3><p>Kotlin 可以使用 <code>org.json.JSONObject</code> 和 <code>org.json.JSONArray</code> 解析 JSON。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.json.JSONObject</span><br><span class="line"></span><br><span class="line">fun parseJson(jsonData: String) &#123;</span><br><span class="line">    val jsonObject = JSONObject(jsonData)</span><br><span class="line">    val appsArray = jsonObject.getJSONArray(&quot;apps&quot;)</span><br><span class="line">    </span><br><span class="line">    for (i in 0 until appsArray.length()) &#123;</span><br><span class="line">        val appObject = appsArray.getJSONObject(i)</span><br><span class="line">        val id = appObject.getInt(&quot;id&quot;)</span><br><span class="line">        val name = appObject.getString(&quot;name&quot;)</span><br><span class="line">        val version = appObject.getString(&quot;version&quot;)</span><br><span class="line">        </span><br><span class="line">        println(&quot;App ID: $id, Name: $name, Version: $version&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-使用-Gson-解析-JSON"><a href="#4-2-使用-Gson-解析-JSON" class="headerlink" title="4.2 使用 Gson 解析 JSON"></a><strong>4.2 使用 Gson 解析 JSON</strong></h3><p><code>Gson</code> 是 Google 提供的 JSON 库，可用于对象与 JSON 之间的转换。</p><p><strong>添加依赖：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;com.google.code.gson:gson:2.8.9&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义数据类并解析 JSON：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import com.google.gson.Gson</span><br><span class="line">import com.google.gson.annotations.SerializedName</span><br><span class="line"></span><br><span class="line">// 定义数据类</span><br><span class="line">data class App(</span><br><span class="line">    val id: Int,</span><br><span class="line">    val name: String,</span><br><span class="line">    val version: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">data class AppList(</span><br><span class="line">    @SerializedName(&quot;apps&quot;) val apps: List&lt;App&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fun parseJsonWithGson(jsonData: String) &#123;</span><br><span class="line">    val gson = Gson()</span><br><span class="line">    val appList = gson.fromJson(jsonData, AppList::class.java)</span><br><span class="line">    </span><br><span class="line">    appList.apps.forEach &#123;</span><br><span class="line">        println(&quot;App ID: $&#123;it.id&#125;, Name: $&#123;it.name&#125;, Version: $&#123;it.version&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-解析流程"><a href="#5-解析流程" class="headerlink" title="5. 解析流程"></a>5. 解析流程</h2><ol><li><strong>选择解析方式</strong>（<code>org.json</code> 或 <code>Gson</code>）。</li><li><strong>解析 JSON 数据</strong>（对象映射或手动解析）。</li><li><strong>处理数据</strong>（存储、展示或操作）。</li></ol><h2 id="6-适用场景对比"><a href="#6-适用场景对比" class="headerlink" title="6. 适用场景对比"></a>6. 适用场景对比</h2><table><thead><tr><th>解析方式</th><th>适用场景</th><th>备注</th></tr></thead><tbody><tr><td><code>org.json</code></td><td>简单解析 JSON</td><td>适合临时处理，性能较低</td></tr><tr><td><code>Gson</code></td><td>解析 API 响应或本地 JSON 文件</td><td>易用，支持复杂对象映射</td></tr></tbody></table><h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p>对于 Kotlin 开发者，<strong>推荐使用</strong> <code>**Gson**</code>，它提供了更灵活的数据映射能力，适用于大多数 JSON 解析需求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAX解析XML数据用法示例</title>
      <link href="/2025/03/30/SAX%E8%A7%A3%E6%9E%90XML%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/30/SAX%E8%A7%A3%E6%9E%90XML%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>使用 SAX 解析 XML 数据</strong></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>SAX（Simple API for XML）是一种基于事件驱动的 XML 解析方式，适用于处理大规模 XML 文档。SAX 解析器不会将整个 XML 加载到内存中，而是逐行解析，因此在 <strong>性能和内存占用方面优于 DOM 解析</strong>。</p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h2><ul><li><strong>处理大 XML 文件</strong>（如 RSS 订阅、日志文件）</li><li><strong>流式解析</strong>（节省内存）</li><li><strong>只需读取数据</strong>（无需修改 XML 结构）</li></ul><h2 id="3-XML-示例"><a href="#3-XML-示例" class="headerlink" title="3. XML 示例"></a>3. XML 示例</h2><p>假设有如下 XML 数据 <code>sample.xml</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;apps&gt;</span><br><span class="line">    &lt;app id=&quot;1&quot;&gt;</span><br><span class="line">        &lt;name&gt;MyApp&lt;/name&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/app&gt;</span><br><span class="line">    &lt;app id=&quot;2&quot;&gt;</span><br><span class="line">        &lt;name&gt;AnotherApp&lt;/name&gt;</span><br><span class="line">        &lt;version&gt;2.3.4&lt;/version&gt;</span><br><span class="line">    &lt;/app&gt;</span><br><span class="line">&lt;/apps&gt;</span><br></pre></td></tr></table></figure><h2 id="4-SAX-解析步骤"><a href="#4-SAX-解析步骤" class="headerlink" title="4. SAX 解析步骤"></a>4. SAX 解析步骤</h2><h3 id="4-1-创建-ContentHandler-处理-XML"><a href="#4-1-创建-ContentHandler-处理-XML" class="headerlink" title="4.1 创建 ContentHandler 处理 XML"></a><strong>4.1 创建 ContentHandler 处理 XML</strong></h3><p>SAX 解析基于 <code>ContentHandler</code> 处理 XML 解析事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import android.util.Log</span><br><span class="line">import org.xml.sax.Attributes</span><br><span class="line">import org.xml.sax.helpers.DefaultHandler</span><br><span class="line"></span><br><span class="line">class AppContentHandler : DefaultHandler() &#123;</span><br><span class="line">    private var nodeName = &quot;&quot;</span><br><span class="line">    private lateinit var id: StringBuilder</span><br><span class="line">    private lateinit var name: StringBuilder</span><br><span class="line">    private lateinit var version: StringBuilder</span><br><span class="line"></span><br><span class="line">    override fun startDocument() &#123;</span><br><span class="line">        id = StringBuilder()</span><br><span class="line">        name = StringBuilder()</span><br><span class="line">        version = StringBuilder()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun startElement(uri: String?, localName: String?, qName: String?, attributes: Attributes?) &#123;</span><br><span class="line">        nodeName = localName ?: &quot;&quot;</span><br><span class="line">        if (localName == &quot;app&quot; &amp;&amp; attributes != null) &#123;</span><br><span class="line">            Log.d(&quot;AppContentHandler&quot;, &quot;App ID: $&#123;attributes.getValue(&quot;id&quot;)&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun characters(ch: CharArray?, start: Int, length: Int) &#123;</span><br><span class="line">        when (nodeName) &#123;</span><br><span class="line">            &quot;name&quot; -&gt; name.append(ch, start, length)</span><br><span class="line">            &quot;version&quot; -&gt; version.append(ch, start, length)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun endElement(uri: String?, localName: String?, qName: String?) &#123;</span><br><span class="line">        if (localName == &quot;app&quot;) &#123;</span><br><span class="line">            Log.d(&quot;AppContentHandler&quot;, &quot;App Name: $&#123;name.toString().trim()&#125;&quot;)</span><br><span class="line">            Log.d(&quot;AppContentHandler&quot;, &quot;App Version: $&#123;version.toString().trim()&#125;&quot;)</span><br><span class="line">            name.setLength(0)</span><br><span class="line">            version.setLength(0)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-在-Activity-或-Service-中使用-SAX-解析-XML"><a href="#4-2-在-Activity-或-Service-中使用-SAX-解析-XML" class="headerlink" title="4.2 在 Activity 或 Service 中使用 SAX 解析 XML"></a><strong>4.2 在 Activity 或 Service 中使用 SAX 解析 XML</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.xml.sax.InputSource</span><br><span class="line">import java.io.StringReader</span><br><span class="line">import javax.xml.parsers.SAXParserFactory</span><br><span class="line"></span><br><span class="line">fun parseXml(xmlData: String) &#123;</span><br><span class="line">    val factory = SAXParserFactory.newInstance()</span><br><span class="line">    val parser = factory.newSAXParser()</span><br><span class="line">    val xmlReader = parser.xmlReader</span><br><span class="line">    xmlReader.contentHandler = AppContentHandler()</span><br><span class="line">    xmlReader.parse(InputSource(StringReader(xmlData)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-调用解析函数"><a href="#4-3-调用解析函数" class="headerlink" title="4.3 调用解析函数"></a><strong>4.3 调用解析函数</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val xmlData = &quot;&quot;&quot;</span><br><span class="line">&lt;apps&gt;</span><br><span class="line">    &lt;app id=&quot;1&quot;&gt;</span><br><span class="line">        &lt;name&gt;MyApp&lt;/name&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/app&gt;</span><br><span class="line">    &lt;app id=&quot;2&quot;&gt;</span><br><span class="line">        &lt;name&gt;AnotherApp&lt;/name&gt;</span><br><span class="line">        &lt;version&gt;2.3.4&lt;/version&gt;</span><br><span class="line">    &lt;/app&gt;</span><br><span class="line">&lt;/apps&gt;</span><br><span class="line">&quot;&quot;&quot;.trimIndent()</span><br><span class="line"></span><br><span class="line">parseXml(xmlData)</span><br></pre></td></tr></table></figure><h2 id="5-解析流程"><a href="#5-解析流程" class="headerlink" title="5. 解析流程"></a>5. 解析流程</h2><ol><li><code>startDocument()</code> 初始化变量。</li><li><code>startElement()</code> 读取 <strong>标签名称</strong> 和 <strong>属性</strong>。</li><li><code>characters()</code> 读取 <strong>标签内文本</strong>。</li><li><code>endElement()</code> 处理 <strong>数据存储和输出</strong>。</li></ol><h2 id="6-优势与局限性"><a href="#6-优势与局限性" class="headerlink" title="6. 优势与局限性"></a>6. 优势与局限性</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>✔ <strong>内存占用低</strong>（适合大 XML 文件） ✔ <strong>解析速度快</strong>（基于流式处理） ✔ <strong>官方推荐</strong>（Android 内置支持）</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>✘ <strong>不支持随机访问</strong>（只能顺序解析） ✘ <strong>不适合修改 XML 结构</strong>（仅适用于读取数据）</p><h2 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a>7. 适用场景</h2><ul><li><strong>解析网络请求返回的 XML</strong></li><li><strong>处理 RSS 订阅数据</strong></li><li><strong>解析配置文件</strong>（如 <code>AndroidManifest.xml</code>）</li></ul><h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a>8. 结论</h2><p>SAX 解析是一种 <strong>高效且轻量</strong> 的 XML 处理方式，适用于 Android 开发，尤其是需要解析大 XML 数据时。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用XmlPullParser解析XML格式数据的用法示例</title>
      <link href="/2025/03/30/%E4%BD%BF%E7%94%A8XmlPullParser%E8%A7%A3%E6%9E%90XML%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/30/%E4%BD%BF%E7%94%A8XmlPullParser%E8%A7%A3%E6%9E%90XML%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>使用 XmlPullParser 解析 XML 格式数据（Kotlin 版）</strong></p><p>书上P438讲的很好，看书我觉得更好</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>XmlPullParser 是 Android 官方提供的轻量级 XML 解析器，适用于资源受限的移动设备。它基于流式解析，不会将整个 XML 加载到内存中，因此适用于大数据量的 XML 解析。</p><p><strong>额外知识—选择合适的解析方式：</strong></p><table><thead><tr><th>方式</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>SAX</td><td>大型 XML，逐行解析</td><td>低内存占用</td><td>编码复杂</td></tr><tr><td>DOM</td><td>小型 XML，需要修改</td><td>易用</td><td>内存占用大</td></tr><tr><td>XmlPullParser</td><td>轻量 XML 解析</td><td>性能高</td><td>手写解析代码</td></tr><tr><td>Simple XML</td><td>复杂 XML，映射对象</td><td>代码清晰</td><td>依赖第三方库</td></tr></tbody></table><p>如果你处理的是 Android 端 XML 解析，建议优先使用 <strong>XmlPullParser</strong>，如果 XML 结构复杂且需要映射对象，可以考虑 <strong>Simple XML</strong>。</p><h2 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2. 使用步骤"></a>2. 使用步骤</h2><h3 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h3><p>XmlPullParser 是 Android 自带的 API，因此无需额外添加依赖。</p><h3 id="2-2-XML-示例数据"><a href="#2-2-XML-示例数据" class="headerlink" title="2.2 XML 示例数据"></a>2.2 XML 示例数据</h3><p>假设我们有一个 XML 文件 <code>sample.xml</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;catalog&gt;</span><br><span class="line">    &lt;book id=&quot;1&quot;&gt;</span><br><span class="line">        &lt;title&gt;Android Development&lt;/title&gt;</span><br><span class="line">        &lt;author&gt;John Doe&lt;/author&gt;</span><br><span class="line">        &lt;price&gt;29.99&lt;/price&gt;</span><br><span class="line">    &lt;/book&gt;</span><br><span class="line">    &lt;book id=&quot;2&quot;&gt;</span><br><span class="line">        &lt;title&gt;Kotlin for Beginners&lt;/title&gt;</span><br><span class="line">        &lt;author&gt;Jane Smith&lt;/author&gt;</span><br><span class="line">        &lt;price&gt;35.50&lt;/price&gt;</span><br><span class="line">    &lt;/book&gt;</span><br><span class="line">&lt;/catalog&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-解析-XML-数据"><a href="#2-3-解析-XML-数据" class="headerlink" title="2.3 解析 XML 数据"></a>2.3 解析 XML 数据</h3><h4 id="2-3-1-创建-XmlPullParser-对象"><a href="#2-3-1-创建-XmlPullParser-对象" class="headerlink" title="2.3.1 创建 XmlPullParser 对象"></a>2.3.1 创建 XmlPullParser 对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val factory = XmlPullParserFactory.newInstance()</span><br><span class="line">val parser = factory.newPullParser()</span><br><span class="line">parser.setInput(xmlData.reader())</span><br></pre></td></tr></table></figure><h4 id="2-3-2-解析-XML"><a href="#2-3-2-解析-XML" class="headerlink" title="2.3.2 解析 XML"></a>2.3.2 解析 XML</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var eventType = parser.eventType</span><br><span class="line">var tagName: String?</span><br><span class="line">var title = &quot;&quot;</span><br><span class="line">var author = &quot;&quot;</span><br><span class="line">var price = &quot;&quot;</span><br><span class="line"></span><br><span class="line">while (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">    when (eventType) &#123;</span><br><span class="line">        XmlPullParser.START_TAG -&gt; &#123;</span><br><span class="line">            tagName = parser.name</span><br><span class="line">            when (tagName) &#123;</span><br><span class="line">                &quot;title&quot; -&gt; title = parser.nextText()</span><br><span class="line">                &quot;author&quot; -&gt; author = parser.nextText()</span><br><span class="line">                &quot;price&quot; -&gt; price = parser.nextText()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventType = parser.next()</span><br><span class="line">    </span><br><span class="line">    // 输出解析结果</span><br><span class="line">    if (title.isNotEmpty() &amp;&amp; author.isNotEmpty() &amp;&amp; price.isNotEmpty()) &#123;</span><br><span class="line">        println(&quot;Book: $title, Author: $author, Price: $price&quot;)</span><br><span class="line">        title = &quot;&quot;</span><br><span class="line">        author = &quot;&quot;</span><br><span class="line">        price = &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-解析流程解析"><a href="#3-解析流程解析" class="headerlink" title="3. 解析流程解析"></a>3. 解析流程解析</h2><ul><li><code>XmlPullParser.START_TAG</code>：检测到 XML 元素开始标签时，获取标签名。</li><li><code>parser.nextText()</code>：提取标签的文本内容。</li><li><code>XmlPullParser.END_DOCUMENT</code>：解析结束。</li></ul><h2 id="4-优势"><a href="#4-优势" class="headerlink" title="4. 优势"></a>4. 优势</h2><ul><li><strong>内存占用低</strong>：适用于大文件解析。</li><li><strong>速度快</strong>：只遍历一次 XML。</li><li><strong>原生支持</strong>：无需额外依赖。</li></ul><h2 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h2><ul><li>解析配置文件（如 <code>AndroidManifest.xml</code>）。</li><li>解析网络返回的 XML 数据。</li><li>解析 RSS 订阅数据。</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>XmlPullParser 是 Android 推荐的 XML 解析方式，适用于移动端高效处理 XML 数据。通过流式解析，可以显著降低内存占用，提高应用性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp的用法示例</title>
      <link href="/2025/03/29/OkHttp%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/29/OkHttp%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>OkHttp 是一个高效、灵活的 HTTP 客户端库，在 Android 开发中非常常用。下面介绍如何在 Android 中使用 OkHttp，并附上常见的 GET 和 POST 请求示例。</p><h2 id="1-添加-OkHttp-依赖"><a href="#1-添加-OkHttp-依赖" class="headerlink" title="1. 添加 OkHttp 依赖"></a><strong>1. 添加 <code>OkHttp</code> 依赖</strong></h2><p>如果你还没有添加 <code>OkHttp</code>，需要在 <code>build.gradle.kts</code> 添加依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;) // 最新版</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你用的是 <code>build.gradle</code>（Groovy 语法）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.squareup.okhttp3:okhttp:4.12.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-基本的-GET-请求-同步"><a href="#2-基本的-GET-请求-同步" class="headerlink" title="2. 基本的 GET 请求(同步)"></a><strong>2. 基本的 GET 请求(同步)</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import okhttp3.OkHttpClient</span><br><span class="line">import okhttp3.Request</span><br><span class="line">import okhttp3.Response</span><br><span class="line">import java.io.IOException</span><br><span class="line"></span><br><span class="line">fun sendGetRequest(): String? &#123;</span><br><span class="line">    val client = OkHttpClient() // 创建 OkHttpClient 实例</span><br><span class="line"></span><br><span class="line">    val request = Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/data&quot;) // 目标 URL</span><br><span class="line">        .get() // GET 请求</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    return try &#123;</span><br><span class="line">        val response: Response = client.newCall(request).execute() // 执行请求（同步）</span><br><span class="line">        if (response.isSuccessful) response.body?.string() else null</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3><ul><li><code>OkHttpClient</code>：创建 HTTP 客户端实例。</li><li><code>Request.Builder()</code>：构建 HTTP 请求。</li><li><code>.execute()</code>：执行 <strong>同步请求</strong>（会阻塞线程）。</li><li><code>response.body?.string()</code>：获取服务器返回的字符串。</li></ul><hr><h2 id="3-GET-请求（异步）"><a href="#3-GET-请求（异步）" class="headerlink" title="3. GET 请求（异步）"></a><strong>3. GET 请求（异步）</strong></h2><p>如果你不想阻塞主线程，可以使用 <strong>异步请求</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import okhttp3.*</span><br><span class="line">import java.io.IOException</span><br><span class="line">//callback 变量最终是用来将结果传递到最下面的回调函数里的，这个 回调函数 里的 result 就是 callback 传递的值</span><br><span class="line">fun sendGetRequestAsync(callback: (String?) -&gt; Unit) &#123;</span><br><span class="line">    val client = OkHttpClient()</span><br><span class="line">    val request = Request.Builder().url(&quot;https://api.example.com/data&quot;).build()</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(object : Callback &#123;</span><br><span class="line">        override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">            callback(null) // 发生错误，返回 null到下面回调函数的result中</span><br><span class="line">        &#125;</span><br><span class="line">        override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">            callback(response.body?.string()) // 请求成功，把返回的数据传递给回调函数中的result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用示例</span><br><span class="line">fun main() &#123;</span><br><span class="line">    sendGetRequestAsync &#123; result -&gt;</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            println(&quot;服务器返回数据：$result&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;请求失败&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li><code>.enqueue()</code>：使用异步请求，不会阻塞主线程。</li><li><strong>onFailure</strong>：请求失败时回调。</li><li><strong>onResponse</strong>：请求成功时回调，并返回数据。</li></ul><hr><h2 id="4-POST-请求（JSON-数据）"><a href="#4-POST-请求（JSON-数据）" class="headerlink" title="4. POST 请求（JSON 数据）"></a><strong>4. POST 请求（JSON 数据）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import okhttp3.MediaType.Companion.toMediaTypeOrNull</span><br><span class="line">import okhttp3.OkHttpClient</span><br><span class="line">import okhttp3.Request</span><br><span class="line">import okhttp3.RequestBody</span><br><span class="line">import okhttp3.Response</span><br><span class="line"></span><br><span class="line">fun sendPostRequest(json: String): String? &#123;</span><br><span class="line">    val client = OkHttpClient()</span><br><span class="line"></span><br><span class="line">    val requestBody = RequestBody.create(&quot;application/json&quot;.toMediaTypeOrNull(), json)//这里的json是传入的参数</span><br><span class="line"></span><br><span class="line">    val request = Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/login&quot;)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    return try &#123;</span><br><span class="line">        val response: Response = client.newCall(request).execute()</span><br><span class="line">        if (response.isSuccessful) response.body?.string() else null</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val jsonData = &quot;&quot;&quot;&#123;&quot;username&quot;:&quot;test&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&quot;&quot;&quot;</span><br><span class="line">val response = sendPostRequest(jsonData)</span><br><span class="line">println(&quot;服务器返回: $response&quot;)</span><br></pre></td></tr></table></figure><h3 id="异步版本POST请求"><a href="#异步版本POST请求" class="headerlink" title="异步版本POST请求"></a>异步版本POST请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import okhttp3.*</span><br><span class="line">import java.io.IOException</span><br><span class="line"></span><br><span class="line">fun sendPostRequestAsync(json: String, callback: (String?) -&gt; Unit) &#123;</span><br><span class="line">    val client = OkHttpClient()</span><br><span class="line"></span><br><span class="line">    // 创建请求体</span><br><span class="line">    val requestBody = RequestBody.create(&quot;application/json&quot;.toMediaTypeOrNull(), json)</span><br><span class="line"></span><br><span class="line">    // 创建请求</span><br><span class="line">    val request = Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/login&quot;)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    // 异步请求，使用 enqueue 发送请求</span><br><span class="line">    client.newCall(request).enqueue(object : Callback &#123;</span><br><span class="line">        override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">            callback(null)  // 请求失败，传递 null 给回调</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">            // 请求成功时，检查响应状态</span><br><span class="line">            if (response.isSuccessful) &#123;</span><br><span class="line">                callback(response.body?.string())  // 请求成功，传递响应内容给回调</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                callback(null)  // 如果请求不成功，传递 null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如何使用如下所示</span><br><span class="line">fun main() &#123;</span><br><span class="line">    val json = &quot;&quot;&quot;&#123;&quot;username&quot;:&quot;test&quot;, &quot;password&quot;:&quot;123456&quot;&#125;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    sendPostRequestAsync(json) &#123; result -&gt;</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            println(&quot;请求成功，返回数据：$result&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;请求失败&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="5-在-Android-里使用（结合协程）"><a href="#5-在-Android-里使用（结合协程）" class="headerlink" title="5. 在 Android 里使用（结合协程）"></a><strong>5. 在 Android 里使用（结合协程）</strong></h2><p>在 Android 开发中，推荐 <strong>协程+OkHttp</strong>，避免阻塞 UI 线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">suspend fun fetchData(): String? &#123;</span><br><span class="line">    return withContext(Dispatchers.IO) &#123;</span><br><span class="line">        val client = OkHttpClient()</span><br><span class="line">        val request = Request.Builder()</span><br><span class="line">            .url(&quot;https://api.example.com/data&quot;)</span><br><span class="line">            .get()</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            val response = client.newCall(request).execute()</span><br><span class="line">            if (response.isSuccessful) response.body?.string() else null</span><br><span class="line">        &#125; catch (e: IOException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">            null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-Activity-中调用"><a href="#在-Activity-中调用" class="headerlink" title="在 Activity 中调用"></a><strong>在 <code>Activity</code> 中调用</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    val data = fetchData()</span><br><span class="line">    textView.text = data // 更新 UI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>请求方式</th><th>方法</th><th>是否阻塞线程</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td><code>execute()</code></td><td>✅ <strong>同步（会阻塞）</strong></td></tr><tr><td><strong>GET（异步）</strong></td><td><code>enqueue()</code></td><td>❌ <strong>异步（不会阻塞）</strong></td></tr><tr><td><strong>POST</strong></td><td><code>execute()</code></td><td>✅ <strong>同步（会阻塞）</strong></td></tr><tr><td><strong>POST（协程）</strong></td><td><code>withContext(Dispatchers.IO)</code></td><td>✅ <strong>推荐（不会阻塞）</strong></td></tr></tbody></table><ul><li><strong>在 Android 里，推荐使用</strong>：<ul><li><strong><code>enqueue()</code></strong>（异步回调）</li><li><strong><code>withContext(Dispatchers.IO)</code></strong>（协程）</li></ul></li><li><strong>避免在主线程执行 <code>execute()</code>，否则会导致 ANR（应用无响应）</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HttpURLConnection的用法示例</title>
      <link href="/2025/03/29/HttpURLConnection%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/29/HttpURLConnection%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><code>HttpURLConnection</code> 是 Android 进行网络请求的一个轻量级 HTTP 客户端，适用于简单的 GET 和 POST 请求。以下是 <code>HttpURLConnection</code> 的基本使用方法。</p><hr><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a><strong>使用步骤</strong></h2><ol><li><strong>创建 URL 对象</strong></li><li><strong>打开连接并配置请求</strong></li><li><strong>发送请求</strong></li><li><strong>读取响应</strong></li><li><strong>关闭连接</strong></li></ol><hr><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="1-GET-请求"><a href="#1-GET-请求" class="headerlink" title="1. GET 请求"></a><strong>1. GET 请求</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.net.HttpURLConnection</span><br><span class="line">import java.net.URL</span><br><span class="line"></span><br><span class="line">fun sendGetRequest(urlString: String): String? &#123;</span><br><span class="line">    var connection: HttpURLConnection? = null</span><br><span class="line">    try &#123;</span><br><span class="line">        val url = URL(urlString)</span><br><span class="line">        connection = url.openConnection() as HttpURLConnection</span><br><span class="line">        connection.requestMethod = &quot;GET&quot;</span><br><span class="line">        connection.connectTimeout = 5000  // 超时时间</span><br><span class="line">        connection.readTimeout = 5000</span><br><span class="line">        connection.doInput = true  // 允许输入流</span><br><span class="line"></span><br><span class="line">        if (connection.responseCode == HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">            return connection.inputStream.bufferedReader().use &#123; it.readText() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        connection?.disconnect()  // 断开连接</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">val response = sendGetRequest(&quot;https://api.example.com/data&quot;)</span><br><span class="line">println(response)</span><br></pre></td></tr></table></figure><hr><h3 id="2-POST-请求"><a href="#2-POST-请求" class="headerlink" title="2. POST 请求"></a><strong>2. POST 请求</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.io.OutputStream</span><br><span class="line">import java.net.HttpURLConnection</span><br><span class="line">import java.net.URL</span><br><span class="line"></span><br><span class="line">fun sendPostRequest(urlString: String, postData: String): String? &#123;</span><br><span class="line">    var connection: HttpURLConnection? = null</span><br><span class="line">    try &#123;</span><br><span class="line">        val url = URL(urlString)</span><br><span class="line">        connection = url.openConnection() as HttpURLConnection</span><br><span class="line">        connection.requestMethod = &quot;POST&quot;</span><br><span class="line">        connection.connectTimeout = 5000</span><br><span class="line">        connection.readTimeout = 5000</span><br><span class="line">        connection.doOutput = true  // 允许输出流</span><br><span class="line">        connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;) // 发送 JSON 数据</span><br><span class="line"></span><br><span class="line">        // 发送数据</span><br><span class="line">        connection.outputStream.use &#123; os: OutputStream -&gt;</span><br><span class="line">            os.write(postData.toByteArray())</span><br><span class="line">            os.flush()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (connection.responseCode == HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">            return connection.inputStream.bufferedReader().use &#123; it.readText() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        connection?.disconnect()</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">val jsonBody = &quot;&quot;&quot;&#123;&quot;username&quot;:&quot;test&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&quot;&quot;&quot;</span><br><span class="line">val postResponse = sendPostRequest(&quot;https://api.example.com/login&quot;, jsonBody)</span><br><span class="line">println(postResponse)</span><br></pre></td></tr></table></figure><hr><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol><li><p><strong>网络请求必须在子线程执行</strong></p><ul><li>在 Android 9 及以上，主线程访问网络会抛出 <code>NetworkOnMainThreadException</code>。</li><li>可以使用 <code>Coroutine</code> 或 <code>Thread</code> 处理。</li></ul><p><strong>使用 <code>Coroutine</code> 进行网络请求</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line">suspend fun fetchData(): String? &#123;</span><br><span class="line">    return withContext(Dispatchers.IO) &#123; </span><br><span class="line">        sendGetRequest(&quot;https://api.example.com/data&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>fetchData()</code></strong></p><p><strong>不能在主线程直接调用 <code>fetchData()</code>，需要在协程中调用，例如：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        val result = fetchData()</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(6000) // 等待协程执行（仅示例用，实际开发不推荐）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>权限</strong></p><ul><li>在 <code>AndroidManifest.xml</code> 中添加权限：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>超时设置</strong></p><ul><li><code>connectTimeout</code> 和 <code>readTimeout</code> 防止请求长时间挂起。</li></ul></li></ol><hr><h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a><strong>替代方案</strong></h2><p>在 Android 现代开发中，建议使用 <code>OkHttp</code> 或 <code>Retrofit</code> 进行网络请求，<code>HttpURLConnection</code> 适用于轻量级请求或对库依赖要求较高的项目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Service用法示例</title>
      <link href="/2025/03/28/Service%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/28/Service%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="Service-是什么"><a href="#Service-是什么" class="headerlink" title="Service 是什么"></a>Service 是什么</h2><p>Service 是 Android 中实现程序后台运行的解决方案，它非常适合执行那些不需要和用户交互而 且还要求长期运行的任务。Service 的运行不依赖于任何用户界面，即使程序被切换到后台，或 者用户打开了另外一个应用程序，Service 仍然能够保持正常运行。</p><p>不过需要注意的是，Service 并不是运行在一个独立的进程当中的，而是依赖于创建 Service 时 所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的 Service 也会停止运行。</p><p>另外，也不要被 Service 的后台概念所迷惑，实际上 Service 并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在 Service 的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。</p><h2 id="Android-多线程编程"><a href="#Android-多线程编程" class="headerlink" title="Android 多线程编程"></a>Android 多线程编程</h2><p>当我们需要执行一些耗时操作，比如发 起一条网络请求时，考虑到网速等其他原因，服务器未必能够立刻响应我们的请求，如果不将 这类操作放在子线程里运行，就会导致主线程被阻塞，从而影响用户对软件的正常使用。</p><h3 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="线程的基本用法"></a>线程的基本用法</h3><p>义一 个线程只需要新建一个类继承自 Thread，然后重写父类的 run () 方法，并在里面编写耗时逻辑 即可，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyThread : Thread()&#123;</span><br><span class="line">    override fun run()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么该如何启动这个线程呢？其实很简单，只需要创建 MyThread 的实例，然后调用它的 start () 方法即可，这样 run () 方法中的代码就会在子线程当中运行了，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyThread().start()</span><br></pre></td></tr></table></figure><p>当然，使用继承的方式耦合性有点高，我们会更多地选择使用实现 Runnable 接口的方式来定义 一个线程，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyThread : Runnable &#123; </span><br><span class="line">     override fun run() &#123; </span><br><span class="line">        // 编写具体的逻辑 </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用了这种写法，启动线程的方法也需要进行相应的改变，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val myThread = MyThread() </span><br><span class="line">Thread(myThread).start() </span><br></pre></td></tr></table></figure><p>可以看到，Thread 的构造函数接收一个 Runnable 参数，而我们创建的 MyThread 实例正是一 个实现了 Runnable 接口的对象，所以可以直接将它传入 Thread 的构造函数里。接着调用 Thread 的 start () 方法，run () 方法中的代码就会在子线程当中运行了。</p><p>当然，如果你不想专门再定义一个类去实现 Runnable 接口，也可以使用 Lambda 的方式，这种 写法更为常见，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread &#123; </span><br><span class="line"> // 编写具体的逻辑 </span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><p>以上几种线程的使用方式你应该不会感到陌生，因为在 Java 中创建和启动线程也是使用同样的 方式。而 Kotlin 还给我们提供了一种更加简单的开启线程的方式，写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread &#123; </span><br><span class="line"> // 编写具体的逻辑 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 thread 是一个 Kotlin 内置的顶层函数，我们只需要在 Lambda 表达式中编写具体的逻辑 就可以了，连 start () 方法都不用调用，thread 函数在内部帮我们全部都处理好了。</p><h3 id="在子线程中更新-UI"><a href="#在子线程中更新-UI" class="headerlink" title="在子线程中更新 UI"></a>在子线程中更新 UI</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity()&#123;</span><br><span class="line">    val updateText = 1</span><br><span class="line">    lateinit var textView : TextView</span><br><span class="line">    </span><br><span class="line">    val handle = object : Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        override fun handleMessage(msg:Message)&#123;</span><br><span class="line">            when(msg.what)&#123;</span><br><span class="line">                updateText -&gt; textView.text = &quot;Nice to meet you&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onCreate(savedInstanceState : Bundle?)&#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        val binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        textView = binding.textView</span><br><span class="line">        val changeTextBtn = binding.changeTextBtn</span><br><span class="line">        changeTextBtn.setOnClickListener&#123;</span><br><span class="line">            thread&#123;</span><br><span class="line">                val msg = Message()</span><br><span class="line">                mag.what = updateText</span><br><span class="line">                handle.sendMessage(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析异步消息处理机制"><a href="#解析异步消息处理机制" class="headerlink" title="解析异步消息处理机制"></a>解析异步消息处理机制</h3><p>Android 中的异步消息处理主要由 4 个部分组成：Message、Handler、MessageQueue 和 Looper。</p><ul><li><p>Message</p><p>Message 是在线程之间传递的消息，它可以在内部携带少量的消息，用于在不同线程之间传递数据。</p></li><li><p>Handler</p><p>Handler 主要是用于发送和处理消息的，发出的消息经过一系列地辗转处理后，最终会传递到 Handler 的 handleMessage () 方法中</p></li><li><p>MessageQueue</p><p>MessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只有一个 MessageQueue 对象。</p></li><li><p>Looper</p><p>Looper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop () 方法后，就会进入一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息时，就会将它取出，并传递到 Handler 的 handleMessage () 方法中。每个线程中只会有一个 Looper 对象</p></li></ul><h4 id="异步消息处理流程"><a href="#异步消息处理流程" class="headerlink" title="异步消息处理流程"></a>异步消息处理流程</h4><p>首先需要在主线程当中创建一个 Handler 对象，并重写 handleMessage () 方法。然后当子线程中国需要进行 UI 操作时，就创建一个 Message 对象，并通过 Handler 将这条消息发送出去。之后这条消息就会被添加到 MessageQueue 的队列中等待被处理，而 Looper 则会一直尝试从 MessageQueue 中取出待处理消息，最后分发回 Handler 的 handleMessage () 方法中。由于 Handle 的构造函数中我们传入了 Looper.getMainLooper ()，所以此时 handleMessage () 方法中的代码也会在主线程中运行</p><h3 id="使用-AsyncTask"><a href="#使用-AsyncTask" class="headerlink" title="使用 AsyncTask"></a>使用 AsyncTask</h3><p>首先来看一下 AsyncTask 的基本用法。由于 AsyncTask 是一个抽象类，所以如果我们想使用 它，就必须创建一个子类去继承它。在继承时我们可以为 AsyncTask 类指定 3 个泛型参数，这 3 个参数的用途如下。</p><ul><li>Params。在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。</li><li>Progress。在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为单位进度</li><li>Result。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型</li></ul><p>因此，一个最简单的自定义 AsyncTask 就可以写成如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class DownloadTask : AsyncTask&lt;Unit, Int, Boolean&gt;() &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里我们把 AsyncTask 的第一个泛型参数指定为 Unit，表示在执行 AsyncTask 的时候不需要传 入参数给后台任务。第二个泛型参数指定为 Int，表示使用整型数据来作为进度显示单位。第三 个泛型参数指定为 Boolean，则表示使用布尔型数据来反馈执行结果。</p><p>当然，目前我们自定义的 DownloadTask 还是一个空任务，并不能进行任何实际的操作，我们 还需要重写 AsyncTask 中的几个方法才能完成对任务的定制。经常需要重写的方法有以下 4 个。</p><ul><li><p>onPreExecute()</p><p>这个方法回在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等</p></li><li><p>doInBackground(Params…)</p><p>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成，就可以通过 return 语句将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Unit，就可以不返回任务执行的结果注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress (Progress…) 方法来完成。</p></li><li><p>onProgressUpdate(Progress…)</p><p>当在后台任务中调用了 publishProgress (Progress…) 方法后， onProgressUpdate (Progress…) 方法就会很快被调用，该方法中携带的参数就是 在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对 界面元素进行相应的更新。</p></li><li><p>onPostExecute(Result)</p><p>当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数 据会作为参数传递到此方法中，可以利用返回的数据进行一些 UI 操作，比如说提醒任务执 行的结果，以及关闭进度条对话框等。</p></li></ul><h2 id="Service-的基本用法"><a href="#Service-的基本用法" class="headerlink" title="Service 的基本用法"></a>Service 的基本用法</h2><h3 id="定义一个-Service"><a href="#定义一个-Service" class="headerlink" title="定义一个 Service"></a>定义一个 Service</h3><p>首先看一下如何在项目中定义一个 Service。新建一个 ServiceTest 项目，然后右击 com.example.servicetest→New→Service→Service，</p><p>可以看到，这里我们将类名定义成 MyService，Exported 属性表示是否将这个 Service 暴露给 外部其他程序访问，Enabled 属性表示是否启用这个 Service。将两个属性都勾中，点 击 “Finish” 完成创建。</p><p>现在观察 MyService 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyService : Service() &#123; </span><br><span class="line"> </span><br><span class="line"> override fun onBind(intent: Intent): IBinder &#123; </span><br><span class="line">     TODO(&quot;Return the communication channel to the service.&quot;) </span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看到，MyService 是继承自系统的 Service 类的。目前 MyService 中可以算是空空如也， 但有一个 onBind () 方法特别醒目。这个方法是 Service 中唯一的抽象方法，所以必须在子类里 实现。我们会在后面的小节中使用到 onBind () 方法，目前可以暂时将它忽略。 既然是定义一个 Service，自然应该在 Service 中处理一些事情了，那处理事情的逻辑应该写在 哪里呢？这时就可以重写 Service 中的另外一些方法了，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyService : Service() &#123; </span><br><span class="line"> ... </span><br><span class="line"> override fun onCreate() &#123; </span><br><span class="line"> super.onCreate() </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int &#123; </span><br><span class="line"> return super.onStartCommand(intent, flags, startId) </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> override fun onDestroy() &#123; </span><br><span class="line"> super.onDestroy() </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们又重写了 onCreate ()、onStartCommand () 和 onDestroy () 这 3 个方 法，它们是每个 Service 中最常用到的 3 个方法了。其中 onCreate () 方法会在 Service 创建的 时候调用，onStartCommand () 方法会在每次 Service 启动的时候调用，onDestroy () 方法 会在 Service 销毁的时候调用。</p><p>通常情况下，如果我们希望 Service 一旦启动就立刻去执行某个动作，就可以将逻辑写在 onStartCommand () 方法里。而当 Service 销毁时，我们又应该在 onDestroy () 方法中回收 那些不再使用的资源。</p><h3 id="启动和停止-Service"><a href="#启动和停止-Service" class="headerlink" title="启动和停止 Service"></a>启动和停止 Service</h3><p>定义好了 Service 之后，接下来就应该考虑如何启动以及停止这个 Service。启动和停止的方法 当然你也不会陌生，主要是借助 Intent 来实现的。下面就让我们在 ServiceTest 项目中尝试启动 以及停止 MyService。</p><p>修改 MainActivity 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity()&#123;</span><br><span class="line">    override fun onCreate(savedInstanceState : Bundle?)&#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        val binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        val startServiceBtn = binding.startServiceBtn</span><br><span class="line">        val stopServiceBtn = binding.stopServiceBtn</span><br><span class="line">        startServiceBtn.setOnClickListener&#123;</span><br><span class="line">            val intent = Intent(this,MyService::class.java)</span><br><span class="line">            startService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">        stioServiceBtn.setOnCLickListener&#123;</span><br><span class="line">            val intent = Intent(this,Myservice::class.java)</span><br><span class="line">            stopService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OnCreate-方法和-onStartCommand-方法区别"><a href="#OnCreate-方法和-onStartCommand-方法区别" class="headerlink" title="OnCreate () 方法和 onStartCommand () 方法区别"></a>OnCreate () 方法和 onStartCommand () 方法区别</h4><p>onCreate () 方法是在 Service 第一次创建的时候调用的，而 onStartCommand () 方法则 在每次启动 Service 的时候都会调用。由于刚才我们是第一次点击 “Start Service” 按钮， Service 此时还未创建过，所以两个方法都会执行，之后如果你再连续多点击几次 “Start Service” 按钮，你就会发现只有 onStartCommand () 方法可以得到执行了。</p><h3 id="Activity-和-Service-进行通信"><a href="#Activity-和-Service-进行通信" class="headerlink" title="Activity 和 Service 进行通信"></a>Activity 和 Service 进行通信</h3><p>使用 onBind () 方法</p><p>比如说，目前我们希望在 MyService 里提供一个下载功能，然后在 Activity 中可以决定何时开始 下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的 Binder 对象来对下载功 能进行管理。修改 MyService 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyService : Service() &#123;</span><br><span class="line">    private val mBinder = DownloadBinder()</span><br><span class="line">    </span><br><span class="line">    class DownloadBinder : Binder()&#123;</span><br><span class="line">        </span><br><span class="line">        fun startDownload()&#123;</span><br><span class="line">            Log.d(&quot;MyService&quot;,&quot;startDownload executed&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fun getProgress() : Int &#123;</span><br><span class="line">            Log.d(&quot;MyService&quot;,&quot;getProgress executed&quot;)</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onBind(intent:Intent) : IBinder&#123;</span><br><span class="line">        return mBinder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们新建了一个 DownloadBinder 类，并让它继承自 Binder，然后在它的内 部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法，并没有实现真正的功 能，我们在这两个方法中分别打印了一行日志。</p><p>接着，在 MyService 中创建了 DownloadBinder 的实例，然后在 onBind () 方法里返回了这个 实例，这样 MyService 中的工作就全部完成了。</p><p>下面就要看一看在 Activity 中如何调用 Service 里的这些方法了。首先需要在布局文件里新增两 个按钮，修改 activity_main.xml 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class="line">     android:orientation=&quot;vertical&quot; </span><br><span class="line">     android:layout_width=&quot;match_parent&quot; </span><br><span class="line">     android:layout_height=&quot;match_parent&quot;&gt; </span><br><span class="line"></span><br><span class="line">         ... </span><br><span class="line"></span><br><span class="line">             &lt;Button </span><br><span class="line">                 android:id=&quot;@+id/bindServiceBtn&quot; </span><br><span class="line">                 android:layout_width=&quot;match_parent&quot; </span><br><span class="line">                 android:layout_height=&quot;wrap_content&quot; </span><br><span class="line">                 android:text=&quot;Bind Service&quot; /&gt; </span><br><span class="line"></span><br><span class="line">             &lt;Button </span><br><span class="line">                 android:id=&quot;@+id/unbindServiceBtn&quot; </span><br><span class="line">                 android:layout_width=&quot;match_parent&quot; </span><br><span class="line">                 android:layout_height=&quot;wrap_content&quot; </span><br><span class="line">                 android:text=&quot;Unbind Service&quot; /&gt; </span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>这两个按钮分别是用于绑定和取消绑定 Service 的，那到底谁需要和 Service 绑定呢？当然就是 Activity 了。当一个 Activity 和 Service 绑定了之后，就可以调用该 Service 里的 Binder 提供的 方法了。修改 MainActivity 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity()&#123;</span><br><span class="line">    lateinit var downloadBinder : MyService.DownloadBinder</span><br><span class="line">    </span><br><span class="line">    private val connection = object : ServiceConnection&#123;</span><br><span class="line">        override fun onServiceConnected(name:ComponentName,service:IBinder)&#123;</span><br><span class="line">            downloadBinder = service as MyService.DownloadBinder</span><br><span class="line">            downloadBinder.startDownload()</span><br><span class="line">            downloadBinder.getProgress()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        override fun onServiceDisconnected(name : ComponentName)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?)&#123;</span><br><span class="line">        、、、</span><br><span class="line">        bindServiceBtn.setOnClickListener&#123;</span><br><span class="line">            val intent = Intent(this, MyService::class.java)</span><br><span class="line">            bindService(intent,connection,Context.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line">        unbindServiceBtn.setOnClickListener&#123;</span><br><span class="line">            unbindService(connection)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service-的生命周期"><a href="#Service-的生命周期" class="headerlink" title="Service 的生命周期"></a>Service 的生命周期</h2><p>一旦在项目的任何位置调用了 Context 的 startService() 方法，相应的 Service 就会启动， 并回调 onStartCommand () 方法。如果这个 Service 之前还没有创建过，onCreate () 方法会 先于 onStartCommand () 方法执行。Service 启动了之后会一直保持运行状态，直到 stopService() 或 stopSelf () 方法被调用，或者被系统回收。注意，虽然每调用一次 startService() 方法，onStartCommand () 就会执行一次，但实际上每个 Service 只会存在 一个实例。所以不管你调用了多少次 startService() 方法，只需调用一次 stopService() 或 stopSelf () 方法，Service 就会停止。 另外，还可以调用 Context 的 bindService() 来获取一个 Service 的持久连接，这时就会回调 Service 中的 onBind () 方法。类似地，如果这个 Service 之前还没有创建过，onCreate () 方 法会先于 onBind () 方法执行。之后，调用方可以获取到 onBind () 方法里返回的 IBinder 对象 的实例，这样就能自由地和 Service 进行通信了。只要调用方和 Service 之间的连接没有断开， Service 就会一直保持运行状态，直到被系统回收。 当调用了 startService() 方法后，再去调用 stopService() 方法。这时 Service 中的 onDestroy () 方法就会执行，表示 Service 已经销毁了。类似地，当调用了 bindService() 方法后，再去调用 unbindService() 方法，onDestroy () 方法也会执行，这两种情况都很好 理解。但是需要注意，我们是完全有可能对一个 Service 既调用了 startService() 方法，又 调用了 bindService() 方法的，在这种情况下该如何让 Service 销毁呢？根据 Android 系统的 机制，一个 Service 只要被启动或者被绑定了之后，就会处于运行状态，必须要让以上两种条件 同时不满足，Service 才能被销毁。所以，这种情况下要同时调用 stopService() 和 unbindService() 方法，onDestroy () 方法才会执行。 这样你就把 Service 的生命周期完整地走了一遍。</p><h2 id="Service-的更多技巧"><a href="#Service-的更多技巧" class="headerlink" title="Service 的更多技巧"></a>Service 的更多技巧</h2><h3 id="使用前台-Service"><a href="#使用前台-Service" class="headerlink" title="使用前台 Service"></a>使用前台 Service</h3><p>修改 MyService 中的代 码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyService : Service()&#123;</span><br><span class="line">    、、、</span><br><span class="line">    override fun onCreate()&#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        Log.d(&quot;MyService&quot;,&quot;onCreate executed&quot;)</span><br><span class="line">        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager</span><br><span class="line">        if(Build.VERSION.SDK_INT &gt;= Build&gt;VERSION_CODES.0)&#123;</span><br><span class="line">            val channel = NotoficationManager(&quot;my_service&quot;,&quot;前台Service通知&quot;,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">            manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line">        val intent = Intent(this, MainActivity::class.java)</span><br><span class="line">        val pi = PendingIntent.getActivity(this,0,intent,0)</span><br><span class="line">        val notification = NotificationCompat.Builder(this,&quot;my_service&quot;)</span><br><span class="line">        .setContextTitle(&quot;This is content text&quot;)</span><br><span class="line">        .setSmallIcon(R.drawable.small_icon)</span><br><span class="line">        .setLargeIcon(BitmapFactory.decodeResource(resoruces,R.drabable.large_icon))</span><br><span class="line">        .setContentIntent(pi)</span><br><span class="line">        .build()</span><br><span class="line">        startForeground(1,notification)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 startForeground () 方法后就会让 MyService 变成一个前 台 Service，并在系统状态栏显示出来。</p><p>另外，从 Android 9.0 系统开始，使用前台 Service 必须在 AndroidManifest.xml 文件中进行权 限声明才行，而且如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class="line"> package=&quot;com.example.servicetest&quot;&gt; </span><br><span class="line">     &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;添加这个</span><br><span class="line">     &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_DATA_SYNC&quot;/&gt;/*添加这个，对应android:foregroundServiceType=&quot;dataSync&quot;所需要的权限*/</span><br><span class="line">         ... </span><br><span class="line">        &lt;service</span><br><span class="line">            android:name=&quot;.MyService&quot;</span><br><span class="line">            android:enabled=&quot;true&quot;</span><br><span class="line">            android:exported=&quot;false&quot;</span><br><span class="line">            android:foregroundServiceType=&quot;dataSync&quot;/&gt;/*添加这个属性，前台service一定要的，也可以是mediaPlayback等，但要添加相应的权限*/</span><br><span class="line">            ...</span><br><span class="line">&lt;/manifest&gt; </span><br></pre></td></tr></table></figure><p>现在即使你退出应用程序，MyService 也会一直处于运行状态，而且不用担心会被系统回收。 当然，MyService 所对应的通知也会一直显示在状态栏上面。如果用户不希望我们的程序一直 运行，也可以选择手动杀掉应用，这样 MyService 就会跟着一起停止运行了。</p><h3 id="使用-IntentService"><a href="#使用-IntentService" class="headerlink" title="使用 IntentService"></a>使用 IntentService</h3><p>Android 专门提供了一个 IntentService 类，这个类就很好地解决了前面所提到的两种尴尬，下面我们就来看一下它的用法。</p><p>新建一个 MyIntentService 类继承自 IntentService，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyIntentService : IntentService(&quot;MyIntentService&quot;)&#123;</span><br><span class="line">    override fun onHandleIntent(intent:Intent?)&#123;</span><br><span class="line">        //打印当前线程的id</span><br><span class="line">        Log.d(&quot;MyIntentService&quot;, &quot;Thread id is $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onDestroy()&#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        Log.d(&quot;MyIntentService&quot;,&quot;onDestroy executed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来修改 activity_main.xml 中的代码，加入一个用于启动 MyIntentService 的按钮，如下 所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class="line"> android:orientation=&quot;vertical&quot; </span><br><span class="line"> android:layout_width=&quot;match_parent&quot; </span><br><span class="line"> android:layout_height=&quot;match_parent&quot;&gt; </span><br><span class="line"> </span><br><span class="line">     ... </span><br><span class="line"></span><br><span class="line">     &lt;Button </span><br><span class="line">         android:id=&quot;@+id/startIntentServiceBtn&quot; </span><br><span class="line">         android:layout_width=&quot;match_parent&quot; </span><br><span class="line">         android:layout_height=&quot;wrap_content&quot; </span><br><span class="line">         android:text=&quot;Start IntentService&quot; /&gt; </span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt; </span><br></pre></td></tr></table></figure><p>然后修改 MainActivity 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity()&#123;</span><br><span class="line">    、、、</span><br><span class="line">    override fun onCreate(savedInstanceState:Bundle?)&#123;</span><br><span class="line">        、、、</span><br><span class="line">        startIntentServiceBtn.setOnClickListener&#123;</span><br><span class="line">            //打印主线程的id</span><br><span class="line">            Log.d(&quot;MainActivity&quot;,&quot;Thread id is $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">            val intent = Intent(this,MyIntentService::class.java)</span><br><span class="line">            startService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在 “Start IntentService” 按钮的点击事件里启动了 MyIntentService，并在这 里打印了一下主线程名，稍后用于和 IntentService 进行比对。你会发现，其实 IntentService 的启动方式和普通的 Service 没什么两样</p><p>最后不要忘记，Service 都是需要在 AndroidManifest.xml 里注册的，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">、、、</span><br><span class="line">&lt;service</span><br><span class="line">         android:name=&quot;MyIntentService&quot;</span><br><span class="line">         android:enabled=&quot;true&quot;</span><br><span class="line">         android:exported=&quot;true&quot;</span><br><span class="line">         /&gt;</span><br><span class="line">、、、</span><br></pre></td></tr></table></figure><h2 id="Kotlin-课堂：泛型的高级特性"><a href="#Kotlin-课堂：泛型的高级特性" class="headerlink" title="Kotlin 课堂：泛型的高级特性"></a>Kotlin 课堂：泛型的高级特性</h2><h3 id="对泛型进行实化"><a href="#对泛型进行实化" class="headerlink" title="对泛型进行实化"></a>对泛型进行实化</h3><p>那么具体该怎么写才能将泛型实化呢？首先，该函数必须是内联函数才行，也就是要用 inline 关键字来修饰该函数。其次，在声明泛型的地方必须加上 reified 关键字来表示该泛型要进行 实化。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; getGenericType() &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数中的泛型 T 就是一个被实化的泛型，因为它满足了内联函数和 reified 关键字这两个前 提条件。那么借助泛型实化，到底可以实现什么样的效果呢？从函数名就可以看出来了，这里 我们准备实现一个获取泛型实际类型的功能，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; getGenericType() = T::class.java </span><br></pre></td></tr></table></figure><p>虽然只有一行代码，但是这里却实现了一个 Java 中完全不可能实现的功能： getGenericType () 函数直接返回了当前指定泛型的实际类型。T.class 这样的语法在 Java 中是不合法的，而在 Kotlin 中，借助泛型实化功能就可以使用 T::class.java 这样的语法了</p><p>现在我们可以使用如下代码对 getGenericType () 函数进行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main() &#123; </span><br><span class="line">     val result1 = getGenericType&lt;String&gt;() </span><br><span class="line">     val result2 = getGenericType&lt;Int&gt;() </span><br><span class="line">     println(&quot;result1 is $result1&quot;) </span><br><span class="line">     println(&quot;result2 is $result2&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型实化的应用"><a href="#泛型实化的应用" class="headerlink" title="泛型实化的应用"></a>泛型实化的应用</h3><p>新建一个 reiﬁed.kt 文件，然后在里面编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; startActivity(context: Context) &#123; </span><br><span class="line">     val intent = Intent(context, T::class.java) </span><br><span class="line">     context.startActivity(intent) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个 startActivity () 函数，该函数接收一个 Context 参数，并同时使用 inline 和 reified 关键字让泛型 T 成为了一个被实化的泛型。接下来就是神奇的地方了， Intent 接收的第二个参数本来应该是一个具体 Activity 的 Class 类型，但由于现在 T 已经是一个 被实化的泛型了，因此这里我们可以直接传入 T::class.java。最后调用 Context 的 startActivity () 方法来完成 Activity 的启动</p><p>现在，如果我们想要启动 TestActivity，只需要这样写就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context) </span><br></pre></td></tr></table></figure><p>添加一个新的 startActivity () 函数重载，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; startActivity(context: Context, block: Intent.() -&gt; Unit) &#123; </span><br><span class="line">     val intent = Intent(context, T::class.java) </span><br><span class="line">     intent.block() </span><br><span class="line">     context.startActivity(intent) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看到，这次的 startActivity () 函数中增加了一个函数类型参数，并且它的函数类型是 定义在 Intent 类当中的。在创建完 Intent 的实例之后，随即调用该函数类型参数，并把 Intent 的 实例传入，这样调用 startActivity () 函数的时候就可以在 Lambda 表达式中为 Intent 传递 参数了，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context) &#123; </span><br><span class="line">     putExtra(&quot;param1&quot;, &quot;data&quot;) </span><br><span class="line">     putExtra(&quot;param2&quot;, 123) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WorkManager用法示例</title>
      <link href="/2025/03/28/WorkManager%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/28/WorkManager%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="WorkManager-是什么？"><a href="#WorkManager-是什么？" class="headerlink" title="WorkManager 是什么？"></a><strong>WorkManager 是什么？</strong></h2><p>WorkManager 是 Android 用来执行<strong>后台任务</strong>的工具，适用于：</p><ul><li><strong>执行一次</strong>的任务（比如：上传日志、备份数据）。</li><li><strong>定期执行</strong>的任务（比如：每 15 分钟同步数据）。</li><li><strong>即使应用关闭、设备重启后也能执行</strong>的任务。</li></ul><hr><h2 id="1-引入-WorkManager"><a href="#1-引入-WorkManager" class="headerlink" title="1. 引入 WorkManager"></a><strong>1. 引入 WorkManager</strong></h2><p>先在 <code>build.gradle.kts</code>（模块级）中添加依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;) // WorkManager 最新版</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 <strong>同步 Gradle</strong>（点击“Sync Now”）。</p><hr><h2 id="2-创建-Worker"><a href="#2-创建-Worker" class="headerlink" title="2. 创建 Worker"></a><strong>2. 创建 Worker</strong></h2><p>Worker 是 WorkManager 执行任务的地方。我们需要创建一个类，继承 <code>Worker</code> 或 <code>CoroutineWorker</code>（推荐）。</p><h3 id="简单任务示例"><a href="#简单任务示例" class="headerlink" title="简单任务示例"></a><strong>简单任务示例</strong></h3><p>新建一个 <code>MyWorker.kt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import android.util.Log</span><br><span class="line">import androidx.work.Worker</span><br><span class="line">import androidx.work.WorkerParameters</span><br><span class="line"></span><br><span class="line">class MyWorker(context: Context, workerParams: WorkerParameters) : Worker(context, workerParams) &#123;</span><br><span class="line">    override fun doWork(): Result &#123;</span><br><span class="line">        Log.d(&quot;MyWorker&quot;, &quot;后台任务正在执行...&quot;)</span><br><span class="line"></span><br><span class="line">        // 假设任务执行成功</span><br><span class="line">        return Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-在应用中启动-WorkManager"><a href="#3-在应用中启动-WorkManager" class="headerlink" title="3. 在应用中启动 WorkManager"></a><strong>3. 在应用中启动 WorkManager</strong></h2><p>在 <code>MainActivity.kt</code> 里启动这个任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.work.OneTimeWorkRequest</span><br><span class="line">import androidx.work.WorkManager</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        // 创建一个任务</span><br><span class="line">        val workRequest = OneTimeWorkRequest.Builder(MyWorker::class.java).build()</span><br><span class="line"></span><br><span class="line">        // 启动任务</span><br><span class="line">        WorkManager.getInstance(this).enqueue(workRequest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，每次启动应用，WorkManager 就会执行 <code>MyWorker</code> 里的代码。</p><hr><h2 id="4-传递参数"><a href="#4-传递参数" class="headerlink" title="4. 传递参数"></a><strong>4. 传递参数</strong></h2><p>如果 Worker 需要参数，比如<strong>下载文件的 URL</strong>，可以这样传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.work.Data</span><br><span class="line"></span><br><span class="line">val data = Data.Builder()</span><br><span class="line">    .putString(&quot;url&quot;, &quot;https://example.com/file.jpg&quot;)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">val workRequest = OneTimeWorkRequest.Builder(MyWorker::class.java)</span><br><span class="line">    .setInputData(data) // 传递参数</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(this).enqueue(workRequest)</span><br></pre></td></tr></table></figure><p>然后在 <code>MyWorker</code> 里接收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override fun doWork(): Result &#123;</span><br><span class="line">    val url = inputData.getString(&quot;url&quot;) ?: &quot;未提供 URL&quot;</span><br><span class="line">    Log.d(&quot;MyWorker&quot;, &quot;下载文件：$url&quot;)</span><br><span class="line"></span><br><span class="line">    return Result.success()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-周期性任务"><a href="#5-周期性任务" class="headerlink" title="5. 周期性任务"></a><strong>5. 周期性任务</strong></h2><p>如果任务需要<strong>定期执行</strong>（比如每 15 分钟备份数据），可以用 <code>PeriodicWorkRequest</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import androidx.work.PeriodicWorkRequest</span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">val periodicWorkRequest = PeriodicWorkRequest.Builder(MyWorker::class.java, 15, TimeUnit.MINUTES)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(this).enqueue(periodicWorkRequest)</span><br></pre></td></tr></table></figure><p>⚠️ <strong>注意</strong>：最小间隔是 <strong>15 分钟</strong>，不能更短！</p><hr><h2 id="6-任务约束（例如仅在-WiFi-下运行）"><a href="#6-任务约束（例如仅在-WiFi-下运行）" class="headerlink" title="6. 任务约束（例如仅在 WiFi 下运行）"></a><strong>6. 任务约束（例如仅在 WiFi 下运行）</strong></h2><p>可以加一些条件，比如：</p><ul><li>只有在 <strong>WiFi 连接</strong> 时运行。</li><li>只有在 <strong>充电状态</strong> 时运行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import androidx.work.Constraints</span><br><span class="line">import androidx.work.NetworkType</span><br><span class="line"></span><br><span class="line">val constraints = Constraints.Builder()</span><br><span class="line">    .setRequiredNetworkType(NetworkType.UNMETERED) // WiFi 才执行</span><br><span class="line">    .setRequiresCharging(true) // 充电时才执行</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">val workRequest = OneTimeWorkRequest.Builder(MyWorker::class.java)</span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(this).enqueue(workRequest)</span><br></pre></td></tr></table></figure><hr><h2 id="7-监听任务状态"><a href="#7-监听任务状态" class="headerlink" title="7. 监听任务状态"></a><strong>7. 监听任务状态</strong></h2><p>如果想知道任务是否执行成功，可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val workManager = WorkManager.getInstance(this)</span><br><span class="line">workManager.getWorkInfoByIdLiveData(workRequest.id).observe(this) &#123; workInfo -&gt;</span><br><span class="line">    if (workInfo != null) &#123;</span><br><span class="line">        when (workInfo.state) &#123;</span><br><span class="line">            WorkInfo.State.ENQUEUED -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务等待中&quot;)</span><br><span class="line">            WorkInfo.State.RUNNING -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务执行中&quot;)</span><br><span class="line">            WorkInfo.State.SUCCEEDED -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务成功&quot;)</span><br><span class="line">            WorkInfo.State.FAILED -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务失败&quot;)</span><br><span class="line">            WorkInfo.State.CANCELLED -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务已取消&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8-取消任务"><a href="#8-取消任务" class="headerlink" title="8. 取消任务"></a><strong>8. 取消任务</strong></h2><p>可以随时取消任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(this).cancelWorkById(workRequest.id) // 取消某个任务</span><br><span class="line">WorkManager.getInstance(this).cancelAllWork() // 取消所有任务</span><br></pre></td></tr></table></figure><hr><h2 id="9-链式任务（Chained-Work）"><a href="#9-链式任务（Chained-Work）" class="headerlink" title="9. 链式任务（Chained Work）"></a>9. 链式任务（Chained Work）</h2><ul><li><p><strong>作用：</strong> 如果有多个任务需要依次执行，比如先下载数据再处理数据，可以把它们链接起来。</p></li><li><p><strong>简单例子：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val workA = OneTimeWorkRequestBuilder&lt;WorkerA&gt;().build()</span><br><span class="line">val workB = OneTimeWorkRequestBuilder&lt;WorkerB&gt;().build()</span><br><span class="line">val workC = OneTimeWorkRequestBuilder&lt;WorkerC&gt;().build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(context)</span><br><span class="line">    .beginWith(workA)   // 先执行 workA</span><br><span class="line">    .then(workB)        // workA 执行完后再执行 workB</span><br><span class="line">    .then(workC)        // workB 执行完后再执行 workC</span><br><span class="line">    .enqueue()          // 提交整个链条任务</span><br></pre></td></tr></table></figure><p>这样就能保证任务按照你设定的顺序依次完成。</p></li></ul><hr><h2 id="10-唯一任务（Unique-Work）"><a href="#10-唯一任务（Unique-Work）" class="headerlink" title="10. 唯一任务（Unique Work）"></a>10. 唯一任务（Unique Work）</h2><ul><li><p><strong>作用：</strong> 防止同样的任务重复执行。比如不希望同时有两个相同的任务在运行。</p></li><li><p><strong>简单例子：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val uniqueWorkRequest = OneTimeWorkRequestBuilder&lt;MyWorker&gt;().build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(context).enqueueUniqueWork(</span><br><span class="line">    &quot;uniqueTask&quot;,                  // 给任务起一个唯一的名字</span><br><span class="line">    ExistingWorkPolicy.REPLACE,    // 如果已有同名任务，替换掉旧的任务</span><br><span class="line">    uniqueWorkRequest</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用唯一任务可以确保同一时刻不会有多个相同任务重复运行。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>功能</th><th>代码</th></tr></thead><tbody><tr><td><strong>一次性任务</strong></td><td><code>OneTimeWorkRequest.Builder(MyWorker::class.java).build()</code></td></tr><tr><td><strong>周期性任务</strong></td><td><code>PeriodicWorkRequest.Builder(MyWorker::class.java, 15, TimeUnit.MINUTES).build()</code></td></tr><tr><td><strong>传递参数</strong></td><td><code>Data.Builder().putString(&quot;key&quot;, &quot;value&quot;).build()</code></td></tr><tr><td><strong>添加约束</strong></td><td><code>Constraints.Builder().setRequiredNetworkType(NetworkType.UNMETERED).build()</code></td></tr><tr><td><strong>监听任务状态</strong></td><td><code>workManager.getWorkInfoByIdLiveData(id).observe(...)</code></td></tr><tr><td><strong>取消任务</strong></td><td><code>WorkManager.getInstance(this).cancelWorkById(id)</code></td></tr></tbody></table><hr><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h2><ul><li><strong>一次性任务</strong>（如：上传日志、备份数据库）。</li><li><strong>定期任务</strong>（如：自动同步数据，每天上传一次）。</li><li><strong>后台任务</strong>（如：下载大文件）。</li><li><strong>任务可以应用退出后执行</strong>（如：应用关闭后仍继续备份数据）。</li></ul><p><strong>❌ WorkManager 不能做的事情</strong></p><ul><li><strong>定时精准任务</strong>（比如定点 3:00AM 运行，推荐用 <code>AlarmManager</code>）。</li><li><strong>即时任务</strong>（如果任务必须立刻完成，建议用 <code>ForegroundService</code>）。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AsyncTask的用法示例</title>
      <link href="/2025/03/27/AsyncTask%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/27/AsyncTask%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-中-AsyncTask-的使用教程"><a href="#Kotlin-中-AsyncTask-的使用教程" class="headerlink" title="Kotlin 中 AsyncTask 的使用教程"></a>Kotlin 中 AsyncTask 的使用教程</h1><p>AsyncTask 用于将耗时操作放到后台线程执行，同时在任务开始和结束时在主线程更新 UI。本文将逐步讲解其基本概念、生命周期方法，并提供一个简单的示例代码。</p><p>值得注意的是， 从 Android 11 开始，AsyncTask 已被弃用，建议在新项目中使用 Kotlin 协程、WorkManager 或其他异步方案，本文仅做学习记录使用，而且第一行代码P396 10.2.4讲的更详细更好。</p><hr><h2 id="1-AsyncTask-的基本概念"><a href="#1-AsyncTask-的基本概念" class="headerlink" title="1. AsyncTask 的基本概念"></a>1. AsyncTask 的基本概念</h2><p>AsyncTask 使用三个泛型参数来确定任务的输入、进度和结果类型：</p><ul><li><strong>Params</strong>：传递给任务的参数类型。</li><li><strong>Progress</strong>：任务执行中更新进度时使用的数据类型。</li><li><strong>Result</strong>：任务执行完毕后返回的结果类型。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class MyTask : AsyncTask&lt;Void, Int, String&gt;() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>表示该任务不需要输入参数（Void）、进度为 Int 类型、最终结果为 String。</p><hr><h2 id="2-AsyncTask-的生命周期方法"><a href="#2-AsyncTask-的生命周期方法" class="headerlink" title="2. AsyncTask 的生命周期方法"></a>2. AsyncTask 的生命周期方法</h2><p>AsyncTask 定义了多个回调方法，每个方法在任务执行的不同阶段被调用：</p><ul><li><strong>onPreExecute()</strong><br> 在任务开始前调用，通常用于初始化 UI（例如显示进度条）。</li><li><strong>doInBackground(vararg params: Params)</strong><br> 在后台线程中执行耗时操作。此方法不能直接更新 UI，但可以调用 <code>publishProgress()</code> 触发进度更新。</li><li><strong>onProgressUpdate(vararg values: Progress)</strong><br> 当调用 <code>publishProgress()</code> 时在主线程中执行，用于更新 UI 中的进度显示。</li><li><strong>onPostExecute(result: Result)</strong><br> 在后台任务执行完毕后调用，运行在主线程中，可以使用任务返回的结果更新 UI。</li><li><strong>onCancelled()</strong><br> 当任务被取消时调用，可用于清理操作。</li></ul><hr><h2 id="3-Kotlin-示例代码"><a href="#3-Kotlin-示例代码" class="headerlink" title="3. Kotlin 示例代码"></a>3. Kotlin 示例代码</h2><p>下面的示例展示了如何使用 AsyncTask 在后台模拟一个耗时任务（例如计数操作），并在 UI 上更新进度和显示结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import android.os.AsyncTask</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.widget.ProgressBar</span><br><span class="line">import android.widget.TextView</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var progressBar: ProgressBar</span><br><span class="line">    private lateinit var textView: TextView</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        progressBar = findViewById(R.id.progressBar)</span><br><span class="line">        textView = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">        // 传入一个整数参数，这个参数会被传递到doInBackground()方法当中，例如：10</span><br><span class="line">        MyTask().execute(10)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // MyTask 类继承自 AsyncTask&lt;Int, Int, String&gt;</span><br><span class="line">    private inner class MyTask : AsyncTask&lt;Int, Int, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        // 在任务开始前调用，通常用于初始化界面，比如显示进度条</span><br><span class="line">        override fun onPreExecute() &#123;</span><br><span class="line">            super.onPreExecute()</span><br><span class="line">            progressBar.progress = 0</span><br><span class="line">            textView.text = &quot;任务开始...&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 在后台线程中执行耗时操作</span><br><span class="line">        // params 数组中包含 execute() 方法传入的参数，这里我们只传入一个 Int 类型的参数</span><br><span class="line">        override fun doInBackground(vararg params: Int?): String &#123;</span><br><span class="line">            // 获取传入的参数值，假设它表示任务总步数</span><br><span class="line">            val totalSteps = params.firstOrNull() ?: 0</span><br><span class="line">            for (i in 1..totalSteps) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 模拟耗时操作，例如睡眠 1 秒</span><br><span class="line">                    Thread.sleep(1000)</span><br><span class="line">                &#125; catch (e: InterruptedException) &#123;</span><br><span class="line">                    e.printStackTrace()</span><br><span class="line">                &#125;</span><br><span class="line">                // 调用 publishProgress() 更新进度，触发 onProgressUpdate()</span><br><span class="line">                publishProgress(i)</span><br><span class="line">            &#125;</span><br><span class="line">            // 返回任务完成后的结果</span><br><span class="line">            return &quot;任务完成，共计 $totalSteps 秒&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 在主线程中接收并更新任务进度</span><br><span class="line">        override fun onProgressUpdate(vararg values: Int?) &#123;</span><br><span class="line">            super.onProgressUpdate(*values)</span><br><span class="line">            // 更新 ProgressBar 和 TextView 显示当前进度</span><br><span class="line">            values.firstOrNull()?.let &#123; progress -&gt;</span><br><span class="line">                progressBar.progress = progress * 100 / (intent.getIntExtra(&quot;TOTAL_STEPS&quot;, 10))</span><br><span class="line">                textView.text = &quot;当前进度: $progress/$&#123;intent.getIntExtra(&quot;TOTAL_STEPS&quot;, 10)&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 在任务执行完毕后调用，传入 doInBackground() 返回的结果</span><br><span class="line">        override fun onPostExecute(result: String?) &#123;</span><br><span class="line">            super.onPostExecute(result)</span><br><span class="line">            textView.text = result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 可选：任务取消时调用</span><br><span class="line">        override fun onCancelled() &#123;</span><br><span class="line">            super.onCancelled()</span><br><span class="line">            textView.text = &quot;任务取消&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ul><li><strong>onPreExecute()</strong><br> 初始化 ProgressBar 和 TextView 的显示状态。</li><li><strong>doInBackground()</strong><br> 在后台执行一个简单的循环操作，每次循环暂停 50 毫秒，并调用 <code>publishProgress()</code> 更新 UI 的进度。</li><li><strong>onProgressUpdate()</strong><br> 接收到进度后，在主线程更新 ProgressBar 和 TextView。</li><li><strong>onPostExecute()</strong><br> 当任务执行完毕后，显示完成消息。</li></ul><hr><h2 id="4-注意事项与最佳实践"><a href="#4-注意事项与最佳实践" class="headerlink" title="4. 注意事项与最佳实践"></a>4. 注意事项与最佳实践</h2><ul><li><strong>内存泄漏问题</strong><br> 如果 AsyncTask 是作为 Activity 的内部类存在，当 Activity 被销毁时可能导致内存泄漏。建议将 AsyncTask 定义为静态内部类，并通过 WeakReference 持有 Activity 的引用。</li><li><strong>执行策略</strong><br> 在 API 11（Android 3.0）及以上版本，AsyncTask 默认串行执行。如果需要并行执行，可以使用 <code>executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)</code>。</li><li><strong>已弃用提醒</strong><br> 从 Android 11 开始，AsyncTask 已被弃用，建议在新项目中使用 Kotlin 协程、WorkManager 或其他异步方案。</li></ul><hr><h2 id="5-为什么推荐-Kotlin-协程？"><a href="#5-为什么推荐-Kotlin-协程？" class="headerlink" title="5. 为什么推荐 Kotlin 协程？"></a>5. 为什么推荐 Kotlin 协程？</h2><ul><li><strong>代码简洁</strong><br> Kotlin 协程可以让异步代码写得像同步代码，减少回调层级和代码冗余。</li><li><strong>更好的错误处理与取消机制</strong><br> 协程内置了结构化并发，便于管理任务生命周期和异常处理。</li><li><strong>官方支持</strong><br> 谷歌和 JetBrains 都推荐在 Android 项目中使用 Kotlin 协程来处理异步任务。</li></ul><hr><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文详细介绍了在 Kotlin 中使用 AsyncTask 的方法，包括各个生命周期回调的作用和示例代码。虽然 AsyncTask 曾经为 Android 异步处理提供了简化方案，但随着技术的发展，Kotlin 协程已成为更推荐的选择。在学习 AsyncTask 的同时，建议大家尽快熟悉并尝试使用 Kotlin 协程以提升代码的简洁性和可维护性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>infix用法示例</title>
      <link href="/2025/03/26/inflix%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/26/inflix%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-infix-函数？"><a href="#什么是-infix-函数？" class="headerlink" title="什么是 infix 函数？"></a><strong>什么是 <code>infix</code> 函数？</strong></h3><p><code>infix</code> 关键字可以让 <strong>单参数的函数</strong> 以 <strong>更自然的语法</strong> 书写，使代码更易读。<br> 你可以把它理解为 <strong>一种特殊的调用方式</strong>，不需要 <code>.</code> 和 <code>()</code>，让代码像 <strong>自然语言</strong> 一样流畅。</p><p>要使用 <code>infix</code>，需要满足 <strong>三个条件</strong>：</p><ol><li><strong>必须是成员函数或扩展函数</strong>（它必须属于某个类或某种类型）。</li><li><strong>必须只有且只能有一个参数</strong>（如果有多个参数，就不能用 <code>infix</code>）。</li><li>⭐⭐⭐⭐⭐⭐<strong>调用时可以省略 <code>.</code> 和 <code>()</code></strong>（但仍然可以用 <code>.</code> 调用）。</li></ol><hr><h3 id="简单示例-1：数字比较"><a href="#简单示例-1：数字比较" class="headerlink" title="简单示例 1：数字比较"></a><strong>简单示例 1：数字比较</strong></h3><h4 id="不使用-infix"><a href="#不使用-infix" class="headerlink" title="不使用 infix"></a><strong>不使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun isBigger(a: Int, b: Int): Boolean &#123;</span><br><span class="line">    return a &gt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(isBigger(10, 5)) // 输出：true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数 <code>isBigger(10, 5)</code> 可读性一般，我们可以用 <code>infix</code> 改写它。</p><hr><h4 id="使用-infix"><a href="#使用-infix" class="headerlink" title="使用 infix"></a><strong>使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">infix fun Int.isBiggerThan(other: Int): Boolean &#123;</span><br><span class="line">    return this &gt; other</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(10 isBiggerThan 5) // 输出：true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <code>10 isBiggerThan 5</code> 读起来就像 <strong>自然语言</strong>，比 <code>isBigger(10, 5)</code> 更易懂。</p><hr><h3 id="简单示例-2：创建-“名字-值”-对"><a href="#简单示例-2：创建-“名字-值”-对" class="headerlink" title="简单示例 2：创建 “名字-值” 对"></a><strong>简单示例 2：创建 “名字-值” 对</strong></h3><h4 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a><strong>普通方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun pair(key: String, value: String): Pair&lt;String, String&gt; &#123;</span><br><span class="line">    return Pair(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val result = pair(&quot;name&quot;, &quot;Alice&quot;)</span><br><span class="line">    println(result) // 输出： (name, Alice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="使用-infix-1"><a href="#使用-infix-1" class="headerlink" title="使用 infix"></a><strong>使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">infix fun String.with(value: String): Pair&lt;String, String&gt; &#123;</span><br><span class="line">    return Pair(this, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val result = &quot;name&quot; with &quot;Alice&quot;</span><br><span class="line">    println(result) // 输出： (name, Alice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <code>&quot;name&quot; with &quot;Alice&quot;</code> 读起来更像 <strong>自然语言</strong>，比 <code>pair(&quot;name&quot;, &quot;Alice&quot;)</code> 更直观。</p><hr><h3 id="简单示例-3：自定义数学运算"><a href="#简单示例-3：自定义数学运算" class="headerlink" title="简单示例 3：自定义数学运算"></a><strong>简单示例 3：自定义数学运算</strong></h3><h4 id="普通加法"><a href="#普通加法" class="headerlink" title="普通加法"></a><strong>普通加法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    fun add(other: Point): Point &#123;</span><br><span class="line">        return Point(this.x + other.x, this.y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(2, 3)</span><br><span class="line">    val p2 = Point(4, 5)</span><br><span class="line">    val result = p1.add(p2)</span><br><span class="line"></span><br><span class="line">    println(&quot;($&#123;result.x&#125;, $&#123;result.y&#125;)&quot;) // 输出：(6, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="使用-infix-2"><a href="#使用-infix-2" class="headerlink" title="使用 infix"></a><strong>使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    infix fun add(other: Point): Point &#123;</span><br><span class="line">        return Point(this.x + other.x, this.y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(2, 3)</span><br><span class="line">    val p2 = Point(4, 5)</span><br><span class="line">    val result = p1 add p2  // 👈 重点：不需要 `.` 和 `()` 了！</span><br><span class="line"></span><br><span class="line">    println(&quot;($&#123;result.x&#125;, $&#123;result.y&#125;)&quot;) // 输出：(6, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <code>p1 add p2</code> <strong>比 <code>p1.add(p2)</code> 更像数学公式</strong>，可读性更强。</p><h4 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    infix fun Point.add(other: Point): Point &#123; //和正确例子唯一差别就是这一行</span><br><span class="line">        return Point(this.x + other.x, this.y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(2, 3)</span><br><span class="line">    val p2 = Point(4, 5)</span><br><span class="line">    val result = p1 add p2  // 👈 重点：不需要 . 和 () 了！</span><br><span class="line"></span><br><span class="line">    println(&quot;($&#123;result.x&#125;, $&#123;result.y&#125;)&quot;) // 输出：(6, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>不能编译</strong>，是因为 <strong>infix 函数不能在类内部对自身类型（<code>Point</code>）扩展</strong>。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><strong><code>infix</code> 让代码更像自然语言，增强可读性</strong>。</li><li><strong>只能用于</strong>：<ul><li><strong>类的成员函数</strong>（如 <code>Point</code> 里的 <code>add</code>）。</li><li><strong>扩展函数</strong>（如 <code>String.with()</code>）。</li><li><strong>且只接受一个参数</strong>。</li></ul></li><li><strong>调用时可以省略 <code>.</code> 和 <code>()</code></strong>，让代码更流畅。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide的基本用法</title>
      <link href="/2025/03/24/Glide%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-%E4%B8%80/"/>
      <url>/2025/03/24/Glide%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/guolin_blog/article/details/53759439">Glide用法一</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/53939176">Glide用法二</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/54895665">Glide用法三</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/70215985">Glide用法四</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/71524668">Glide用法五</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/72866313">Glide用法六</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/78357251">Glide用法七</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/78582548">Glide用法八</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Bitmap.createBitmap()用法示例</title>
      <link href="/2025/03/24/Android-Bitmap-createBitmap-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/24/Android-Bitmap-createBitmap-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-Bitmap-createBitmap-用法全解析"><a href="#Android-Bitmap-createBitmap-用法全解析" class="headerlink" title="Android Bitmap.createBitmap() 用法全解析"></a>Android Bitmap.createBitmap() 用法全解析</h1><p>在 Android 开发中，<code>Bitmap.createBitmap()</code> 是一个非常强大的方法，可以用来 <strong>创建新的位图</strong>，并且可以 <strong>进行旋转、缩放、平移、镜像翻转、裁剪等操作</strong>。本篇文章将详细介绍 <code>Bitmap.createBitmap()</code> 的各种用法。</p><hr><h2 id="1-Bitmap-createBitmap-基础用法"><a href="#1-Bitmap-createBitmap-基础用法" class="headerlink" title="1. Bitmap.createBitmap() 基础用法"></a>1. <code>Bitmap.createBitmap()</code> 基础用法</h2><h3 id="1-1-创建一个空白-Bitmap"><a href="#1-1-创建一个空白-Bitmap" class="headerlink" title="1.1 创建一个空白 Bitmap"></a><strong>1.1 创建一个空白 Bitmap</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)</span><br></pre></td></tr></table></figure><ul><li><code>width</code>：Bitmap 的宽度。</li><li><code>height</code>：Bitmap 的高度。</li><li><code>Bitmap.Config.ARGB_8888</code>：像素格式，支持透明度。</li></ul><blockquote><p><strong>用途</strong>：用于创建空白的 <code>Bitmap</code>，然后通过 <code>Canvas</code> 进行绘制。</p></blockquote><hr><h2 id="2-旋转（Rotate）"><a href="#2-旋转（Rotate）" class="headerlink" title="2. 旋转（Rotate）"></a>2. 旋转（Rotate）</h2><p>如果拍照后的图片方向不正确，可以使用 <code>Matrix</code> 进行旋转。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rotateBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, degree: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postRotate(degree.toFloat()) <span class="comment">// 旋转 degree 度</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>postRotate(degree)</code>：将图片旋转指定角度。</li></ul><p><strong>示例：旋转 90 度</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rotatedBitmap = rotateBitmap(originalBitmap, <span class="number">90</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="3-缩放（Scale）"><a href="#3-缩放（Scale）" class="headerlink" title="3. 缩放（Scale）"></a>3. 缩放（Scale）</h2><p>如果想要调整图片大小，可以使用 <code>postScale()</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scaleBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, sx: <span class="type">Float</span>, sy: <span class="type">Float</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postScale(sx, sy) <span class="comment">// 设置缩放比例</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：缩小 50%</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scaledBitmap = scaleBitmap(originalBitmap, <span class="number">0.5f</span>, <span class="number">0.5f</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="4-平移（Translate）"><a href="#4-平移（Translate）" class="headerlink" title="4. 平移（Translate）"></a>4. 平移（Translate）</h2><p>可以使用 <code>postTranslate()</code> 来移动 <code>Bitmap</code> 位置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">translateBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, dx: <span class="type">Float</span>, dy: <span class="type">Float</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postTranslate(dx, dy) <span class="comment">// X 方向右移 dx，Y 方向下移 dy</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：右移 50px，下移 100px</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> translatedBitmap = translateBitmap(originalBitmap, <span class="number">50f</span>, <span class="number">100f</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="5-镜像翻转（Flip）"><a href="#5-镜像翻转（Flip）" class="headerlink" title="5. 镜像翻转（Flip）"></a>5. 镜像翻转（Flip）</h2><h3 id="5-1-左右翻转（水平镜像）"><a href="#5-1-左右翻转（水平镜像）" class="headerlink" title="5.1 左右翻转（水平镜像）"></a><strong>5.1 左右翻转（水平镜像）</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">flipHorizontal</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postScale(-<span class="number">1f</span>, <span class="number">1f</span>) <span class="comment">// 水平方向镜像</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-上下翻转（垂直镜像）"><a href="#5-2-上下翻转（垂直镜像）" class="headerlink" title="5.2 上下翻转（垂直镜像）"></a><strong>5.2 上下翻转（垂直镜像）</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">flipVertical</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postScale(<span class="number">1f</span>, -<span class="number">1f</span>) <span class="comment">// 垂直方向镜像</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：左右翻转</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> flippedBitmap = flipHorizontal(originalBitmap)</span><br></pre></td></tr></table></figure><hr><h2 id="6-裁剪（Crop）"><a href="#6-裁剪（Crop）" class="headerlink" title="6. 裁剪（Crop）"></a>6. 裁剪（Crop）</h2><p>如果只想截取 <code>Bitmap</code> 的一部分，可以使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cropBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, x: <span class="type">Int</span>, y: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, x, y, width, height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：从 (50,50) 开始，裁剪 200x200 区域</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> croppedBitmap = cropBitmap(originalBitmap, <span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="7-综合变换：旋转-缩放-平移"><a href="#7-综合变换：旋转-缩放-平移" class="headerlink" title="7. 综合变换：旋转 + 缩放 + 平移"></a>7. 综合变换：旋转 + 缩放 + 平移</h2><p>可以组合多个变换，比如 <strong>先旋转 45°，再缩小 80%，然后平移</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transformBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postRotate(<span class="number">45f</span>)      <span class="comment">// 旋转 45 度</span></span><br><span class="line">    matrix.postScale(<span class="number">0.8f</span>, <span class="number">0.8f</span>) <span class="comment">// 缩小 80%</span></span><br><span class="line">    matrix.postTranslate(<span class="number">100f</span>, <span class="number">50f</span>) <span class="comment">// 右移 100，下移 50</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：应用组合变换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> transformedBitmap = transformBitmap(originalBitmap)</span><br></pre></td></tr></table></figure><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><table><thead><tr><th>操作</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td><strong>创建空白 Bitmap</strong></td><td><code>Bitmap.createBitmap(width, height, config)</code></td><td><code>Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888)</code></td></tr><tr><td><strong>旋转</strong></td><td><code>postRotate(degree)</code></td><td><code>postRotate(90f)</code></td></tr><tr><td><strong>缩放</strong></td><td><code>postScale(sx, sy)</code></td><td><code>postScale(0.5f, 0.5f)</code></td></tr><tr><td><strong>平移</strong></td><td><code>postTranslate(dx, dy)</code></td><td><code>postTranslate(50f, 100f)</code></td></tr><tr><td><strong>水平翻转</strong></td><td><code>postScale(-1f, 1f)</code></td><td><code>postScale(-1f, 1f)</code></td></tr><tr><td><strong>垂直翻转</strong></td><td><code>postScale(1f, -1f)</code></td><td><code>postScale(1f, -1f)</code></td></tr><tr><td><strong>裁剪</strong></td><td><code>Bitmap.createBitmap(bitmap, x, y, w, h)</code></td><td><code>Bitmap.createBitmap(bitmap, 50, 50, 200, 200)</code></td></tr></tbody></table><h3 id="📌-结论："><a href="#📌-结论：" class="headerlink" title="📌 结论："></a><strong>📌 结论：</strong></h3><p><code>Bitmap.createBitmap()</code> <strong>不仅能创建 Bitmap，还能旋转、缩放、平移、镜像翻转、裁剪，几乎所有图片变换都可以搞定！</strong> 🚀</p><p>希望这篇文章能帮你更好地理解 <code>Bitmap.createBitmap()</code> 的使用！ 😊</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通知的用法示例</title>
      <link href="/2025/03/24/%E9%80%9A%E7%9F%A5%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/24/%E9%80%9A%E7%9F%A5%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-通知（Notification）完全指南"><a href="#Android-通知（Notification）完全指南" class="headerlink" title="Android 通知（Notification）完全指南"></a><strong>Android 通知（Notification）完全指南</strong></h2><p><strong>记得在测试APP的通知功能时，要在手机上把关于通知的权限打开!!!</strong></p><h3 id="1-通知的作用"><a href="#1-通知的作用" class="headerlink" title="1. 通知的作用"></a><strong>1. 通知的作用</strong></h3><ul><li><strong>用户提示</strong>：告知用户重要事件，如新消息、下载进度等。</li><li><strong>交互入口</strong>：用户点击通知可跳转至应用的特定页面。</li><li><strong>持续展示</strong>：某些通知需要常驻状态栏，如后台任务提醒。</li></ul><hr><h3 id="2-关键组件"><a href="#2-关键组件" class="headerlink" title="2. 关键组件"></a><strong>2. 关键组件</strong></h3><ul><li><strong>NotificationManager</strong>：管理通知的发布、更新、取消。</li><li><strong>NotificationCompat.Builder</strong>：构建通知，确保兼容低版本 Android。</li><li><strong>NotificationChannel（Android 8.0+）</strong>：管理通知的重要性、声音、震动等。</li><li><strong>PendingIntent</strong>：设定用户点击通知后的操作。</li></ul><hr><h3 id="3-创建通知"><a href="#3-创建通知" class="headerlink" title="3. 创建通知"></a><strong>3. 创建通知</strong></h3><h4 id="3-0-权限"><a href="#3-0-权限" class="headerlink" title="3.0 权限"></a><strong>3.0 权限</strong></h4><p>在 <strong>AndroidManifest.xml</strong> 添加权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.POST_NOTIFICATIONS&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-创建通知频道（Android-8-0-必须）"><a href="#3-1-创建通知频道（Android-8-0-必须）" class="headerlink" title="3.1 创建通知频道（Android 8.0+ 必须）"></a><strong>3.1 创建通知频道（Android 8.0+ 必须）</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    <span class="keyword">val</span> channelId = <span class="string">&quot;channel_id_example&quot;</span></span><br><span class="line">    <span class="keyword">val</span> channelName = <span class="string">&quot;通知频道&quot;</span></span><br><span class="line">    <span class="keyword">val</span> importance = NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">    <span class="keyword">val</span> channel = NotificationChannel(channelId, channelName, importance).apply &#123;</span><br><span class="line">        description = <span class="string">&quot;这个频道用于普通通知&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager这个写法和下面本质一样的，下面的更简洁安全，上面的能兼容旧版本(适用API22以及更早版本)*/</span></span><br><span class="line">    <span class="keyword">val</span> notificationManager = getSystemService(NotificationManager::<span class="keyword">class</span>.java)</span><br><span class="line">    notificationManager.createNotificationChannel(channel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-发送基础通知"><a href="#3-2-发送基础通知" class="headerlink" title="3.2 发送基础通知"></a><strong>3.2 发送基础通知</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channelId = <span class="string">&quot;channel_id_example&quot;</span></span><br><span class="line"><span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">    .setSmallIcon(R.drawable.ic_notification)</span><br><span class="line">    .setContentTitle(<span class="string">&quot;通知标题&quot;</span>)</span><br><span class="line">    .setContentText(<span class="string">&quot;通知内容&quot;</span>)</span><br><span class="line">    .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">notificationManager.notify(<span class="number">1</span>, builder.build())<span class="comment">/*通过 NotificationManager 显示通知。1 作为通知的 唯一 ID，用于标识和更新/取消特定通知。builder.build() 构建通知对象 并发送。*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-添加交互（PendingIntent）"><a href="#4-添加交互（PendingIntent）" class="headerlink" title="4. 添加交互（PendingIntent）"></a><strong>4. 添加交互（PendingIntent）</strong></h3><h4 id="4-1-点击通知跳转到-Activity"><a href="#4-1-点击通知跳转到-Activity" class="headerlink" title="4.1 点击通知跳转到 Activity"></a><strong>4.1 点击通知跳转到 Activity</strong></h4><p>创建一个 <code>TargetActivity</code> 作为跳转目标：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TargetActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改通知代码，添加 <code>PendingIntent</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, TargetActivity::<span class="keyword">class</span>.java)</span><br><span class="line"><span class="keyword">val</span> pendingIntent = PendingIntent.getActivity(</span><br><span class="line">    <span class="keyword">this</span>, <span class="number">0</span>, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">    .setSmallIcon(R.drawable.ic_notification)</span><br><span class="line">    .setContentTitle(<span class="string">&quot;点击查看详情&quot;</span>)</span><br><span class="line">    .setContentText(<span class="string">&quot;点击此通知跳转到 TargetActivity&quot;</span>)</span><br><span class="line">    .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">    .setContentIntent(pendingIntent)</span><br><span class="line">    .setAutoCancel(<span class="literal">true</span>) <span class="comment">// 用户点击后自动清除通知</span></span><br><span class="line"></span><br><span class="line">notificationManager.notify(<span class="number">2</span>, builder.build())</span><br></pre></td></tr></table></figure><hr><h3 id="5-丰富通知内容（setStyle）"><a href="#5-丰富通知内容（setStyle）" class="headerlink" title="5. 丰富通知内容（setStyle）"></a><strong>5. 丰富通知内容（setStyle）</strong></h3><h4 id="5-1-长文本通知（BigTextStyle）"><a href="#5-1-长文本通知（BigTextStyle）" class="headerlink" title="5.1 长文本通知（BigTextStyle）"></a><strong>5.1 长文本通知（BigTextStyle）</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.setStyle(NotificationCompat.BigTextStyle()</span><br><span class="line">    .bigText(<span class="string">&quot;这里是详细的通知内容，适合展示更多的文字信息&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="5-2-大图通知（BigPictureStyle）"><a href="#5-2-大图通知（BigPictureStyle）" class="headerlink" title="5.2 大图通知（BigPictureStyle）"></a><strong>5.2 大图通知（BigPictureStyle）</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bigPicture = BitmapFactory.decodeResource(resources, R.drawable.big_image)</span><br><span class="line">builder.setStyle(NotificationCompat.BigPictureStyle()</span><br><span class="line">    .bigPicture(bigPicture)</span><br><span class="line">    .setBigContentTitle(<span class="string">&quot;大图通知&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="5-3-多条信息通知（InboxStyle）"><a href="#5-3-多条信息通知（InboxStyle）" class="headerlink" title="5.3 多条信息通知（InboxStyle）"></a><strong>5.3 多条信息通知（InboxStyle）</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.setStyle(NotificationCompat.InboxStyle()</span><br><span class="line">    .addLine(<span class="string">&quot;第一条信息&quot;</span>)</span><br><span class="line">    .addLine(<span class="string">&quot;第二条信息&quot;</span>)</span><br><span class="line">    .setSummaryText(<span class="string">&quot;共2条信息&quot;</span>))</span><br></pre></td></tr></table></figure><hr><h3 id="6-高级用法"><a href="#6-高级用法" class="headerlink" title="6. 高级用法"></a><strong>6. 高级用法</strong></h3><ul><li><strong>自定义通知布局</strong>：使用 <code>RemoteViews</code> 创建个性化界面。</li><li><strong>前台服务通知</strong>：后台任务运行时显示不可清除的通知。</li><li><strong>分组通知</strong>：合并多个相关通知，减少干扰。</li></ul><hr><h3 id="7-重要注意事项"><a href="#7-重要注意事项" class="headerlink" title="7. 重要注意事项"></a><strong>7. 重要注意事项</strong></h3><ul><li><strong>Android 8.0+ 必须使用 NotificationChannel，否则通知不会显示。</strong></li><li><strong>使用 NotificationCompat 确保低版本 Android 兼容性。</strong></li><li><strong>合理管理通知，避免频繁弹出影响用户体验。</strong></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过 <strong>NotificationManager</strong> 发送通知，使用 <strong>PendingIntent</strong> 响应点击操作，并通过 <strong>setStyle</strong> 增强通知的可读性和交互性。在 Android 8.0 及以上版本，必须创建 <strong>NotificationChannel</strong>，确保通知正常显示。结合这些技巧，可以打造更优雅、实用的通知系统。 🚀</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ContentProvider+ContentResolver+UriMatcher+SQLite的用法示例</title>
      <link href="/2025/03/19/ContentProvider-ContentResolver-UriMatcher%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/19/ContentProvider-ContentResolver-UriMatcher%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>在 Android 中，数据共享是应用开发中非常重要的一部分。为了在不同应用之间共享数据，Android 提供了 <strong>ContentProvider</strong> 机制，通过该机制，应用能够访问其他应用的数据或向其他应用提供自己的数据。结合 <strong>SQLite</strong> 数据库、<strong>ContentProvider</strong>、<strong>ContentResolver</strong> 和 <strong>UriMatcher</strong>，我们可以方便地实现数据的持久化存储、查询、插入、更新和删除操作，同时还能够保证数据访问的安全性。</p><p>本文将介绍如何结合 <strong>SQLite</strong> 数据库、<strong>ContentProvider</strong>、<strong>ContentResolver</strong> 和 <strong>UriMatcher</strong> 实现一个完整的应用数据共享系统，并通过一个具体的示例进行详细说明。</p><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><h3 id="2-1-SQLite-数据库"><a href="#2-1-SQLite-数据库" class="headerlink" title="2.1 SQLite 数据库"></a>2.1 SQLite 数据库</h3><p>SQLite 是 Android 中推荐的本地数据库，它是一个轻量级的关系型数据库管理系统。SQLite 可以嵌入到应用中，支持 SQL 查询、数据持久化存储。</p><ul><li><strong>优点</strong>：开销小、无需服务器，适合单机应用。</li><li><strong>缺点</strong>：功能相对较简单，适用于小型应用和中小规模的数据存储。</li></ul><h3 id="2-2-ContentProvider"><a href="#2-2-ContentProvider" class="headerlink" title="2.2 ContentProvider"></a>2.2 ContentProvider</h3><p>ContentProvider 是一个提供数据存取接口的组件。它允许不同的应用共享数据，支持跨进程调用和跨应用访问。ContentProvider 通过 URI（统一资源标识符）来标识数据资源，并通过 SQL 查询操作来处理数据。</p><ul><li><strong>方法</strong>：<code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code>、<code>getType()</code> 等。</li><li><strong>作用</strong>：提供统一的接口，允许不同应用之间共享数据，避免直接暴露内部数据库结构。</li></ul><h3 id="2-3-ContentResolver"><a href="#2-3-ContentResolver" class="headerlink" title="2.3 ContentResolver"></a>2.3 ContentResolver</h3><p>ContentResolver 是一个访问 ContentProvider 的接口。通过 ContentResolver，我们可以向 ContentProvider 发起查询、插入、更新和删除操作。</p><ul><li><strong>方法</strong>：<code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code> 等。</li><li><strong>作用</strong>：通过 ContentResolver，应用可以操作 ContentProvider 中的数据，不需要知道数据存储的具体实现细节。</li><li><a href="https://goshenc.github.io/2025/03/17/ContentResolver%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/">ContentResolver的增删改查方法示例 | GoshenC</a></li></ul><h3 id="2-4-UriMatcher"><a href="#2-4-UriMatcher" class="headerlink" title="2.4 UriMatcher"></a>2.4 UriMatcher</h3><p>UriMatcher 是一个帮助 ContentProvider 匹配 URI 的工具，它根据 URI 的路径来判断进行操作的数据表或者数据项。通过 UriMatcher，我们可以根据传入的 URI 判断用户请求的是整个数据表的数据，还是某一条特定的数据记录。</p><ul><li><strong>作用</strong>：根据 URI 匹配不同的数据处理操作，帮助 ContentProvider 做出正确的响应。</li></ul><h3 id="2-5-概念及它们之间的关系"><a href="#2-5-概念及它们之间的关系" class="headerlink" title="2.5 概念及它们之间的关系"></a>2.5 概念及它们之间的关系</h3><ul><li><p><strong>ContentProvider</strong></p><ul><li><strong>作用</strong>：用于对外暴露应用的数据（例如 SQLite 数据库、文件等），支持跨进程或跨应用数据共享。</li><li><strong>关键方法</strong>：<code>onCreate()</code>（初始化）、<code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code>、<code>getType()</code>。</li></ul></li><li><p><strong>UriMatcher</strong></p><ul><li><strong>作用</strong>：帮助 ContentProvider 根据传入的 URI 判断需要操作的数据类型或数据集合。</li><li><strong>工作原理</strong>：预先注册一系列 URI 模式，每个模式对应一个整数代码；在请求时根据 URI 返回相应代码，以便在代码中进行判断和分支处理。</li></ul></li><li><p><strong>ContentResolver</strong></p><ul><li><p><strong>作用</strong>：作为数据访问者，由外部（或本应用内其他组件）调用，用于向 ContentProvider 发送数据操作请求（如查询、插入等）。</p></li><li><p>使用方式</p><p>：直接在 Activity、Service 等继承了 Context 的组件中调用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>这三者一起工作，实现了应用间（或应用内）的数据共享：</p><ol><li><strong>ContentResolver</strong> 发起请求，传入一个 URI。</li><li><strong>ContentProvider</strong> 通过内部的 <strong>UriMatcher</strong> 匹配 URI，判断请求的数据类型。</li><li>根据匹配结果，<strong>ContentProvider</strong> 调用相应的数据库操作，并返回数据（Cursor、Uri、影响行数等）。</li></ol><h2 id="3-使用-SQLite-ContentProvider-ContentResolver-UriMatcher-实现数据共享"><a href="#3-使用-SQLite-ContentProvider-ContentResolver-UriMatcher-实现数据共享" class="headerlink" title="3. 使用 SQLite + ContentProvider + ContentResolver + UriMatcher 实现数据共享"></a>3. 使用 SQLite + ContentProvider + ContentResolver + UriMatcher 实现数据共享</h2><h3 id="3-1-数据库实现"><a href="#3-1-数据库实现" class="headerlink" title="3.1 数据库实现"></a>3.1 数据库实现</h3><p>首先，我们需要创建一个 SQLite 数据库并定义数据表。下面是一个简单的 SQLiteOpenHelper 类，它管理一个名为 <code>diary</code> 的表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DiaryDatabaseHelper(context: Context) : SQLiteOpenHelper(context, &quot;DiaryDB&quot;, null, 1) &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase) &#123;</span><br><span class="line">        val createTableSQL = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE diary (</span><br><span class="line">                id INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                title TEXT,</span><br><span class="line">                date INTEGER,</span><br><span class="line">                content TEXT</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;.trimIndent()</span><br><span class="line">        db.execSQL(createTableSQL)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        db.execSQL(&quot;DROP TABLE IF EXISTS diary&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个数据库中，<code>diary</code> 表包含 <code>id</code>（主键）、<code>title</code>（标题）、<code>date</code>（日期）和 <code>content</code>（内容）等字段。</p><h3 id="3-2-ContentProvider-实现"><a href="#3-2-ContentProvider-实现" class="headerlink" title="3.2 ContentProvider 实现"></a>3.2 ContentProvider 实现</h3><p>接下来，我们要实现一个 ContentProvider，它将使用我们刚刚定义的数据库。通过 ContentProvider，外部应用可以通过 URI 来访问我们提供的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class DiaryProvider : ContentProvider() &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val AUTHORITY = &quot;com.example.providerdemo.diaryprovider&quot;</span><br><span class="line">        const val TABLE_DIARY = &quot;diary&quot;</span><br><span class="line">        val CONTENT_URI: Uri = Uri.parse(&quot;content://$AUTHORITY/$TABLE_DIARY&quot;)</span><br><span class="line">        const val DIARY_DIR = 1</span><br><span class="line">        const val DIARY_ITEM = 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private lateinit var dbHelper: DiaryDatabaseHelper</span><br><span class="line">    private val uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply &#123;</span><br><span class="line">        addURI(AUTHORITY, TABLE_DIARY, DIARY_DIR)</span><br><span class="line">        </span><br><span class="line">  /*DIARY_Dir是一个整数值，用来标识这个 URI 模式对应的操作。在后面的 ContentProvider 中，我们会使用这个整数值来确定执行哪些操作（例如查询、插入、更新、删除等）。DIARY_1Dir 是你在代码中定义的常量。比如后面的return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt;...&#125;*/</span><br><span class="line">            </span><br><span class="line">        addURI(AUTHORITY, &quot;$TABLE_DIARY/#&quot;, DIARY_ITEM)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(): Boolean &#123;</span><br><span class="line">        dbHelper = DiaryDatabaseHelper(context!!)</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun query(uri: Uri, projection: Array&lt;String&gt;?, selection: String?, selectionArgs: Array&lt;String&gt;?, sortOrder: String?): Cursor? &#123;</span><br><span class="line">        val db = dbHelper.readableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; db.query(TABLE_DIARY, projection, selection, selectionArgs, null, null, sortOrder)</span><br><span class="line">            DIARY_ITEM -&gt; &#123;</span><br><span class="line">                val id = uri.lastPathSegment</span><br><span class="line">                db.query(TABLE_DIARY, projection, &quot;id=?&quot;, arrayOf(id), null, null, sortOrder)</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun insert(uri: Uri, values: ContentValues?): Uri? &#123;</span><br><span class="line">        val db = dbHelper.writableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; &#123;</span><br><span class="line">                val id = db.insert(TABLE_DIARY, null, values)</span><br><span class="line">                Uri.withAppendedPath(CONTENT_URI, id.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun update(uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array&lt;String&gt;?): Int &#123;</span><br><span class="line">        val db = dbHelper.writableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; db.update(TABLE_DIARY, values, selection, selectionArgs)</span><br><span class="line">            DIARY_ITEM -&gt; &#123;</span><br><span class="line">                val id = uri.lastPathSegment</span><br><span class="line">                db.update(TABLE_DIARY, values, &quot;id=?&quot;, arrayOf(id))</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun delete(uri: Uri, selection: String?, selectionArgs: Array&lt;String&gt;?): Int &#123;</span><br><span class="line">        val db = dbHelper.writableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; db.delete(TABLE_DIARY, selection, selectionArgs)</span><br><span class="line">            DIARY_ITEM -&gt; &#123;</span><br><span class="line">                val id = uri.lastPathSegment</span><br><span class="line">                db.delete(TABLE_DIARY, &quot;id=?&quot;, arrayOf(id))</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getType(uri: Uri): String? &#123;</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; &quot;vnd.android.cursor.dir/vnd.$AUTHORITY.$TABLE_DIARY&quot;</span><br><span class="line">            DIARY_ITEM -&gt; &quot;vnd.android.cursor.item/vnd.$AUTHORITY.$TABLE_DIARY&quot;</span><br><span class="line">            else -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-UriMatcher-配置"><a href="#3-3-UriMatcher-配置" class="headerlink" title="3.3 UriMatcher 配置"></a>3.3 UriMatcher 配置</h3><p>在 ContentProvider 中，我们使用 UriMatcher 来判断传入的 URI 属于哪个类型。UriMatcher 会匹配表名（<code>diary</code>）或者某个具体的记录（通过 ID 来识别）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply &#123;</span><br><span class="line">    addURI(AUTHORITY, TABLE_DIARY, DIARY_DIR) // 匹配整个 diary 表</span><br><span class="line">    addURI(AUTHORITY, &quot;$TABLE_DIARY/#&quot;, DIARY_ITEM) // 匹配单条 diary 记录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>DIARY_DIR</strong>：匹配整个表的 URI。</li><li><strong>DIARY_ITEM</strong>：匹配单条数据记录的 URI，带有 <code>#</code> 通配符，表示记录的 ID。</li></ul><h3 id="3-4-ContentResolver-的使用"><a href="#3-4-ContentResolver-的使用" class="headerlink" title="3.4 ContentResolver 的使用"></a>3.4 ContentResolver 的使用</h3><p>ContentResolver 是外部应用用来访问 ContentProvider 的接口。在外部应用中，我们可以通过 ContentResolver 来执行查询、插入、更新和删除操作。例如，查询所有标题包含“心情”的日记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//构造 content:// 开头的 Uri，它用于标识数据库中的某条数据。</span><br><span class="line">val uri = Uri.parse(&quot;content://com.example.providerdemo.diaryprovider/diary&quot;)</span><br><span class="line">val projection = arrayOf(&quot;id&quot;, &quot;title&quot;, &quot;date&quot;, &quot;content&quot;)</span><br><span class="line">val selection = &quot;title LIKE ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;%心情%&quot;)</span><br><span class="line">val sortOrder = &quot;date DESC&quot;</span><br><span class="line"></span><br><span class="line">// 查询操作</span><br><span class="line">val cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)</span><br><span class="line">cursor?.use &#123;</span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val id = it.getInt(it.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val title = it.getString(it.getColumnIndexOrThrow(&quot;title&quot;))</span><br><span class="line">        val date = it.getLong(it.getColumnIndexOrThrow(&quot;date&quot;))</span><br><span class="line">        val content = it.getString(it.getColumnIndexOrThrow(&quot;content&quot;))</span><br><span class="line">        println(&quot;ID: $id, Title: $title, Date: $date, Content: $content&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过结合 <strong>SQLite</strong> 数据库、<strong>ContentProvider</strong>、<strong>ContentResolver</strong> 和 <strong>UriMatcher</strong>，我们可以实现一个完整的跨应用数据共享机制。ContentProvider 作为数据提供者，向外部应用提供访问接口，ContentResolver 则充当请求者的角色，发起查询、插入、更新和删除等操作，UriMatcher 则帮助我们根据 URI 匹配具体的数据操作。</p><p>这种架构不仅保证了数据共享的高效性和安全性，同时还使得应用内部数据管理变得更加清晰和规范。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecycleView使用示例</title>
      <link href="/2025/03/17/RecycleView%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/17/RecycleView%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="🚀-RecyclerView-进阶优化指南"><a href="#🚀-RecyclerView-进阶优化指南" class="headerlink" title="🚀 RecyclerView 进阶优化指南"></a><strong>🚀 RecyclerView 进阶优化指南</strong></h1><p>相比之前的版本，这次的改进包括：</p><ul><li>✅ <strong>使用 <code>DiffUtil</code> 优化数据更新</strong>（避免 <code>notifyDataSetChanged()</code>）</li><li>✅ <strong>使用 <code>ViewBinding</code> 简化 <code>ViewHolder</code> 代码</strong></li><li>✅ <strong>封装 <code>Adapter</code> 支持 <code>MutableList</code>（支持增删改查）</strong></li><li>✅ <strong>优化 <code>onClick</code> 事件，让 <code>RecyclerView</code> 更易扩展</strong></li><li>✅ <strong>支持 Grid&#x2F;瀑布流&#x2F;线性布局</strong></li></ul><hr><h2 id="1️⃣-添加-RecyclerView-依赖"><a href="#1️⃣-添加-RecyclerView-依赖" class="headerlink" title="1️⃣ 添加 RecyclerView 依赖"></a><strong>1️⃣ 添加 RecyclerView 依赖</strong></h2><p>确保你的 <code>build.gradle</code> 添加了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;androidx.recyclerview:recyclerview:1.3.2&#x27;</span><br><span class="line">    implementation &#x27;androidx.viewbinding:viewbinding:7.3.1&#x27; // 使用 ViewBinding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-在-activity-main-xml-中添加-RecyclerView"><a href="#2️⃣-在-activity-main-xml-中添加-RecyclerView" class="headerlink" title="2️⃣ 在 activity_main.xml 中添加 RecyclerView"></a><strong>2️⃣ 在 <code>activity_main.xml</code> 中添加 <code>RecyclerView</code></strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">    android:id=&quot;@+id/recyclerView&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;/&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="3️⃣-创建数据模型"><a href="#3️⃣-创建数据模型" class="headerlink" title="3️⃣ 创建数据模型"></a><strong>3️⃣ 创建数据模型</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data class Diary(</span><br><span class="line">    val id: Int,         // 方便更新和删除</span><br><span class="line">    val title: String,  </span><br><span class="line">    val content: String, </span><br><span class="line">    val date: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="4️⃣-使用-DiffUtil-优化-Adapter"><a href="#4️⃣-使用-DiffUtil-优化-Adapter" class="headerlink" title="4️⃣ 使用 DiffUtil 优化 Adapter"></a><strong>4️⃣ 使用 <code>DiffUtil</code> 优化 <code>Adapter</code></strong></h2><p>🚀 <code>DiffUtil</code> 可以高效更新 <code>RecyclerView</code>，避免全量刷新，提高性能。</p><h3 id="创建-DiaryDiffCallback"><a href="#创建-DiaryDiffCallback" class="headerlink" title="创建 DiaryDiffCallback"></a><strong>创建 <code>DiaryDiffCallback</code></strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class DiaryDiffCallback(</span><br><span class="line">    private val oldList: List&lt;Diary&gt;,</span><br><span class="line">    private val newList: List&lt;Diary&gt;</span><br><span class="line">) : DiffUtil.Callback() &#123;</span><br><span class="line">    </span><br><span class="line">    override fun getOldListSize(): Int = oldList.size</span><br><span class="line">    override fun getNewListSize(): Int = newList.size</span><br><span class="line"></span><br><span class="line">    // 判断是否是同一项（通常比较 ID）</span><br><span class="line">    override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean &#123;</span><br><span class="line">        return oldList[oldItemPosition].id == newList[newItemPosition].id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断内容是否相同（避免不必要的刷新）</span><br><span class="line">    override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean &#123;</span><br><span class="line">        return oldList[oldItemPosition] == newList[newItemPosition]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5️⃣-优化-Adapter（使用-ViewBinding）"><a href="#5️⃣-优化-Adapter（使用-ViewBinding）" class="headerlink" title="5️⃣ 优化 Adapter（使用 ViewBinding）"></a><strong>5️⃣ 优化 <code>Adapter</code>（使用 <code>ViewBinding</code>）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class DiaryAdapter(</span><br><span class="line">    private var diaryList: MutableList&lt;Diary&gt;, // 让数据可变</span><br><span class="line">    private val onItemClick: (Diary) -&gt; Unit</span><br><span class="line">) : RecyclerView.Adapter&lt;DiaryAdapter.DiaryViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    // 使用 ViewBinding 简化 ViewHolder</span><br><span class="line">    class DiaryViewHolder(val binding: ItemDiaryBinding) : RecyclerView.ViewHolder(binding.root)</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): DiaryViewHolder &#123;</span><br><span class="line">        val binding = ItemDiaryBinding.inflate(LayoutInflater.from(parent.context), parent, false)</span><br><span class="line">        return DiaryViewHolder(binding)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: DiaryViewHolder, position: Int) &#123;</span><br><span class="line">        val diary = diaryList[position]</span><br><span class="line">        with(holder.binding) &#123;</span><br><span class="line">            tvTitle.text = diary.title</span><br><span class="line">            tvContent.text = diary.content</span><br><span class="line">            tvDate.text = diary.date</span><br><span class="line">            root.setOnClickListener &#123; onItemClick(diary) &#125; // 处理点击事件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getItemCount(): Int = diaryList.size</span><br><span class="line"></span><br><span class="line">    // 🚀 使用 DiffUtil 刷新数据，避免全量刷新</span><br><span class="line">    fun updateData(newList: List&lt;Diary&gt;) &#123;</span><br><span class="line">        val diffResult = DiffUtil.calculateDiff(DiaryDiffCallback(diaryList, newList))</span><br><span class="line">        diaryList.clear()</span><br><span class="line">        diaryList.addAll(newList)</span><br><span class="line">        diffResult.dispatchUpdatesTo(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 增删改查方法</span><br><span class="line">    fun addDiary(diary: Diary) &#123;</span><br><span class="line">        diaryList.add(0, diary)  // 插入到第一个位置</span><br><span class="line">        notifyItemInserted(0)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun removeDiary(position: Int) &#123;</span><br><span class="line">        if (position in diaryList.indices) &#123;</span><br><span class="line">            diaryList.removeAt(position)</span><br><span class="line">            notifyItemRemoved(position)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6️⃣-创建-item-diary-xml"><a href="#6️⃣-创建-item-diary-xml" class="headerlink" title="6️⃣ 创建 item_diary.xml"></a><strong>6️⃣ 创建 <code>item_diary.xml</code></strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;</span><br><span class="line">    android:background=&quot;@android:color/white&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tvTitle&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;18sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/black&quot;</span><br><span class="line">        android:textStyle=&quot;bold&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tvContent&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;16sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/darker_gray&quot;</span><br><span class="line">        android:maxLines=&quot;2&quot;</span><br><span class="line">        android:ellipsize=&quot;end&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tvDate&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;14sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/holo_blue_dark&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="7️⃣-在-MainActivity-绑定-RecyclerView"><a href="#7️⃣-在-MainActivity-绑定-RecyclerView" class="headerlink" title="7️⃣ 在 MainActivity 绑定 RecyclerView"></a><strong>7️⃣ 在 <code>MainActivity</code> 绑定 <code>RecyclerView</code></strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    </span><br><span class="line">    private lateinit var recyclerView: RecyclerView</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        recyclerView = findViewById(R.id.recyclerView)</span><br><span class="line">        recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line"></span><br><span class="line">        // 初始数据</span><br><span class="line">        val diaryList = mutableListOf(</span><br><span class="line">            Diary(1, &quot;今日心情&quot;, &quot;今天天气很好，心情愉快！&quot;, &quot;2025-03-17&quot;),</span><br><span class="line">            Diary(2, &quot;学习 Kotlin&quot;, &quot;RecyclerView 真的很好用！&quot;, &quot;2025-03-16&quot;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // 绑定 Adapter</span><br><span class="line">        diaryAdapter = DiaryAdapter(diaryList) &#123; diary -&gt;</span><br><span class="line">            Toast.makeText(this, &quot;点击了: $&#123;diary.title&#125;&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        recyclerView.adapter = diaryAdapter</span><br><span class="line"></span><br><span class="line">        // 模拟 3 秒后刷新数据</span><br><span class="line">        Handler(Looper.getMainLooper()).postDelayed(&#123;</span><br><span class="line">            val newData = diaryList + Diary(3, &quot;记账&quot;, &quot;今天吃了火锅，花了 120 元&quot;, &quot;2025-03-15&quot;)</span><br><span class="line">            diaryAdapter.updateData(newData)</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8️⃣-可选优化"><a href="#8️⃣-可选优化" class="headerlink" title="8️⃣ 可选优化"></a><strong>8️⃣ 可选优化</strong></h2><h3 id="（1）网格布局"><a href="#（1）网格布局" class="headerlink" title="（1）网格布局"></a><strong>（1）网格布局</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.layoutManager = GridLayoutManager(this, 2) // 2 列</span><br></pre></td></tr></table></figure><h3 id="（2）瀑布流布局"><a href="#（2）瀑布流布局" class="headerlink" title="（2）瀑布流布局"></a><strong>（2）瀑布流布局</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-总结"><a href="#🎯-总结" class="headerlink" title="🎯 总结"></a><strong>🎯 总结</strong></h2><table><thead><tr><th>改进点</th><th>说明</th></tr></thead><tbody><tr><td>✅ <strong>使用 <code>DiffUtil</code></strong></td><td><strong>优化数据更新</strong>，避免 <code>notifyDataSetChanged()</code></td></tr><tr><td>✅ <strong>使用 <code>ViewBinding</code></strong></td><td><strong>减少 <code>findViewById</code> 代码</strong>，提高可读性</td></tr><tr><td>✅ <strong>封装增删改查方法</strong></td><td><code>addDiary()</code> 和 <code>removeDiary()</code></td></tr><tr><td>✅ <strong>支持 <code>MutableList</code></strong></td><td><strong>让数据可变</strong>，更方便操作</td></tr><tr><td>✅ <strong>支持 Grid&#x2F;瀑布流布局</strong></td><td><strong>适配不同 UI 需求</strong></td></tr></tbody></table><hr><p>🚀 <strong>这样写的 <code>RecyclerView</code> 更高效、更易扩展！你可以直接用在 Kotlin 日记本 App 里。</strong> 🎉</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ContentResolver的增删改查方法示例</title>
      <link href="/2025/03/17/ContentResolver%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/17/ContentResolver%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-中-ContentResolver-的增删改查详解"><a href="#Android-中-ContentResolver-的增删改查详解" class="headerlink" title="Android 中 ContentResolver 的增删改查详解"></a><strong>Android 中 <code>ContentResolver</code> 的增删改查详解</strong></h2><p><code>ContentResolver</code> 是 Android 提供的 API，用于在不同应用程序之间访问和操作数据，通常与 <code>ContentProvider</code> 一起使用。它提供 <strong>增（insert）、删（delete）、改（update）、查（query）</strong> 操作，常见于访问系统数据库（如通讯录、媒体库等）或应用自定义的数据库（如日记本、笔记等）。</p><hr><h2 id="📌-使用-ContentResolver-的步骤"><a href="#📌-使用-ContentResolver-的步骤" class="headerlink" title="📌 使用 ContentResolver 的步骤"></a><strong>📌 使用 <code>ContentResolver</code> 的步骤</strong></h2><ol><li><strong>确定 <code>ContentProvider</code> 提供的数据 URI</strong>（<code>content://</code> 格式）</li><li><strong>获取 <code>ContentResolver</code></strong> 对象</li><li><strong>执行增、删、改、查操作</strong></li><li><strong>处理权限（如果是访问系统数据）</strong></li><li><strong>关闭 <code>Cursor</code> 以释放资源（仅 <code>query</code> 需要）</strong></li></ol><hr><h2 id="💡-1-获取-ContentResolver"><a href="#💡-1-获取-ContentResolver" class="headerlink" title="💡 1. 获取 ContentResolver"></a><strong>💡 1. 获取 <code>ContentResolver</code></strong></h2><p>在 <code>Activity</code> 或 <code>Fragment</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val contentResolver = context.contentResolver</span><br></pre></td></tr></table></figure><p>在 <code>Service</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val contentResolver = applicationContext.contentResolver</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-2-查询数据（query）"><a href="#🔍-2-查询数据（query）" class="headerlink" title="🔍 2. 查询数据（query）"></a><strong>🔍 2. 查询数据（query）</strong></h2><p>查询 <code>ContentProvider</code> 提供的数据，返回 <code>Cursor</code>，需手动遍历和关闭。</p><h3 id="示例：查询日记"><a href="#示例：查询日记" class="headerlink" title="示例：查询日记"></a><strong>示例：查询日记</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 1. 目标 ContentProvider 的 URI</span><br><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line">//构造 content:// 开头的 Uri，它用于标识数据库中的某条数据。</span><br><span class="line"></span><br><span class="line">// 2. 查询的字段（列）</span><br><span class="line">val projection = arrayOf(&quot;id&quot;, &quot;title&quot;, &quot;date&quot;)</span><br><span class="line"></span><br><span class="line">// 3. 查询条件（WHERE）</span><br><span class="line">val selection = &quot;title LIKE ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;%心情%&quot;) // 查询包含“心情”的日记</span><br><span class="line">//这表示查询 title 列，要求 title 的内容包含“心情”两个字。</span><br><span class="line">//LIKE 是 SQL 语法，用于进行模糊查询。</span><br><span class="line">//? 是占位符，用来防止 SQL 注入，具体值由 selectionArgs 提供。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 4. 排序方式</span><br><span class="line">val sortOrder = &quot;date DESC&quot;</span><br><span class="line"></span><br><span class="line">// 5. 执行查询</span><br><span class="line">val cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)</span><br><span class="line"></span><br><span class="line">cursor?.use &#123; </span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val id = it.getInt(it.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val title = it.getString(it.getColumnIndexOrThrow(&quot;title&quot;))</span><br><span class="line">        val date = it.getLong(it.getColumnIndexOrThrow(&quot;date&quot;))</span><br><span class="line">        println(&quot;ID: $id, Title: $title, Date: $date&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // `use` 语法确保 Cursor 关闭</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li>查询时使用 <code>LIKE</code> 支持模糊匹配，<code>?</code> 代表参数占位符</li><li>使用 <code>Cursor</code> 需要调用 <code>.moveToNext()</code> 逐行读取</li><li>关闭 <code>Cursor</code> 以释放资源</li></ul><hr><h2 id="📝-3-插入数据（insert）"><a href="#📝-3-插入数据（insert）" class="headerlink" title="📝 3. 插入数据（insert）"></a><strong>📝 3. 插入数据（insert）</strong></h2><p>用于新增数据，返回新数据的 <code>Uri</code>。</p><h3 id="示例：新增日记"><a href="#示例：新增日记" class="headerlink" title="示例：新增日记"></a><strong>示例：新增日记</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line"></span><br><span class="line">// 1. 创建 ContentValues，存储字段和值</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(&quot;title&quot;, &quot;今日心情&quot;)</span><br><span class="line">    put(&quot;content&quot;, &quot;今天是个好天气&quot;)</span><br><span class="line">    put(&quot;date&quot;, System.currentTimeMillis())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 调用 insert 方法</span><br><span class="line">val newUri = contentResolver.insert(uri, values)</span><br><span class="line"></span><br><span class="line">// 3. 判断插入结果</span><br><span class="line">if (newUri != null) &#123;</span><br><span class="line">    println(&quot;插入成功，URI: $newUri&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;插入失败&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li><code>ContentValues</code> 类似 <code>Map</code>，用于存储字段和值</li><li><code>insert()</code> 返回新数据的 <code>Uri</code>，失败时返回 <code>null</code></li><li>newUri:表示新插入的数据的 <strong>URI</strong>，用于后续操作。如果插入失败，返回 <code>null</code>。</li></ul><hr><h2 id="✏-4-更新数据（update）"><a href="#✏-4-更新数据（update）" class="headerlink" title="✏ 4. 更新数据（update）"></a><strong>✏ 4. 更新数据（update）</strong></h2><p>用于修改已有数据，返回影响的行数。</p><h3 id="示例：更新日记内容"><a href="#示例：更新日记内容" class="headerlink" title="示例：更新日记内容"></a><strong>示例：更新日记内容</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line"></span><br><span class="line">// 1. 创建 ContentValues，存储更新的字段和值</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(&quot;content&quot;, &quot;更新后的日记内容&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 更新条件</span><br><span class="line">val selection = &quot;id = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;) // 只更新 ID 为 1 的日记</span><br><span class="line"></span><br><span class="line">// 3. 执行 update</span><br><span class="line">val rowsUpdated = contentResolver.update(uri, values, selection, selectionArgs)</span><br><span class="line"></span><br><span class="line">println(&quot;更新了 $rowsUpdated 条数据&quot;)</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li><code>selection</code> 是 SQL 语法的 <code>WHERE</code> 子句</li><li><code>update()</code> 返回更新的行数，可能为 <code>0</code>（表示数据未找到）</li></ul><hr><h2 id="🗑-5-删除数据（delete）"><a href="#🗑-5-删除数据（delete）" class="headerlink" title="🗑 5. 删除数据（delete）"></a><strong>🗑 5. 删除数据（delete）</strong></h2><p>用于删除数据，返回删除的行数。</p><h3 id="示例：删除指定日记"><a href="#示例：删除指定日记" class="headerlink" title="示例：删除指定日记"></a><strong>示例：删除指定日记</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line"></span><br><span class="line">// 1. 删除条件</span><br><span class="line">val selection = &quot;id = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;) // 只删除 ID 为 1 的日记</span><br><span class="line"></span><br><span class="line">// 2. 执行删除</span><br><span class="line">val rowsDeleted = contentResolver.delete(uri, selection, selectionArgs)</span><br><span class="line"></span><br><span class="line">println(&quot;删除了 $rowsDeleted 条数据&quot;)</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li><code>delete()</code> 返回删除的行数</li><li>不提供 <code>selection</code> 则删除所有数据（谨慎）</li></ul><hr><h2 id="📖-6-访问系统-ContentProvider-示例"><a href="#📖-6-访问系统-ContentProvider-示例" class="headerlink" title="📖 6. 访问系统 ContentProvider 示例"></a><strong>📖 6. 访问系统 <code>ContentProvider</code> 示例</strong></h2><h3 id="📌-读取联系人"><a href="#📌-读取联系人" class="headerlink" title="📌 读取联系人"></a><strong>📌 读取联系人</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI</span><br><span class="line">val cursor = contentResolver.query(uri, null, null, null, null)</span><br><span class="line"></span><br><span class="line">cursor?.use &#123;</span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val name = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME))</span><br><span class="line">        val phone = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.NUMBER))</span><br><span class="line">        println(&quot;联系人: $name, 电话: $phone&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="📌-读取相册"><a href="#📌-读取相册" class="headerlink" title="📌 读取相册"></a><strong>📌 读取相册</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI</span><br><span class="line">val projection = arrayOf(MediaStore.Images.Media.DATA)</span><br><span class="line">val cursor = contentResolver.query(uri, projection, null, null, null)</span><br><span class="line"></span><br><span class="line">cursor?.use &#123;</span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val imagePath = it.getString(it.getColumnIndexOrThrow(MediaStore.Images.Media.DATA))</span><br><span class="line">        println(&quot;图片路径: $imagePath&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔒-7-处理权限"><a href="#🔒-7-处理权限" class="headerlink" title="🔒 7. 处理权限"></a><strong>🔒 7. 处理权限</strong></h2><p><strong>如果访问系统 <code>ContentProvider</code>（如通讯录、相册等），需申请权限</strong>：</p><h3 id="在-AndroidManifest-xml-申请权限"><a href="#在-AndroidManifest-xml-申请权限" class="headerlink" title="在 AndroidManifest.xml 申请权限"></a><strong>在 <code>AndroidManifest.xml</code> 申请权限</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="动态请求权限（Android-6-0-）"><a href="#动态请求权限（Android-6-0-）" class="headerlink" title="动态请求权限（Android 6.0+）"></a><strong>动态请求权限（Android 6.0+）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.READ_CONTACTS), 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a><strong>📌 总结</strong></h2><table><thead><tr><th>操作</th><th>方法名</th><th>主要参数</th></tr></thead><tbody><tr><td><strong>查询</strong></td><td><code>query(uri, projection, selection, selectionArgs, sortOrder)</code></td><td><code>Uri</code>，字段数组，查询条件，排序</td></tr><tr><td><strong>插入</strong></td><td><code>insert(uri, values)</code></td><td><code>Uri</code>，<code>ContentValues</code></td></tr><tr><td><strong>更新</strong></td><td><code>update(uri, values, selection, selectionArgs)</code></td><td><code>Uri</code>，<code>ContentValues</code>，条件</td></tr><tr><td><strong>删除</strong></td><td><code>delete(uri, selection, selectionArgs)</code></td><td><code>Uri</code>，条件</td></tr></tbody></table><p><strong>💡 你是要操作自己的 <code>ContentProvider</code> 还是访问系统数据？如果是日记本的 <code>ContentProvider</code>，可以一起设计 URI 和数据库结构。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite用法</title>
      <link href="/2025/03/15/SQLite%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/SQLite%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>SQLite 是一种轻量级的嵌入式数据库，在 Android 中用于存储结构化数据。你可以通过 <code>SQLiteOpenHelper</code> 来管理数据库的创建、升级、和版本管理。以下是使用 SQLite 的基本步骤：</p><h2 id="1-创建数据库和表"><a href="#1-创建数据库和表" class="headerlink" title="1. 创建数据库和表"></a><strong>1. 创建数据库和表</strong></h2><p>使用 <code>SQLiteOpenHelper</code> 创建数据库以及表结构。这个类会帮助你创建数据库、执行表的升级、降级等操作。</p><h3 id="创建-SQLiteOpenHelper-类"><a href="#创建-SQLiteOpenHelper-类" class="headerlink" title="创建 SQLiteOpenHelper 类"></a><strong>创建 SQLiteOpenHelper 类</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import android.database.sqlite.SQLiteDatabase</span><br><span class="line">import android.database.sqlite.SQLiteOpenHelper</span><br><span class="line"></span><br><span class="line">class MyDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private const val DATABASE_NAME = &quot;my_database.db&quot; // 数据库名称</span><br><span class="line">        private const val DATABASE_VERSION = 1 // 数据库版本号</span><br><span class="line">        private const val TABLE_NAME = &quot;users&quot; // 表名称</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase) &#123;</span><br><span class="line">        // 创建数据库表</span><br><span class="line">        val createTableQuery = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE $TABLE_NAME (</span><br><span class="line">                id INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                name TEXT NOT NULL,</span><br><span class="line">                age INTEGER</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;.trimIndent()</span><br><span class="line">        db.execSQL(createTableQuery)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        // 如果数据库版本变化时，删除旧表并创建新表</span><br><span class="line">        db.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NAME&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>onCreate</code></strong>：当数据库首次创建时执行。通常在这里创建表和初始化数据。</li><li><strong><code>onUpgrade</code></strong>：当数据库版本发生变化时执行。你可以在这里进行表的迁移或删除。</li></ul><h2 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2. 插入数据"></a><strong>2. 插入数据</strong></h2><p>插入数据需要通过 <code>SQLiteDatabase.insert()</code> 方法来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import android.content.ContentValues</span><br><span class="line"></span><br><span class="line">fun insertUser(context: Context, name: String, age: Int) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val values = ContentValues().apply &#123;</span><br><span class="line">        put(&quot;name&quot;, name)</span><br><span class="line">        put(&quot;age&quot;, age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    db.insert(&quot;users&quot;, null, values)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>ContentValues</code></strong>：是用于存储要插入的数据的容器。通过 <code>put</code> 方法将列名和值添加到 <code>ContentValues</code> 中。</li><li><strong><code>insert</code></strong>：插入数据的方法，第一个参数是表名，第二个参数是列为空时插入的默认值，第三个参数是 <code>ContentValues</code>。</li></ul><h2 id="3-查询数据"><a href="#3-查询数据" class="headerlink" title="3. 查询数据"></a><strong>3. 查询数据</strong></h2><p>查询数据使用 <code>SQLiteDatabase.query()</code> 或 <code>SQLiteDatabase.rawQuery()</code> 方法。</p><h3 id="使用-query-方法"><a href="#使用-query-方法" class="headerlink" title="使用 query() 方法"></a>使用 <code>query()</code> 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import android.database.Cursor</span><br><span class="line"></span><br><span class="line">fun queryUsers(context: Context): List&lt;User&gt; &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.readableDatabase</span><br><span class="line"></span><br><span class="line">    val cursor: Cursor = db.query(</span><br><span class="line">        &quot;users&quot;, // 表名</span><br><span class="line">        arrayOf(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;), // 列名</span><br><span class="line">        null, // WHERE 子句</span><br><span class="line">        null, // WHERE 子句的参数</span><br><span class="line">        null, // GROUP BY 子句</span><br><span class="line">        null, // HAVING 子句</span><br><span class="line">        null // ORDER BY 子句</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val users = mutableListOf&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    while (cursor.moveToNext()) &#123;</span><br><span class="line">        val id = cursor.getLong(cursor.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val name = cursor.getString(cursor.getColumnIndexOrThrow(&quot;name&quot;))</span><br><span class="line">        val age = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;age&quot;))</span><br><span class="line"></span><br><span class="line">        users.add(User(id, name, age))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    return users</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data class User(val id: Long, val name: String, val age: Int)</span><br></pre></td></tr></table></figure><ul><li><strong><code>query</code></strong>：用于查询数据库，返回一个 <code>Cursor</code> 对象。你可以通过 <code>Cursor</code> 遍历结果集。</li><li><strong><code>getColumnIndexOrThrow()</code></strong>：根据列名获取列的索引，<code>getString()</code>, <code>getInt()</code> 等方法用于提取数据。</li></ul><h3 id="使用-rawQuery-方法"><a href="#使用-rawQuery-方法" class="headerlink" title="使用 rawQuery() 方法"></a>使用 <code>rawQuery()</code> 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun queryUsersRaw(context: Context): List&lt;User&gt; &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.readableDatabase</span><br><span class="line"></span><br><span class="line">    val cursor: Cursor = db.rawQuery(&quot;SELECT * FROM users&quot;, null)</span><br><span class="line"></span><br><span class="line">    val users = mutableListOf&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    while (cursor.moveToNext()) &#123;</span><br><span class="line">        val id = cursor.getLong(cursor.getColumnIndex(&quot;id&quot;))</span><br><span class="line">        val name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;))</span><br><span class="line">        val age = cursor.getInt(cursor.getColumnIndex(&quot;age&quot;))</span><br><span class="line"></span><br><span class="line">        users.add(User(id, name, age))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    return users</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>rawQuery()</code></strong>：执行原始的 SQL 查询语句，返回一个 <code>Cursor</code>。</li></ul><h2 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4. 更新数据"></a><strong>4. 更新数据</strong></h2><p>更新数据使用 <code>SQLiteDatabase.update()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import android.content.ContentValues</span><br><span class="line"></span><br><span class="line">fun updateUser(context: Context, id: Long, name: String, age: Int) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val values = ContentValues().apply &#123;</span><br><span class="line">        put(&quot;name&quot;, name)</span><br><span class="line">        put(&quot;age&quot;, age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val selection = &quot;id = ?&quot;</span><br><span class="line">    val selectionArgs = arrayOf(id.toString())</span><br><span class="line"></span><br><span class="line">    db.update(&quot;users&quot;, values, selection, selectionArgs)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>update()</code></strong>：更新数据的方法。第一个参数是表名，第二个参数是更新的值，第三个参数是 <code>WHERE</code> 子句，第四个参数是 <code>WHERE</code> 子句的参数。</li></ul><h2 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5. 删除数据"></a><strong>5. 删除数据</strong></h2><p>删除数据使用 <code>SQLiteDatabase.delete()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun deleteUser(context: Context, id: Long) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val selection = &quot;id = ?&quot;</span><br><span class="line">    val selectionArgs = arrayOf(id.toString())</span><br><span class="line"></span><br><span class="line">    db.delete(&quot;users&quot;, selection, selectionArgs)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>delete()</code></strong>：删除数据的方法，类似于 <code>update()</code> 方法，传入 <code>WHERE</code> 子句来指定删除条件。</li></ul><h2 id="6-关闭数据库连接"><a href="#6-关闭数据库连接" class="headerlink" title="6. 关闭数据库连接"></a><strong>6. 关闭数据库连接</strong></h2><p>每次操作完数据库后，记得关闭数据库连接，防止内存泄漏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.close()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><strong>创建数据库和表</strong>：通过继承 <code>SQLiteOpenHelper</code> 类来创建数据库及表。</li><li><strong>插入数据</strong>：使用 <code>ContentValues</code> 结合 <code>insert()</code> 方法插入数据。</li><li><strong>查询数据</strong>：通过 <code>query()</code> 或 <code>rawQuery()</code> 查询数据，返回 <code>Cursor</code> 对象进行遍历。</li><li><strong>更新数据</strong>：使用 <code>update()</code> 方法更新数据。</li><li><strong>删除数据</strong>：使用 <code>delete()</code> 方法删除数据。</li><li><strong>关闭数据库连接</strong>：操作完成后记得关闭数据库。</li></ol><p>SQLite 提供了强大的本地数据存储能力，适合用于需要存储结构化数据的应用。</p><p><strong>完整示例</strong></p><p>假设我们有一个应用需要保存用户信息，每个用户包含 <code>id</code>、<code>name</code> 和 <code>email</code>。我们可以在数据库中创建一个表并对数据进行增删改查操作。</p><h4 id="1-数据库助手类"><a href="#1-数据库助手类" class="headerlink" title="1. 数据库助手类"></a>1. 数据库助手类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MyDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val DATABASE_NAME = &quot;my_database.db&quot;</span><br><span class="line">        const val DATABASE_VERSION = 1</span><br><span class="line">        const val TABLE_NAME = &quot;users&quot;</span><br><span class="line">        const val COLUMN_ID = &quot;id&quot;</span><br><span class="line">        const val COLUMN_NAME = &quot;name&quot;</span><br><span class="line">        const val COLUMN_EMAIL = &quot;email&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase?) &#123;</span><br><span class="line">        val createTableQuery = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE $TABLE_NAME (</span><br><span class="line">                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                $COLUMN_NAME TEXT,</span><br><span class="line">                $COLUMN_EMAIL TEXT</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        db?.execSQL(createTableQuery)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NAME&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-插入数据-1"><a href="#2-插入数据-1" class="headerlink" title="2. 插入数据"></a>2. 插入数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_NAME, &quot;John Doe&quot;)</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_EMAIL, &quot;john.doe@example.com&quot;)</span><br><span class="line">&#125;</span><br><span class="line">db.insert(MyDatabaseHelper.TABLE_NAME, null, values)</span><br></pre></td></tr></table></figure><h4 id="3-查询数据-1"><a href="#3-查询数据-1" class="headerlink" title="3. 查询数据"></a>3. 查询数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val db = dbHelper.readableDatabase</span><br><span class="line">val cursor = db.query(</span><br><span class="line">    MyDatabaseHelper.TABLE_NAME,</span><br><span class="line">    arrayOf(MyDatabaseHelper.COLUMN_ID, MyDatabaseHelper.COLUMN_NAME, MyDatabaseHelper.COLUMN_EMAIL),</span><br><span class="line">    null, null, null, null, null</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">while (cursor.moveToNext()) &#123;</span><br><span class="line">    val id = cursor.getLong(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_ID))</span><br><span class="line">    val name = cursor.getString(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_NAME))</span><br><span class="line">    val email = cursor.getString(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_EMAIL))</span><br><span class="line">    println(&quot;User: $id, $name, $email&quot;)</span><br><span class="line">&#125;</span><br><span class="line">cursor.close()</span><br></pre></td></tr></table></figure><h4 id="4-更新数据-1"><a href="#4-更新数据-1" class="headerlink" title="4. 更新数据"></a>4. 更新数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_NAME, &quot;John Smith&quot;)</span><br><span class="line">&#125;</span><br><span class="line">val selection = &quot;$&#123;MyDatabaseHelper.COLUMN_ID&#125; = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">db.update(MyDatabaseHelper.TABLE_NAME, values, selection, selectionArgs)</span><br></pre></td></tr></table></figure><h4 id="5-删除数据-1"><a href="#5-删除数据-1" class="headerlink" title="5. 删除数据"></a>5. 删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val selection = &quot;$&#123;MyDatabaseHelper.COLUMN_ID&#125; = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">db.delete(MyDatabaseHelper.TABLE_NAME, selection, selectionArgs)</span><br></pre></td></tr></table></figure><h4 id="6-关闭数据库"><a href="#6-关闭数据库" class="headerlink" title="6. 关闭数据库"></a>6. 关闭数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.close()</span><br></pre></td></tr></table></figure><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>SQLiteOpenHelper</strong>：管理数据库的创建、升级等操作。</li><li><strong>SQLiteDatabase</strong>：用于执行数据库操作，如插入、查询、更新、删除。</li><li><strong>ContentValues</strong>：用于存储要插入或更新的数据。</li><li><strong>Cursor</strong>：用于访问查询结果。</li></ul><p>SQLite 是一种非常有效的方式来在 Android 上进行本地数据存储，尤其适用于存储小型结构化数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Room+ViewModel+LiveData一起使用的用法</title>
      <link href="/2025/03/15/Room-ViewModel-LiveData%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/Room-ViewModel-LiveData%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 <code>Android</code> 开发中，<code>Room</code>、<code>ViewModel</code> 和 <code>LiveData</code> 经常一起使用，以实现 <strong>MVVM 架构</strong>，并提供持久化数据存储、生命周期感知的数据管理和自动更新 UI 的能力。</p><hr><h1 id="📌-1-主要作用"><a href="#📌-1-主要作用" class="headerlink" title="📌 1. 主要作用"></a><strong>📌 1. 主要作用</strong></h1><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>Room（数据库）</strong></td><td>提供 SQLite 的抽象层，管理本地数据存储</td></tr><tr><td><strong>ViewModel</strong></td><td>管理 UI 相关的数据，确保数据在配置变更（如旋转屏幕）时不会丢失</td></tr><tr><td><strong>LiveData</strong></td><td>观察数据变化，并在 UI 组件生命周期内自动更新</td></tr></tbody></table><hr><h1 id="🚀-2-使用-Room-ViewModel-LiveData-的完整示例"><a href="#🚀-2-使用-Room-ViewModel-LiveData-的完整示例" class="headerlink" title="🚀 2. 使用 Room + ViewModel + LiveData 的完整示例"></a><strong>🚀 2. 使用 <code>Room + ViewModel + LiveData</code> 的完整示例</strong></h1><h3 id="📌-功能："><a href="#📌-功能：" class="headerlink" title="📌 功能："></a><strong>📌 功能</strong>：</h3><p>我们实现一个<strong>简单的待办事项（ToDo List）应用</strong>，可以：</p><ul><li><strong>增删查改任务</strong>，数据存储在 <code>Room</code> 数据库中。</li><li><strong>使用 <code>LiveData</code></strong> 让 UI <strong>自动更新</strong>，而不需要手动刷新。</li><li><strong><code>ViewModel</code> 负责管理数据</strong>，避免 <code>Activity</code> 直接操作数据库。</li></ul><hr><h2 id="📌-3-创建-Room-数据库"><a href="#📌-3-创建-Room-数据库" class="headerlink" title="📌 3. 创建 Room 数据库"></a><strong>📌 3. 创建 Room 数据库</strong></h2><h3 id="（1）定义-Entity（数据库表）"><a href="#（1）定义-Entity（数据库表）" class="headerlink" title="（1）定义 Entity（数据库表）"></a><strong>（1）定义 <code>Entity</code>（数据库表）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.Entity</span><br><span class="line">import androidx.room.PrimaryKey</span><br><span class="line"></span><br><span class="line">@Entity(tableName = &quot;todo_table&quot;)</span><br><span class="line">data class Todo(</span><br><span class="line">    @PrimaryKey(autoGenerate = true) val id: Int = 0,</span><br><span class="line">    val task: String,</span><br><span class="line">    val isCompleted: Boolean</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>@Entity</code>：表示这是一个数据库表，表名是 <code>todo_table</code>。</li><li><code>@PrimaryKey(autoGenerate = true)</code>：<code>id</code> 是主键，<code>Room</code> 会自动生成。</li></ul><hr><h3 id="（2）创建-DAO（数据访问对象）"><a href="#（2）创建-DAO（数据访问对象）" class="headerlink" title="（2）创建 DAO（数据访问对象）"></a><strong>（2）创建 DAO（数据访问对象）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line">import androidx.room.*</span><br><span class="line"></span><br><span class="line">@Dao</span><br><span class="line">interface TodoDao &#123;</span><br><span class="line">    @Insert(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    suspend fun insert(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    suspend fun update(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    suspend fun delete(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM todo_table ORDER BY id DESC&quot;)</span><br><span class="line">    fun getAllTodos(): LiveData&lt;List&lt;Todo&gt;&gt; // 使用 LiveData 让 UI 自动更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Dao</code>：数据访问对象，定义数据库操作。</li><li><code>@Insert</code> &#x2F; <code>@Update</code> &#x2F; <code>@Delete</code>：操作数据库的基本增、删、改。</li><li><code>getAllTodos()</code> 返回 <code>LiveData&lt;List&lt;Todo&gt;&gt;</code>，<strong>Room 会自动监听数据变化，并更新 UI</strong>。</li></ul><hr><h3 id="（3）创建-Room-数据库"><a href="#（3）创建-Room-数据库" class="headerlink" title="（3）创建 Room 数据库"></a><strong>（3）创建 Room 数据库</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import androidx.room.Database</span><br><span class="line">import androidx.room.Room</span><br><span class="line">import androidx.room.RoomDatabase</span><br><span class="line"></span><br><span class="line">@Database(entities = [Todo::class], version = 1, exportSchema = false)</span><br><span class="line">abstract class TodoDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun todoDao(): TodoDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile</span><br><span class="line">        private var INSTANCE: TodoDatabase? = null</span><br><span class="line"></span><br><span class="line">        fun getDatabase(context: Context): TodoDatabase &#123;</span><br><span class="line">            return INSTANCE ?: synchronized(this) &#123;</span><br><span class="line">                val instance = Room.databaseBuilder(</span><br><span class="line">                    context.applicationContext,</span><br><span class="line">                    TodoDatabase::class.java,</span><br><span class="line">                    &quot;todo_database&quot;</span><br><span class="line">                ).build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Database(entities = [Todo::class], version = 1)</code>：定义数据库，包含 <code>Todo</code> 表。</li><li><code>synchronized(this)</code>：保证数据库实例的线程安全。</li><li><code>Room.databaseBuilder()</code>：构建 <code>Room</code> 数据库实例。</li></ul><hr><h2 id="📌-4-创建-Repository"><a href="#📌-4-创建-Repository" class="headerlink" title="📌 4. 创建 Repository"></a><strong>📌 4. 创建 Repository</strong></h2><p><code>Repository</code> 负责处理 <code>DAO</code> 操作，避免 <code>ViewModel</code> 直接操作数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line"></span><br><span class="line">class TodoRepository(private val todoDao: TodoDao) &#123;</span><br><span class="line">    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt; = todoDao.getAllTodos()</span><br><span class="line"></span><br><span class="line">    suspend fun insert(todo: Todo) &#123;</span><br><span class="line">        todoDao.insert(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun update(todo: Todo) &#123;</span><br><span class="line">        todoDao.update(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun delete(todo: Todo) &#123;</span><br><span class="line">        todoDao.delete(todo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Repository</code> 封装 <code>DAO</code>，<strong>ViewModel 只需要调用 <code>Repository</code>，而不直接操作 <code>Room</code></strong>。</li></ul><hr><h2 id="📌-5-创建-ViewModel"><a href="#📌-5-创建-ViewModel" class="headerlink" title="📌 5. 创建 ViewModel"></a><strong>📌 5. 创建 ViewModel</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.*</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">class TodoViewModel(private val repository: TodoRepository) : ViewModel() &#123;</span><br><span class="line">    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt; = repository.allTodos</span><br><span class="line"></span><br><span class="line">    fun insert(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.insert(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun update(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.update(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun delete(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.delete(todo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>viewModelScope.launch &#123;&#125;</code> 让数据库操作在 <strong>后台线程执行</strong>（<code>suspend</code> 需要 <code>Coroutine</code>）。</li><li><code>LiveData&lt;List&lt;Todo&gt;&gt;</code> 确保 UI 自动更新。</li></ul><hr><h2 id="📌-6-创建-ViewModelFactory"><a href="#📌-6-创建-ViewModelFactory" class="headerlink" title="📌 6. 创建 ViewModelFactory"></a><strong>📌 6. 创建 ViewModelFactory</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import androidx.lifecycle.ViewModelProvider</span><br><span class="line"></span><br><span class="line">class TodoViewModelFactory(private val repository: TodoRepository) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(TodoViewModel::class.java)) &#123;</span><br><span class="line">            @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">            return TodoViewModel(repository) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ViewModelFactory</code> 用于 <strong>传递 <code>Repository</code></strong>，让 <code>ViewModel</code> 使用 <code>Room</code>。</li></ul><hr><h2 id="📌-7-在-Activity-里使用"><a href="#📌-7-在-Activity-里使用" class="headerlink" title="📌 7. 在 Activity 里使用"></a><strong>📌 7. 在 <code>Activity</code> 里使用</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var todoViewModel: TodoViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        // 获取数据库实例和 DAO</span><br><span class="line">        val database = TodoDatabase.getDatabase(this)</span><br><span class="line">        val repository = TodoRepository(database.todoDao())</span><br><span class="line"></span><br><span class="line">        // 创建 ViewModel</span><br><span class="line">        val factory = TodoViewModelFactory(repository)</span><br><span class="line">        todoViewModel = ViewModelProvider(this, factory).get(TodoViewModel::class.java)</span><br><span class="line"></span><br><span class="line">        // 监听 LiveData，更新 UI</span><br><span class="line">        todoViewModel.allTodos.observe(this) &#123; todos -&gt;</span><br><span class="line">            // 更新 RecyclerView 或 UI</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 添加任务</span><br><span class="line">        buttonAdd.setOnClickListener &#123;</span><br><span class="line">            val newTodo = Todo(task = &quot;New Task&quot;, isCompleted = false)</span><br><span class="line">            todoViewModel.insert(newTodo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getDatabase(this)</code> 获取数据库实例。</li><li><code>ViewModelProvider(this, factory)</code> 创建 <code>ViewModel</code>。</li><li><code>LiveData.observe()</code> 监听数据变化，<strong>UI 自动更新</strong>。</li></ul><hr><h1 id="📌-8-总结"><a href="#📌-8-总结" class="headerlink" title="📌 8. 总结"></a><strong>📌 8. 总结</strong></h1><p>✅ <strong>Room 负责存储数据</strong>，<code>DAO</code> 负责数据库操作。<br> ✅ <strong>ViewModel 负责持久化数据</strong>，避免因屏幕旋转导致数据丢失。<br> ✅ <strong>LiveData 让 UI 自动更新</strong>，不需要手动刷新数据。<br> ✅ <strong>Repository 作为数据中介</strong>，避免 <code>ViewModel</code> 直接操作 <code>Room</code>。</p><p>📌 <strong>最终效果</strong>：</p><ol><li><strong>数据库变更时，UI 自动更新</strong>（<code>LiveData</code>）。</li><li><strong>ViewModel 让数据在 Activity&#x2F;Fragment 生命周期内持久化</strong>。</li><li><strong>Repository 让数据管理更清晰</strong>，避免 <code>ViewModel</code> 直接访问数据库。</li></ol><p>💡 <strong>这样，我们的 <code>MVVM + Room</code> 架构更加清晰，可维护性更强！</strong> 🚀</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewModel用法</title>
      <link href="/2025/03/15/ViewModel%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/ViewModel%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>ViewModel</code> 是 Android 架构组件之一，<strong>用于管理 UI 相关的数据</strong>，并在 <strong>配置更改（如屏幕旋转）时保持数据不丢失</strong>。</p><hr><h2 id="🔹-1-添加-ViewModel-依赖"><a href="#🔹-1-添加-ViewModel-依赖" class="headerlink" title="🔹 1. 添加 ViewModel 依赖"></a><strong>🔹 1. 添加 ViewModel 依赖</strong></h2><p>在 <code>build.gradle.kts</code>（模块级）中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-2-创建-ViewModel"><a href="#🔹-2-创建-ViewModel" class="headerlink" title="🔹 2. 创建 ViewModel"></a><strong>🔹 2. 创建 ViewModel</strong></h2><h3 id="（1）基础-ViewModel"><a href="#（1）基础-ViewModel" class="headerlink" title="（1）基础 ViewModel"></a><strong>（1）基础 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line">class CounterViewModel : ViewModel() &#123;</span><br><span class="line">    var count = 0 // ViewModel 变量（Activity 重建后不会丢失）</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-3-在-Activity-Fragment-中使用"><a href="#🔹-3-在-Activity-Fragment-中使用" class="headerlink" title="🔹 3. 在 Activity&#x2F;Fragment 中使用"></a><strong>🔹 3. 在 Activity&#x2F;Fragment 中使用</strong></h2><h3 id="（1）Activity-获取-ViewModel"><a href="#（1）Activity-获取-ViewModel" class="headerlink" title="（1）Activity 获取 ViewModel"></a><strong>（1）Activity 获取 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import android.widget.TextView</span><br><span class="line">import androidx.activity.viewModels</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels() // 通过 viewModels() 获取 ViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        // 显示当前计数</span><br><span class="line">        textView.text = counterViewModel.count.toString()</span><br><span class="line"></span><br><span class="line">        // 点击按钮增加计数</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">            textView.text = counterViewModel.count.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>即使旋转屏幕，<code>count</code> 也不会重置</strong>。</p><hr><h2 id="🔹-4-ViewModel-LiveData-监听数据变化"><a href="#🔹-4-ViewModel-LiveData-监听数据变化" class="headerlink" title="🔹 4. ViewModel + LiveData 监听数据变化"></a><strong>🔹 4. ViewModel + LiveData 监听数据变化</strong></h2><p>使用 <code>LiveData</code>，<strong>UI 会自动更新</strong>：</p><h3 id="（1）ViewModel（使用-LiveData）"><a href="#（1）ViewModel（使用-LiveData）" class="headerlink" title="（1）ViewModel（使用 LiveData）"></a><strong>（1）ViewModel（使用 <code>LiveData</code>）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line">import androidx.lifecycle.MutableLiveData</span><br><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line">class CounterViewModel : ViewModel() &#123;</span><br><span class="line">    private val _count = MutableLiveData(0) // 可变 LiveData</span><br><span class="line">    val count: LiveData&lt;Int&gt; = _count // 只暴露不可变 LiveData</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        _count.value = (_count.value ?: 0) + 1 // 更新数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）Activity-观察-LiveData"><a href="#（2）Activity-观察-LiveData" class="headerlink" title="（2）Activity 观察 LiveData"></a><strong>（2）Activity 观察 LiveData</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels()</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        // 观察 LiveData，自动更新 UI</span><br><span class="line">        counterViewModel.count.observe(this) &#123; newCount -&gt;</span><br><span class="line">            textView.text = newCount.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong><code>LiveData</code> 确保数据变化时，UI 会自动更新</strong>。</p><hr><h2 id="🔹-5-处理-ViewModel-依赖（带参数的-ViewModel）"><a href="#🔹-5-处理-ViewModel-依赖（带参数的-ViewModel）" class="headerlink" title="🔹 5. 处理 ViewModel 依赖（带参数的 ViewModel）"></a><strong>🔹 5. 处理 ViewModel 依赖（带参数的 ViewModel）</strong></h2><h3 id="（1）ViewModel-需要参数"><a href="#（1）ViewModel-需要参数" class="headerlink" title="（1）ViewModel 需要参数"></a><strong>（1）ViewModel 需要参数</strong></h3><p>如果 <code>ViewModel</code> 需要参数（如 <code>Repository</code>），需要创建 <code>ViewModelProvider.Factory</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class CounterViewModel(private val startValue: Int) : ViewModel() &#123;</span><br><span class="line">    private val _count = MutableLiveData(startValue)</span><br><span class="line">    val count: LiveData&lt;Int&gt; = _count</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        _count.value = (_count.value ?: 0) + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义 ViewModelFactory</span><br><span class="line">class CounterViewModelFactory(private val startValue: Int) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(CounterViewModel::class.java)) &#123;</span><br><span class="line">            @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">            return CounterViewModel(startValue) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）Activity-获取带参数的-ViewModel"><a href="#（2）Activity-获取带参数的-ViewModel" class="headerlink" title="（2）Activity 获取带参数的 ViewModel"></a><strong>（2）Activity 获取带参数的 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels &#123;</span><br><span class="line">        CounterViewModelFactory(5) // 传入初始值 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        counterViewModel.count.observe(this) &#123; newCount -&gt;</span><br><span class="line">            textView.text = newCount.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>支持带参数的 ViewModel（如从数据库或网络获取初始数据）</strong>。</p><hr><h2 id="🔹-6-ViewModel-Room-持久化数据库数据"><a href="#🔹-6-ViewModel-Room-持久化数据库数据" class="headerlink" title="🔹 6. ViewModel + Room 持久化数据库数据"></a><strong>🔹 6. ViewModel + Room 持久化数据库数据</strong></h2><p>如果你使用 <code>Room</code> 存储数据，<code>ViewModel</code> 可以直接从 <code>Room</code> 获取 <code>LiveData</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface DiaryDao &#123;</span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">    fun getAllDiaries(): LiveData&lt;List&lt;DiaryEntry&gt;&gt; // LiveData 监听数据库</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val diaryList: LiveData&lt;List&lt;DiaryEntry&gt;&gt; = diaryDao.getAllDiaries()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Fragment</code> 观察数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diaryViewModel.diaryList.observe(viewLifecycleOwner) &#123; diaryList -&gt;</span><br><span class="line">    diaryAdapter.submitList(diaryList) // 更新 UI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>Room + ViewModel + LiveData 确保数据持久化，并自动更新 UI</strong>。</p><hr><h2 id="🔹-7-ViewModel-Kotlin-Flow（协程）"><a href="#🔹-7-ViewModel-Kotlin-Flow（协程）" class="headerlink" title="🔹 7. ViewModel + Kotlin Flow（协程）"></a><strong>🔹 7. ViewModel + Kotlin Flow（协程）</strong></h2><p>如果你用 <code>Flow</code>，可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val diaryListFlow = diaryDao.getAllDiariesFlow()</span><br><span class="line">        .stateIn(viewModelScope, SharingStarted.Lazily, emptyList()) // 转为 StateFlow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Fragment</code> 中 <code>collect</code> 数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    viewModel.diaryListFlow.collect &#123; diaryList -&gt;</span><br><span class="line">        diaryAdapter.submitList(diaryList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong><code>Flow</code> 更适合复杂数据流（如数据库、网络请求）</strong>。</p><hr><h2 id="🔹-8-ViewModel-生命周期"><a href="#🔹-8-ViewModel-生命周期" class="headerlink" title="🔹 8. ViewModel 生命周期"></a><strong>🔹 8. ViewModel 生命周期</strong></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>ViewModel 作用</strong></th></tr></thead><tbody><tr><td>旋转屏幕</td><td>保持数据不丢失</td></tr><tr><td>App 进后台</td><td>ViewModel 可能被销毁（可用 <code>SavedStateHandle</code> 处理）</td></tr><tr><td>Fragment 切换</td><td>共享 <code>ViewModel</code> 以保留数据</td></tr></tbody></table><hr><h2 id="🔹-总结"><a href="#🔹-总结" class="headerlink" title="🔹 总结"></a><strong>🔹 总结</strong></h2><p>✅ <code>ViewModel</code> <strong>用于管理 UI 相关数据，避免因屏幕旋转导致数据丢失</strong>。<br> ✅ 搭配 <code>LiveData</code> <strong>自动通知 UI 变化</strong>。<br> ✅ <code>ViewModel</code> + <code>Room</code> <strong>可以自动监听数据库变化</strong>。<br> ✅ <code>ViewModel</code> + <code>Flow</code> <strong>适合复杂数据流处理</strong>。<br> ✅ <code>ViewModelFactory</code> <strong>用于创建带参数的 ViewModel</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Room用法</title>
      <link href="/2025/03/15/Room%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/Room%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Room 是 Android 官方推荐的数据库框架，它是 SQLite 的抽象封装，提供了更便捷的数据库操作方式，支持 Kotlin 协程和 LiveData。以下是 Room 的基本使用方法：</p><hr><h2 id="1-添加-Room-依赖"><a href="#1-添加-Room-依赖" class="headerlink" title="1. 添加 Room 依赖"></a><strong>1. 添加 Room 依赖</strong></h2><p>在 <code>build.gradle.kts</code>（模块级）中添加 Room 相关依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    val room_version = &quot;2.6.1&quot; // 确保使用最新版本</span><br><span class="line"></span><br><span class="line">    implementation(&quot;androidx.room:room-runtime:$room_version&quot;)</span><br><span class="line">    kapt(&quot;androidx.room:room-compiler:$room_version&quot;) // 用于注解处理器</span><br><span class="line"></span><br><span class="line">    implementation(&quot;androidx.room:room-ktx:$room_version&quot;) // 支持 Kotlin 协程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果项目使用 Kotlin Symbol Processing (KSP) 代替 kapt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ksp(&quot;androidx.room:room-compiler:$room_version&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="2-创建数据库实体（Entity）"><a href="#2-创建数据库实体（Entity）" class="headerlink" title="2. 创建数据库实体（Entity）"></a><strong>2. 创建数据库实体（Entity）</strong></h2><p>使用 <code>@Entity</code> 注解定义数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.Entity</span><br><span class="line">import androidx.room.PrimaryKey</span><br><span class="line"></span><br><span class="line">@Entity(tableName = &quot;diary_entries&quot;) // 指定表名</span><br><span class="line">data class DiaryEntry(</span><br><span class="line">    @PrimaryKey(autoGenerate = true) val id: Int = 0, // 主键，自动生成</span><br><span class="line">    val title: String,</span><br><span class="line">    val content: String,</span><br><span class="line">    val date: Long, // 以时间戳形式存储日期</span><br><span class="line">    val weather: String? = null</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="3-创建-DAO（数据访问对象）"><a href="#3-创建-DAO（数据访问对象）" class="headerlink" title="3. 创建 DAO（数据访问对象）"></a><strong>3. 创建 DAO（数据访问对象）</strong></h2><p>DAO 负责数据库的 CRUD 操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.*</span><br><span class="line"></span><br><span class="line">@Dao</span><br><span class="line">interface DiaryDao &#123;</span><br><span class="line">    @Insert(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    suspend fun insertDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    suspend fun updateDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    suspend fun deleteDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">    fun getAllDiaries(): List&lt;DiaryEntry&gt; // 直接返回列表（不推荐，建议使用 Flow）</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries WHERE id = :id&quot;)</span><br><span class="line">    suspend fun getDiaryById(id: Int): DiaryEntry?</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries WHERE title LIKE &#x27;%&#x27; || :query || &#x27;%&#x27;&quot;)</span><br><span class="line">    fun searchDiaries(query: String): List&lt;DiaryEntry&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要监听数据变化，可以用 <code>Flow</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">fun getAllDiariesFlow(): Flow&lt;List&lt;DiaryEntry&gt;&gt; // 使用 Flow 以支持实时监听</span><br></pre></td></tr></table></figure><hr><h2 id="4-创建数据库（Database）"><a href="#4-创建数据库（Database）" class="headerlink" title="4. 创建数据库（Database）"></a><strong>4. 创建数据库（Database）</strong></h2><p>使用 <code>@Database</code> 注解创建 Room 数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import androidx.room.Database</span><br><span class="line">import androidx.room.Room</span><br><span class="line">import androidx.room.RoomDatabase</span><br><span class="line"></span><br><span class="line">@Database(entities = [DiaryEntry::class], version = 1, exportSchema = false)</span><br><span class="line">abstract class DiaryDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun diaryDao(): DiaryDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile</span><br><span class="line">        private var INSTANCE: DiaryDatabase? = null</span><br><span class="line"></span><br><span class="line">        fun getDatabase(context: Context): DiaryDatabase &#123;</span><br><span class="line">            return INSTANCE ?: synchronized(this) &#123;</span><br><span class="line">                val instance = Room.databaseBuilder(</span><br><span class="line">                    context.applicationContext,</span><br><span class="line">                    DiaryDatabase::class.java,</span><br><span class="line">                    &quot;diary_database&quot;</span><br><span class="line">                ).build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：</p><ul><li><code>@Volatile</code> 确保多个线程能正确访问 <code>INSTANCE</code>。</li><li><code>synchronized(this)</code> 确保数据库实例的单例模式。</li></ul></blockquote><hr><h2 id="5-在-ViewModel-中使用"><a href="#5-在-ViewModel-中使用" class="headerlink" title="5. 在 ViewModel 中使用"></a><strong>5. 在 ViewModel 中使用</strong></h2><p>在 <code>ViewModel</code> 里封装数据库操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import kotlinx.coroutines.flow.Flow</span><br><span class="line"></span><br><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val allDiaries: Flow&lt;List&lt;DiaryEntry&gt;&gt; = diaryDao.getAllDiariesFlow()</span><br><span class="line"></span><br><span class="line">    suspend fun addDiary(entry: DiaryEntry) &#123;</span><br><span class="line">        diaryDao.insertDiary(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun deleteDiary(entry: DiaryEntry) &#123;</span><br><span class="line">        diaryDao.deleteDiary(entry)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>viewmodel</code> 目录下新建 <code>DiaryViewModelFactory.kt</code> 文件，并写入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import androidx.lifecycle.ViewModelProvider</span><br><span class="line">import com.example.uibestpractice.data.DiaryDao // 替换为你的包名</span><br><span class="line"></span><br><span class="line">class DiaryViewModelFactory(private val diaryDao: DiaryDao) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(DiaryViewModel::class.java)) &#123;</span><br><span class="line">            return DiaryViewModel(diaryDao) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-在-Activity-Fragment-中使用"><a href="#6-在-Activity-Fragment-中使用" class="headerlink" title="6. 在 Activity&#x2F;Fragment 中使用"></a><strong>6. 在 Activity&#x2F;Fragment 中使用</strong></h2><p>在 <code>Activity</code> 或 <code>Fragment</code> 里使用 ViewModel：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.activity.viewModels</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val diaryViewModel: DiaryViewModel by viewModels &#123;</span><br><span class="line">        DiaryViewModelFactory(DiaryDatabase.getDatabase(this).diaryDao())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        // 监听数据库变化</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            diaryViewModel.allDiaries.collect &#123; diaryList -&gt;</span><br><span class="line">                // 更新 UI</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun addDiaryEntry() &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            val newEntry = DiaryEntry(title = &quot;新日记&quot;, content = &quot;今天很开心！&quot;, date = System.currentTimeMillis())</span><br><span class="line">            diaryViewModel.addDiary(newEntry)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="7-线程调度（协程）"><a href="#7-线程调度（协程）" class="headerlink" title="7. 线程调度（协程）"></a><strong>7. 线程调度（协程）</strong></h2><p>Room 允许在 <code>suspend</code> 函数中调用数据库操作，Kotlin 协程会自动切换到 IO 线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun insertDiary(entry: DiaryEntry) &#123;</span><br><span class="line">    diaryDao.insertDiary(entry) // Room 在 IO 线程执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <strong>不支持协程的函数</strong>（如 <code>getAllDiaries()</code>），应使用 <code>withContext(Dispatchers.IO)</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun getAllDiariesBlocking(): List&lt;DiaryEntry&gt; &#123;</span><br><span class="line">    return runBlocking &#123; withContext(Dispatchers.IO) &#123; diaryDao.getAllDiaries() &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Room 提供了 <strong>简单、安全、高效</strong> 的数据库管理：</p><ol><li><strong>Entity</strong>（表） → <code>@Entity</code></li><li><strong>DAO</strong>（数据操作） → <code>@Dao</code></li><li><strong>Database</strong>（数据库实例） → <code>@Database</code></li><li><strong>ViewModel</strong>（封装业务逻辑）</li><li><strong>Activity&#x2F;Fragment</strong>（UI 层使用数据库）</li></ol><p>你可以结合 <code>Flow</code> 进行 <strong>实时监听</strong>，结合 <strong>Kotlin 协程</strong> 进行 <strong>异步处理</strong>，使数据库操作更加流畅高效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>startActivity和registerForActivityResult的用法</title>
      <link href="/2025/03/14/startActivity%E5%92%8CregisterForActivityResult%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/14/startActivity%E5%92%8CregisterForActivityResult%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 Android Kotlin 开发中，<code>startActivity</code> 和 <code>registerForActivityResult</code> 是启动新 Activity 并处理返回结果的两种方式。</p><hr><h2 id="1-使用-startActivity"><a href="#1-使用-startActivity" class="headerlink" title="1. 使用 startActivity"></a>1. 使用 <code>startActivity</code></h2><p><code>startActivity</code> 适用于 <strong>不需要获取返回值</strong> 的情况，例如从 <code>MainActivity</code> 跳转到 <code>SecondActivity</code>：</p><h3 id="示例：启动新-Activity"><a href="#示例：启动新-Activity" class="headerlink" title="示例：启动新 Activity"></a><strong>示例：启动新 Activity</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>如果你需要传递数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java).apply &#123;</span><br><span class="line">    putExtra(&quot;key&quot;, &quot;Hello, SecondActivity!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>在 <code>SecondActivity</code> 中获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val data = intent.getStringExtra(&quot;key&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="2-使用-registerForActivityResult"><a href="#2-使用-registerForActivityResult" class="headerlink" title="2. 使用 registerForActivityResult"></a>2. 使用 <code>registerForActivityResult</code></h2><p><code>registerForActivityResult</code> 适用于 <strong>需要从子 Activity 返回数据</strong> 的情况，比如用户选择了一个文件或拍照后返回图片。</p><h3 id="示例：启动-Activity-并获取返回值"><a href="#示例：启动-Activity-并获取返回值" class="headerlink" title="示例：启动 Activity 并获取返回值"></a><strong>示例：启动 Activity 并获取返回值</strong></h3><p>先在主 Activity 中注册一个 <code>ActivityResultLauncher</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private val launcher=registerForActivityResult(ActivityResultContracts.StartActivityForResult())&#123; result -&gt;</span><br><span class="line">    if (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        val data = result.data?.getStringExtra(&quot;result_key&quot;)</span><br><span class="line">        Toast.makeText(this, &quot;收到返回值: $data&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 <code>launcher.launch(intent)</code> 启动新 Activity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java)</span><br><span class="line">launcher.launch(intent)</span><br></pre></td></tr></table></figure><h3 id="在-SecondActivity-处理返回数据"><a href="#在-SecondActivity-处理返回数据" class="headerlink" title="在 SecondActivity 处理返回数据"></a><strong>在 SecondActivity 处理返回数据</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val resultIntent = Intent().apply &#123;</span><br><span class="line">    putExtra(&quot;result_key&quot;, &quot;返回的数据&quot;)</span><br><span class="line">&#125;</span><br><span class="line">setResult(Activity.RESULT_OK, resultIntent)</span><br><span class="line">finish()</span><br></pre></td></tr></table></figure><hr><h2 id="3-startActivityForResult-已废弃"><a href="#3-startActivityForResult-已废弃" class="headerlink" title="3. startActivityForResult 已废弃"></a>3. <code>startActivityForResult</code> 已废弃</h2><p><code>startActivityForResult</code> 在 API 30（Android 11）开始被 <strong>弃用</strong>，官方推荐使用 <code>registerForActivityResult</code> 代替。</p><p>如果你的代码仍然使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">startActivityForResult(intent, REQUEST_CODE)</span><br></pre></td></tr></table></figure><p>则应改用 <code>registerForActivityResult</code>。</p><hr><h2 id="4-其他-ActivityResultContracts"><a href="#4-其他-ActivityResultContracts" class="headerlink" title="4. 其他 ActivityResultContracts"></a>4. 其他 <code>ActivityResultContracts</code></h2><p><code>registerForActivityResult</code> 还支持多种 <code>ActivityResultContracts</code>，如：</p><ul><li><code>ActivityResultContracts.RequestPermission()</code>（请求单个权限）</li><li><code>ActivityResultContracts.GetContent()</code>（选择文件）</li><li><code>ActivityResultContracts.TakePicture()</code>（拍照）</li></ul><h3 id="示例：获取图片"><a href="#示例：获取图片" class="headerlink" title="示例：获取图片"></a><strong>示例：获取图片</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private val getImage = registerForActivityResult(ActivityResultContracts.GetContent()) &#123; uri: Uri? -&gt;</span><br><span class="line">    uri?.let &#123;</span><br><span class="line">        imageView.setImageURI(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    getImage.launch(&quot;image/*&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>总结：</strong></p><ul><li><code>startActivity()</code> 适用于无返回值的跳转。</li><li><code>registerForActivityResult()</code> 适用于需要获取返回值的情况，并且比 <code>startActivityForResult()</code> 更推荐。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit用法示例</title>
      <link href="/2025/03/14/Retrofit%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/14/Retrofit%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<ol start="5"><li><ul><li><h1 id="Retrofit-使用指南"><a href="#Retrofit-使用指南" class="headerlink" title="Retrofit 使用指南"></a><strong>Retrofit 使用指南</strong></h1><p><code>Retrofit</code> 是 Android 上最常用的网络请求库之一，它简化了 HTTP 请求的处理，支持 <strong>GET、POST、PUT、DELETE</strong> 等请求方式，并且可以配合 <code>Gson</code>、<code>Moshi</code> 等解析 JSON 数据。</p><hr><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a><strong>1. 添加依赖</strong></h2><p>在 <code>build.gradle</code>（Module 级）中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span><br><span class="line">    implementation &#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27; // Gson 解析 JSON</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-创建-API-接口"><a href="#2-创建-API-接口" class="headerlink" title="2. 创建 API 接口"></a><strong>2. 创建 API 接口</strong></h2><p>定义 API 接口，例如获取用户信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import retrofit2.Call</span><br><span class="line">import retrofit2.http.GET</span><br><span class="line">import retrofit2.http.Path</span><br><span class="line"></span><br><span class="line">interface ApiService &#123;</span><br><span class="line">    @GET(&quot;users/&#123;id&#125;&quot;)  // 定义 GET 请求，&#123;id&#125; 是动态路径参数</span><br><span class="line">    fun getUser(@Path(&quot;id&quot;) userId: Int): Call&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-定义数据模型"><a href="#3-定义数据模型" class="headerlink" title="3. 定义数据模型"></a><strong>3. 定义数据模型</strong></h2><p>Retrofit 需要解析服务器返回的 JSON 数据，因此要创建一个 <code>data class</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class User(</span><br><span class="line">    val id: Int,</span><br><span class="line">    val name: String,</span><br><span class="line">    val email: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="4-创建-Retrofit-实例"><a href="#4-创建-Retrofit-实例" class="headerlink" title="4. 创建 Retrofit 实例"></a><strong>4. 创建 Retrofit 实例</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import retrofit2.Retrofit</span><br><span class="line">import retrofit2.converter.gson.GsonConverterFactory</span><br><span class="line"></span><br><span class="line">object RetrofitClient &#123;</span><br><span class="line">    private const val BASE_URL = &quot;https://api.example.com/&quot;</span><br><span class="line"></span><br><span class="line">    val instance: ApiService by lazy &#123;</span><br><span class="line">        Retrofit.Builder()</span><br><span class="line">            .baseUrl(BASE_URL)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create()) // 自动解析 JSON</span><br><span class="line">            .build()</span><br><span class="line">            .create(ApiService::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-发起网络请求"><a href="#5-发起网络请求" class="headerlink" title="5. 发起网络请求"></a><strong>5. 发起网络请求</strong></h2><h3 id="方式-1：传统的同步请求"><a href="#方式-1：传统的同步请求" class="headerlink" title="方式 1：传统的同步请求"></a><strong>方式 1：传统的同步请求</strong></h3><p>在传统的同步请求中，我们会创建一个 <code>Call</code> 对象并使用 <code>execute()</code> 或 <code>enqueue()</code> 方法发起请求。</p><h4 id="同步请求代码-不推荐-："><a href="#同步请求代码-不推荐-：" class="headerlink" title="同步请求代码(不推荐)："></a>同步请求代码(不推荐)：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取 ApiService 实例</span><br><span class="line">val call = RetrofitClient.instance.getUser(1)  // 创建 Call 对象</span><br><span class="line"></span><br><span class="line">// 发起同步请求</span><br><span class="line">val response = call.execute()  // 使用 execute() 进行同步请求</span><br><span class="line"></span><br><span class="line">if (response.isSuccessful) &#123;</span><br><span class="line">    val user = response.body()</span><br><span class="line">    println(&quot;用户信息：$&#123;user?.name&#125;, $&#123;user?.email&#125;&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;请求失败: $&#123;response.code()&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execute()</code> 方法会同步阻塞线程，直到请求完成。通常情况下，<em><strong>不建议</strong></em>在主线程中使用这种方式，因为它可能导致应用的卡顿。</p><h4 id="异步请求代码："><a href="#异步请求代码：" class="headerlink" title="异步请求代码："></a>异步请求代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 获取 ApiService 实例</span><br><span class="line">val call = RetrofitClient.instance.getUser(1)  // 创建 Call 对象</span><br><span class="line"></span><br><span class="line">// 使用 enqueue() 发起异步请求</span><br><span class="line">call.enqueue(object : retrofit2.Callback&lt;User&gt; &#123;</span><br><span class="line">    override fun onResponse(call: Call&lt;User&gt;, response: retrofit2.Response&lt;User&gt;) &#123;</span><br><span class="line">        if (response.isSuccessful) &#123;</span><br><span class="line">            val user = response.body()</span><br><span class="line">            println(&quot;用户信息：$&#123;user?.name&#125;, $&#123;user?.email&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onFailure(call: Call&lt;User&gt;, t: Throwable) &#123;</span><br><span class="line">        println(&quot;请求失败: $&#123;t.message&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <code>enqueue()</code> 中使用回调来处理响应，它不会阻塞主线程，适合在 UI 线程中使用。</p><hr><h3 id="方式-2：使用协程-suspend（推荐方式）"><a href="#方式-2：使用协程-suspend（推荐方式）" class="headerlink" title="方式 2：使用协程 + suspend（推荐方式）"></a><strong>方式 2：使用协程 + <code>suspend</code>（推荐方式）</strong></h3><p>Retrofit 也支持 Kotlin <strong>协程</strong>，这样可以避免 <code>enqueue()</code> 回调写法：</p><h4 id="修改-API-接口："><a href="#修改-API-接口：" class="headerlink" title="修改 API 接口："></a>修改 API 接口：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ApiService &#123;</span><br><span class="line">    @GET(&quot;users/&#123;id&#125;&quot;)</span><br><span class="line">    suspend fun getUser(@Path(&quot;id&quot;) userId: Int): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在-ViewModel-里使用-suspend-请求："><a href="#在-ViewModel-里使用-suspend-请求：" class="headerlink" title="在 ViewModel 里使用 suspend 请求："></a>在 ViewModel 里使用 <code>suspend</code> 请求：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.CoroutineScope</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">fun fetchUserData() &#123;</span><br><span class="line">    CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            val user = RetrofitClient.instance.getUser(1)</span><br><span class="line">            println(&quot;用户信息: $&#123;user.name&#125;, $&#123;user.email&#125;&quot;)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            println(&quot;请求失败: $&#123;e.message&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>无回调地狱</strong>，代码更简洁。</li><li><strong>自动处理异步任务</strong>，适用于现代 Android 开发。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><p><strong>添加依赖</strong> (<code>Retrofit + Gson</code>)。</p></li><li><p><strong>创建 API 接口</strong> (<code>interface ApiService</code>)。</p></li><li><p><strong>定义数据模型</strong> (<code>data class User</code>)。</p></li><li><p><strong>创建 Retrofit 实例</strong> (<code>RetrofitClient</code>)。</p></li><li><p>发起请求</p><p>：</p><ul><li><strong>方式 1</strong>：使用 <code>Call</code> 对象 + <code>execute()</code> 或 <code>enqueue()</code>（传统方式）。</li><li><strong>方式 2</strong>：使用 <code>suspend</code> 函数 + 协程（推荐现代写法）。</li></ul></li></ol></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD命令大全</title>
      <link href="/2025/03/13/CMD%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2025/03/13/CMD%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CMD-命令大全：从入门到精通"><a href="#CMD-命令大全：从入门到精通" class="headerlink" title="CMD 命令大全：从入门到精通"></a>CMD 命令大全：从入门到精通</h1><p>命令提示符（CMD）是 Windows 操作系统中的命令行界面，允许用户通过输入命令来执行各种任务。它是一个强大的工具，适用于系统管理、网络配置、文件操作等多种场景。本文详细介绍了常用的 CMD 命令，帮助你从入门到精通 CMD。<strong>不过也可以直接打help寻找命令的。</strong></p><p>[参考来源](<a href="https://blog.csdn.net/m0_70474954/article/details/143496800">CMD 命令大全：从入门到精通_cmd命令-CSDN博客</a>)</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#cmd-%E5%9F%BA%E7%A1%80">CMD 基础</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">文件和目录操作命令</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4">系统信息获取命令</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4">网络配置命令</a></li><li><a href="#%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">磁盘和文件系统操作命令</a></li><li><a href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6">批处理文件</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li><li><a href="#cmd-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7">CMD 高级技巧</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">常见问题与解决方案</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ol><hr><h2 id="CMD-基础"><a href="#CMD-基础" class="headerlink" title="CMD 基础"></a>CMD 基础</h2><h3 id="1-1-打开-CMD"><a href="#1-1-打开-CMD" class="headerlink" title="1.1 打开 CMD"></a>1.1 打开 CMD</h3><p>在 Windows 中，可通过以下方式打开命令提示符：</p><ul><li>按 <code>Win + R</code>，输入 <code>cmd</code>，然后按 <code>Enter</code>。</li><li>在开始菜单中搜索 “cmd” 或 “命令提示符”。</li></ul><h3 id="1-2-常用命令格式"><a href="#1-2-常用命令格式" class="headerlink" title="1.2 常用命令格式"></a>1.2 常用命令格式</h3><p>CMD 命令通常遵循以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 [参数]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /w</span><br></pre></td></tr></table></figure><p>其中 <code>dir</code> 是命令，<code>/w</code> 是参数。</p><hr><h2 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h2><h3 id="2-1-查看当前目录"><a href="#2-1-查看当前目录" class="headerlink" title="2.1 查看当前目录"></a>2.1 查看当前目录</h3><p>使用 <code>cd</code> 命令显示当前工作目录的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure><h3 id="2-2-列出目录中的文件"><a href="#2-2-列出目录中的文件" class="headerlink" title="2.2 列出目录中的文件"></a>2.2 列出目录中的文件</h3><p>使用 <code>dir</code> 命令列出当前目录中的所有文件和子目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><h3 id="2-3-进入目录"><a href="#2-3-进入目录" class="headerlink" title="2.3 进入目录"></a>2.3 进入目录</h3><p>使用 <code>cd [目录路径]</code> 进入指定目录。例如，进入 <code>D:\Documents</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd D:\Documents</span><br></pre></td></tr></table></figure><h3 id="2-4-返回上一级目录"><a href="#2-4-返回上一级目录" class="headerlink" title="2.4 返回上一级目录"></a>2.4 返回上一级目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><h3 id="2-5-创建新目录"><a href="#2-5-创建新目录" class="headerlink" title="2.5 创建新目录"></a>2.5 创建新目录</h3><p>使用 <code>mkdir [目录名]</code> 创建新目录。例如，创建一个名为 <code>NewFolder</code> 的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir NewFolder</span><br></pre></td></tr></table></figure><h3 id="2-6-删除目录"><a href="#2-6-删除目录" class="headerlink" title="2.6 删除目录"></a>2.6 删除目录</h3><p>使用 <code>rmdir [目录名]</code> 删除空目录。如果要删除非空目录，请使用 <code>/s</code> 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /s [目录名]</span><br></pre></td></tr></table></figure><h3 id="2-7-复制文件"><a href="#2-7-复制文件" class="headerlink" title="2.7 复制文件"></a>2.7 复制文件</h3><p>使用 <code>copy [源文件路径] [目标路径]</code> 复制文件。例如，将 <code>file.txt</code> 复制到 <code>D:\Backup</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy file.txt D:\Backup</span><br></pre></td></tr></table></figure><h3 id="2-8-移动文件"><a href="#2-8-移动文件" class="headerlink" title="2.8 移动文件"></a>2.8 移动文件</h3><p>使用 <code>move [源文件路径] [目标路径]</code> 移动文件。例如，将 <code>file.txt</code> 移动到 <code>D:\Documents</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move file.txt D:\Documents</span><br></pre></td></tr></table></figure><h3 id="2-9-删除文件"><a href="#2-9-删除文件" class="headerlink" title="2.9 删除文件"></a>2.9 删除文件</h3><p>使用 <code>del [文件名]</code> 删除文件。例如，删除 <code>file.txt</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del file.txt</span><br></pre></td></tr></table></figure><h3 id="2-10-重命名文件"><a href="#2-10-重命名文件" class="headerlink" title="2.10 重命名文件"></a>2.10 重命名文件</h3><p>使用 <code>ren [旧文件名] [新文件名]</code> 重命名文件。例如，将 <code>oldfile.txt</code> 重命名为 <code>newfile.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren oldfile.txt newfile.txt</span><br></pre></td></tr></table></figure><hr><h2 id="系统信息获取命令"><a href="#系统信息获取命令" class="headerlink" title="系统信息获取命令"></a>系统信息获取命令</h2><h3 id="3-1-查看系统信息"><a href="#3-1-查看系统信息" class="headerlink" title="3.1 查看系统信息"></a>3.1 查看系统信息</h3><p>使用 <code>systeminfo</code> 显示计算机的详细信息（操作系统版本、内存、网络适配器等）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><h3 id="3-2-查看当前用户"><a href="#3-2-查看当前用户" class="headerlink" title="3.2 查看当前用户"></a>3.2 查看当前用户</h3><p>使用 <code>whoami</code> 显示当前登录的用户名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><h3 id="3-3-查看计算机名"><a href="#3-3-查看计算机名" class="headerlink" title="3.3 查看计算机名"></a>3.3 查看计算机名</h3><p>使用 <code>hostname</code> 显示计算机的主机名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure><h3 id="3-4-查看进程列表"><a href="#3-4-查看进程列表" class="headerlink" title="3.4 查看进程列表"></a>3.4 查看进程列表</h3><p>使用 <code>tasklist</code> 列出当前运行的所有进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><h3 id="3-5-结束进程"><a href="#3-5-结束进程" class="headerlink" title="3.5 结束进程"></a>3.5 结束进程</h3><p>使用 <code>taskkill /IM [进程名] /F</code> 强制结束指定进程。例如，结束 <code>notepad.exe</code> 进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /IM notepad.exe /F</span><br></pre></td></tr></table></figure><hr><h2 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h2><h3 id="4-1-查看-IP-配置"><a href="#4-1-查看-IP-配置" class="headerlink" title="4.1 查看 IP 配置"></a>4.1 查看 IP 配置</h3><p>使用 <code>ipconfig</code> 显示计算机的 IP 地址、子网掩码和默认网关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><h3 id="4-2-刷新-IP-地址"><a href="#4-2-刷新-IP-地址" class="headerlink" title="4.2 刷新 IP 地址"></a>4.2 刷新 IP 地址</h3><p>使用以下命令释放并更新 DHCP 分配的 IP 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /release</span><br><span class="line">ipconfig /renew</span><br></pre></td></tr></table></figure><h3 id="4-3-查看网络连接"><a href="#4-3-查看网络连接" class="headerlink" title="4.3 查看网络连接"></a>4.3 查看网络连接</h3><p>使用 <code>netstat</code> 显示当前所有网络连接和监听端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br></pre></td></tr></table></figure><h3 id="4-4-测试网络连接"><a href="#4-4-测试网络连接" class="headerlink" title="4.4 测试网络连接"></a>4.4 测试网络连接</h3><p>使用 <code>ping [IP 地址或域名]</code> 测试网络连接。例如，测试与 Google 的连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.google.com</span><br></pre></td></tr></table></figure><h3 id="4-5-追踪路由"><a href="#4-5-追踪路由" class="headerlink" title="4.5 追踪路由"></a>4.5 追踪路由</h3><p>使用 <code>tracert [IP 地址或域名]</code> 追踪网络路由。例如，追踪到 Google 的路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert www.google.com</span><br></pre></td></tr></table></figure><hr><h2 id="磁盘和文件系统操作命令"><a href="#磁盘和文件系统操作命令" class="headerlink" title="磁盘和文件系统操作命令"></a>磁盘和文件系统操作命令</h2><h3 id="5-1-查看磁盘使用情况"><a href="#5-1-查看磁盘使用情况" class="headerlink" title="5.1 查看磁盘使用情况"></a>5.1 查看磁盘使用情况</h3><p>使用以下命令显示每个逻辑磁盘的总大小和可用空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic logicaldisk get size,freespace,caption</span><br></pre></td></tr></table></figure><h3 id="5-2-格式化磁盘"><a href="#5-2-格式化磁盘" class="headerlink" title="5.2 格式化磁盘"></a>5.2 格式化磁盘</h3><p>使用 <code>format [驱动器:] /FS:[文件系统]</code> 格式化磁盘。例如，将 D 盘格式化为 NTFS 文件系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format D: /FS:NTFS</span><br></pre></td></tr></table></figure><h3 id="5-3-检查磁盘错误"><a href="#5-3-检查磁盘错误" class="headerlink" title="5.3 检查磁盘错误"></a>5.3 检查磁盘错误</h3><p>使用 <code>chkdsk [驱动器:]</code> 检查磁盘错误。例如，检查 C 盘错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkdsk C:</span><br></pre></td></tr></table></figure><h3 id="5-4-显示磁盘分区信息"><a href="#5-4-显示磁盘分区信息" class="headerlink" title="5.4 显示磁盘分区信息"></a>5.4 显示磁盘分区信息</h3><p>使用 <code>diskpart</code> 进入 DiskPart 工具，然后在提示符下输入 <code>list disk</code> 查看所有磁盘信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskpart</span><br></pre></td></tr></table></figure><hr><h2 id="批处理文件"><a href="#批处理文件" class="headerlink" title="批处理文件"></a>批处理文件</h2><p>批处理文件是包含多个 CMD 命令的文本文件，便于一次性执行一系列命令。</p><h3 id="6-1-创建批处理文件"><a href="#6-1-创建批处理文件" class="headerlink" title="6.1 创建批处理文件"></a>6.1 创建批处理文件</h3><p>使用文本编辑器（如 Notepad）创建一个 <code>.bat</code> 文件，并输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo Hello, World!</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="6-2-运行批处理文件"><a href="#6-2-运行批处理文件" class="headerlink" title="6.2 运行批处理文件"></a>6.2 运行批处理文件</h3><p>双击 <code>.bat</code> 文件，或在 CMD 中输入文件路径来运行该文件。</p><hr><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="7-1-查看环境变量"><a href="#7-1-查看环境变量" class="headerlink" title="7.1 查看环境变量"></a>7.1 查看环境变量</h3><p>使用 <code>set</code> 命令显示所有环境变量及其值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure><h3 id="7-2-设置环境变量"><a href="#7-2-设置环境变量" class="headerlink" title="7.2 设置环境变量"></a>7.2 设置环境变量</h3><p>使用 <code>set [变量名]=[值]</code> 设置环境变量。例如，设置名为 <code>MY_VAR</code> 的环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MY_VAR=Hello</span><br></pre></td></tr></table></figure><h3 id="7-3-删除环境变量"><a href="#7-3-删除环境变量" class="headerlink" title="7.3 删除环境变量"></a>7.3 删除环境变量</h3><p>将环境变量值设为空即可删除。例如，删除 <code>MY_VAR</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MY_VAR=</span><br></pre></td></tr></table></figure><hr><h2 id="CMD-高级技巧"><a href="#CMD-高级技巧" class="headerlink" title="CMD 高级技巧"></a>CMD 高级技巧</h2><h3 id="8-1-使用管道"><a href="#8-1-使用管道" class="headerlink" title="8.1 使用管道"></a>8.1 使用管道</h3><p>管道符号 <code>|</code> 可将一个命令的输出传递给另一个命令。例如，查找进程列表中包含 “chrome” 的进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | find &quot;chrome&quot;</span><br></pre></td></tr></table></figure><h3 id="8-2-使用重定向"><a href="#8-2-使用重定向" class="headerlink" title="8.2 使用重定向"></a>8.2 使用重定向</h3><p>重定向符 <code>&gt;</code> 可将命令的输出保存到文件中。例如，将 <code>dir</code> 命令的输出保存到 <code>output.txt</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir &gt; output.txt</span><br></pre></td></tr></table></figure><h3 id="8-3-批量重命名文件"><a href="#8-3-批量重命名文件" class="headerlink" title="8.3 批量重命名文件"></a>8.3 批量重命名文件</h3><p>使用 <code>for</code> 循环批量重命名文件。例如，将当前目录下的所有 <code>.txt</code> 文件重命名为 <code>.bak</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for %f in (*.txt) do ren &quot;%f&quot; &quot;*.bak&quot;</span><br></pre></td></tr></table></figure><p><em>注：在批处理文件中使用 for 循环时，需将 <code>%f</code> 替换为 <code>%%f</code>。</em></p><hr><h2 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h2><h3 id="9-1-CMD-无法识别命令"><a href="#9-1-CMD-无法识别命令" class="headerlink" title="9.1 CMD 无法识别命令"></a>9.1 CMD 无法识别命令</h3><ul><li>如果 CMD 提示 “不是内部或外部命令”，可能是因为命令输入错误或相应程序未安装。</li></ul><h3 id="9-2-权限不足"><a href="#9-2-权限不足" class="headerlink" title="9.2 权限不足"></a>9.2 权限不足</h3><ul><li>某些命令需要管理员权限。请右键点击 CMD 图标，选择“以管理员身份运行”。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了 CMD 的基本命令、文件和目录操作、系统信息获取、网络配置等内容。通过具体示例和操作说明，帮助你更好地理解和掌握 CMD 的使用。希望这份 CMD 命令大全能帮助你提高工作效率，成为 CMD 使用的高手！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task3 Android Diary</title>
      <link href="/2025/03/05/Task3-Diary/"/>
      <url>/2025/03/05/Task3-Diary/</url>
      
        <content type="html"><![CDATA[<h1 id="MY-API-KEY-和风"><a href="#MY-API-KEY-和风" class="headerlink" title="MY API KEY(和风)"></a>MY API KEY(和风)</h1><p>670ca929136a456992608cd2e794df24</p><h1 id="Mainactivity"><a href="#Mainactivity" class="headerlink" title="Mainactivity"></a>Mainactivity</h1><h2 id="超级好的Mainactivity"><a href="#超级好的Mainactivity" class="headerlink" title="超级好的Mainactivity"></a>超级好的Mainactivity</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line"></span><br><span class="line">import androidx.core.widget.addTextChangedListener</span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.BroadcastReceiver</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.IntentFilter</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line">import androidx.appcompat.app.AlertDialog</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.Observer</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import com.example.diary_3.adapter.DiaryAdapter</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityMainBinding</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var binding: ActivityMainBinding</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line">    private val addDiaryLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">        when (result.resultCode) &#123;</span><br><span class="line">            Activity.RESULT_OK -&gt; loadAllDiaries()</span><br><span class="line">            Activity.RESULT_CANCELED -&gt; &#123;&#125;</span><br><span class="line">            else -&gt; Log.d(&quot;MainActivity&quot;, &quot;未知的返回结果: $&#123;result.resultCode&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private val diarySavedReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            if (intent?.action == &quot;SAVED&quot;) &#123;</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        binding.recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line">        diaryAdapter = DiaryAdapter(this, emptyList())</span><br><span class="line">        binding.recyclerView.adapter = diaryAdapter</span><br><span class="line"></span><br><span class="line">        val filter = IntentFilter(&quot;SAVED&quot;)</span><br><span class="line">        registerReceiver(diarySavedReceiver, filter)</span><br><span class="line"></span><br><span class="line">        loadAllDiaries()</span><br><span class="line"></span><br><span class="line">        // 监听搜索框</span><br><span class="line">        binding.searchBox.addTextChangedListener &#123; text -&gt;</span><br><span class="line">            searchDiaries(text.toString())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 启动添加日记页面</span><br><span class="line">        binding.addDiaryButton.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this, AddDiaryActivity::class.java)</span><br><span class="line">            addDiaryLauncher.launch(intent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 绑定删除按钮</span><br><span class="line">        binding.deleteDiaryButton.setOnClickListener &#123;</span><br><span class="line">            deleteDiary()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除日记的方法</span><br><span class="line">    private fun deleteDiary() &#123;</span><br><span class="line">        val diaries = diaryAdapter.getCurrentDiaries()</span><br><span class="line">        if (diaries.isEmpty()) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;当前没有日记可删除&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val diaryTitles = diaries.map &#123; it.title &#125;.toTypedArray()</span><br><span class="line">        var selectedIndex = 0</span><br><span class="line"></span><br><span class="line">        AlertDialog.Builder(this)</span><br><span class="line">            .setTitle(&quot;选择要删除的日记&quot;)</span><br><span class="line">            .setSingleChoiceItems(diaryTitles, 0) &#123; _, which -&gt;</span><br><span class="line">                selectedIndex = which</span><br><span class="line">            &#125;</span><br><span class="line">            .setPositiveButton(&quot;删除&quot;) &#123; _, _ -&gt;</span><br><span class="line">                val diaryToDelete = diaries[selectedIndex]</span><br><span class="line">                lifecycleScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">                    diaryDatabase.diaryDao().deleteDiary(diaryToDelete)</span><br><span class="line">                    withContext(Dispatchers.Main) &#123;</span><br><span class="line">                        loadAllDiaries()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .setNegativeButton(&quot;取消&quot;, null)</span><br><span class="line">            .show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加载所有日记</span><br><span class="line">    private fun loadAllDiaries() &#123;</span><br><span class="line">        diaryDatabase.diaryDao().getDiaries().observe(this, Observer &#123; diaries -&gt;</span><br><span class="line">            diaryAdapter.updateData(diaries) // 更新数据</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 搜索日记</span><br><span class="line">    private fun searchDiaries(query: String) &#123;</span><br><span class="line">        diaryDatabase.diaryDao().searchDiaries(&quot;%$query%&quot;)</span><br><span class="line">            .observe(this, Observer &#123; diaries -&gt;</span><br><span class="line">                diaryAdapter.updateData(diaries)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        unregisterReceiver(diarySavedReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line">import androidx.core.widget.addTextChangedListener</span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.BroadcastReceiver</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.IntentFilter</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.text.Editable</span><br><span class="line">import android.text.TextWatcher</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line">import androidx.annotation.RequiresApi</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import androidx.room.InvalidationTracker</span><br><span class="line">import com.example.diary_3.adapter.DiaryAdapter</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityMainBinding</span><br><span class="line">import java.util.concurrent.Executors</span><br><span class="line">import kotlinx.coroutines.CoroutineScope</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line">import androidx.lifecycle.Observer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var binding: ActivityMainBinding</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private val addDiaryLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">        when (result.resultCode) &#123;</span><br><span class="line">            Activity.RESULT_OK -&gt; &#123;</span><br><span class="line">                // 如果有返回结果，刷新数据</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">            Activity.RESULT_CANCELED -&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; &#123;</span><br><span class="line">                // 处理其他可能的返回情况</span><br><span class="line">                Log.d(&quot;MainActivity&quot;, &quot;未知的返回结果: $&#123;result.resultCode&#125;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private val diarySavedReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            if (intent?.action == &quot;SAVED&quot;) &#123;</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//gl gd</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        binding.recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line">        diaryAdapter = DiaryAdapter(this, emptyList())</span><br><span class="line">        binding.recyclerView.adapter = diaryAdapter</span><br><span class="line">        val filter = IntentFilter(&quot;SAVED&quot;)</span><br><span class="line">        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) &#123;</span><br><span class="line">            registerReceiver(diarySavedReceiver, filter, Context.RECEIVER_NOT_EXPORTED)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            registerReceiver(diarySavedReceiver, filter, RECEIVER_NOT_EXPORTED)</span><br><span class="line">        &#125;//ys5 gd</span><br><span class="line">        loadAllDiaries()</span><br><span class="line">        binding.searchBox.addTextChangedListener &#123; text -&gt;</span><br><span class="line">            searchDiaries(text.toString())</span><br><span class="line">        &#125;//ys3 gd</span><br><span class="line">        // 使用 ActivityResultLauncher 启动 AddDiaryActivity</span><br><span class="line">        binding.addDiaryButton.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this, AddDiaryActivity::class.java)</span><br><span class="line">            addDiaryLauncher.launch(intent)</span><br><span class="line">        &#125;//ys4 gd</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun loadAllDiaries() &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            val diaries = withContext(Dispatchers.IO) &#123;</span><br><span class="line">                diaryDatabase.diaryDao().getAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">            diaryAdapter.updateData(diaries) // 更新数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//ys8 gd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun searchDiaries(query: String) &#123;</span><br><span class="line">        diaryDatabase.diaryDao().searchDiaries(&quot;%$query%&quot;)</span><br><span class="line">            .observe(this, object : Observer&lt;List&lt;Diary&gt;&gt; &#123;</span><br><span class="line">                override fun onChanged(diaries: List&lt;Diary&gt;) &#123;</span><br><span class="line">                    diaryAdapter = DiaryAdapter(this@MainActivity, diaries)</span><br><span class="line">                    binding.recyclerView.adapter = diaryAdapter</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;//ys9 gd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        unregisterReceiver(diarySavedReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="AddDiaryActivity"><a href="#AddDiaryActivity" class="headerlink" title="AddDiaryActivity"></a>AddDiaryActivity</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line">import androidx.appcompat.app.AlertDialog</span><br><span class="line">import android.view.View</span><br><span class="line">import android.widget.EditText</span><br><span class="line">import com.example.diary_3.utils.DateUtils</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.pm.PackageManager</span><br><span class="line">import android.net.Uri</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.os.Looper</span><br><span class="line">import android.provider.MediaStore</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.core.app.ActivityCompat</span><br><span class="line">import androidx.core.content.ContextCompat</span><br><span class="line">import com.bumptech.glide.Glide</span><br><span class="line">import com.bumptech.glide.request.RequestOptions</span><br><span class="line">import com.example.diary_3.R</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityAddDiaryBinding</span><br><span class="line">import com.example.diary_3.model.CityResponse</span><br><span class="line">import com.example.diary_3.model.WeatherResponse</span><br><span class="line">import com.example.diary_3.network.RetrofitClient</span><br><span class="line">import com.example.diary_3.network.WeatherApi</span><br><span class="line">import com.example.diary_3.utils.LocationUtils</span><br><span class="line">import retrofit2.Call</span><br><span class="line">import retrofit2.Callback</span><br><span class="line">import retrofit2.Response</span><br><span class="line">import java.util.Calendar</span><br><span class="line">import java.util.concurrent.Executors</span><br><span class="line"></span><br><span class="line">class AddDiaryActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val selectedLocalImageUris = mutableListOf&lt;Uri&gt;()</span><br><span class="line">    private val networkImageUrls = mutableListOf&lt;String&gt;()</span><br><span class="line">    private val API_KEY = &quot;670ca929136a456992608cd2e794df24&quot;</span><br><span class="line">    private lateinit var binding: ActivityAddDiaryBinding</span><br><span class="line">    private var selectedDate: Calendar = Calendar.getInstance()</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var locationUtils: LocationUtils</span><br><span class="line">    private val PERMISSION_REQUEST_CODE = 1</span><br><span class="line">    private var selectedLocalImageUri: Uri? = null</span><br><span class="line">    private var networkImageUrl: String? = null</span><br><span class="line"></span><br><span class="line">    private fun hasPermission(permission: String): Boolean &#123;</span><br><span class="line">        return ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityAddDiaryBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        locationUtils = LocationUtils(this)</span><br><span class="line"></span><br><span class="line">        binding.selectImageButton.setOnClickListener &#123;</span><br><span class="line">            pickLocalImage()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binding.addNetworkImageButton.setOnClickListener &#123;</span><br><span class="line">            // 创建一个输入框</span><br><span class="line">            val input = EditText(this)</span><br><span class="line">            input.hint = &quot;请输入有效的图片链接&quot;</span><br><span class="line"></span><br><span class="line">            // 构建对话框</span><br><span class="line">            AlertDialog.Builder(this)</span><br><span class="line">                .setTitle(&quot;输入图片URL&quot;)</span><br><span class="line">                .setView(input)</span><br><span class="line">                .setPositiveButton(&quot;确定&quot;) &#123; dialog, which -&gt;</span><br><span class="line">                    val url = input.text.toString().trim()</span><br><span class="line">                    if (url.isNotBlank()) &#123;</span><br><span class="line">                        networkImageUrl = url</span><br><span class="line">                        Glide.with(this)</span><br><span class="line">                            .load(url)</span><br><span class="line">                            .placeholder(R.drawable.loading_placeholder) // 加载过程中的占位符图片</span><br><span class="line">                            .apply(RequestOptions.circleCropTransform())</span><br><span class="line">                            .error(R.drawable.no) // 加载失败时显示的图片</span><br><span class="line">                            .into(binding.selectedImageView)</span><br><span class="line">                        binding.selectedImageView.visibility = View.VISIBLE</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Toast.makeText(this, &quot;请输入有效的图片链接&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                        binding.selectedImageView.visibility = View.GONE</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .setNegativeButton(&quot;取消&quot;) &#123; dialog, which -&gt;</span><br><span class="line">                    dialog.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">                .show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binding.saveDiaryButton.setOnClickListener &#123;</span><br><span class="line">            saveDiary()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 新增按钮：点击刷新地点和天气</span><br><span class="line">        binding.refreshWeatherLocationButton.setOnClickListener &#123;</span><br><span class="line">            getLocation()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val permissionsToRequest = mutableListOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        if (!hasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION)) &#123;</span><br><span class="line">            permissionsToRequest.add(android.Manifest.permission.ACCESS_FINE_LOCATION)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!hasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">            permissionsToRequest.add(android.Manifest.permission.READ_EXTERNAL_STORAGE)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (permissionsToRequest.isNotEmpty()) &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(</span><br><span class="line">                this,</span><br><span class="line">                permissionsToRequest.toTypedArray(),</span><br><span class="line">                PERMISSION_REQUEST_CODE</span><br><span class="line">            )</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            getLocation()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun pickLocalImage() &#123;</span><br><span class="line">        val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)</span><br><span class="line">        startActivityForResult(intent, 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123;</span><br><span class="line">        super.onActivityResult(requestCode, resultCode, data)</span><br><span class="line"></span><br><span class="line">        if (requestCode == 1 &amp;&amp; resultCode == RESULT_OK &amp;&amp; data != null) &#123;</span><br><span class="line">            selectedLocalImageUri = data.data</span><br><span class="line">            Glide.with(this)</span><br><span class="line">                .load(selectedLocalImageUri)</span><br><span class="line">                .into(binding.selectedImageView)</span><br><span class="line">            binding.selectedImageView.visibility = android.view.View.VISIBLE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getLocation() &#123;</span><br><span class="line">        locationUtils.getLocation &#123; location -&gt;</span><br><span class="line">            if (location != null) &#123;</span><br><span class="line">                val latitude = location.latitude</span><br><span class="line">                val longitude = location.longitude</span><br><span class="line">                Log.d(&quot;AddDiaryActivity&quot;, &quot;获取到的经纬度: 纬度 $latitude, 经度 $longitude&quot;)</span><br><span class="line">                // 格式化经纬度字符串，注意这里 longitude 和 latitude 的顺序可以根据接口要求调整</span><br><span class="line">                val loc = String.format(&quot;%.2f,%.2f&quot;, location.longitude, location.latitude)</span><br><span class="line">                Executors.newSingleThreadExecutor().execute &#123;</span><br><span class="line">                    runOnUiThread &#123;</span><br><span class="line">                        binding.locationTextView.text = loc</span><br><span class="line">                        getCityId(loc)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                runOnUiThread &#123;</span><br><span class="line">                    Toast.makeText(this, &quot;无法获取当前位置&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun showToastOnUiThread(message: String) &#123;</span><br><span class="line">        if (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                Toast.makeText(this, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getCityId(cityName: String) &#123;</span><br><span class="line">        val weatherApi = RetrofitClient.geoInstance.create(WeatherApi::class.java)</span><br><span class="line">        weatherApi.getCityInfo(API_KEY, cityName).enqueue(object : Callback&lt;CityResponse&gt; &#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;CityResponse&gt;, response: Response&lt;CityResponse&gt;) &#123;</span><br><span class="line">                if (response.isSuccessful &amp;&amp; response.body()?.code == &quot;200&quot;) &#123;</span><br><span class="line">                    val cityLocation = response.body()?.location?.firstOrNull()</span><br><span class="line">                    if (cityLocation != null) &#123;</span><br><span class="line">                        binding.locationTextView.text = cityLocation.name</span><br><span class="line">                        getWeatherInfo(cityLocation.id)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.e(&quot;AddDiaryActivity&quot;, &quot;获取城市 ID 失败: $&#123;response.message()&#125;, 响应代码: $&#123;response.code()&#125;, 响应体: $&#123;response.errorBody()?.string()&#125;&quot;)</span><br><span class="line">                    showToastOnUiThread(&quot;获取城市 ID 失败&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;CityResponse&gt;, t: Throwable) &#123;</span><br><span class="line">                Log.e(&quot;AddDiaryActivity&quot;, &quot;获取城市 ID 网络请求失败: $&#123;t.message&#125;&quot;, t)</span><br><span class="line">                showToastOnUiThread(&quot;获取城市 ID 网络请求失败&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getWeatherInfo(cityId: String) &#123;</span><br><span class="line">        val weatherApi = RetrofitClient.weatherInstance.create(WeatherApi::class.java)</span><br><span class="line">        weatherApi.getWeatherInfo(API_KEY, cityId).enqueue(object : Callback&lt;WeatherResponse&gt; &#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;WeatherResponse&gt;, response: Response&lt;WeatherResponse&gt;) &#123;</span><br><span class="line">                if (response.isSuccessful &amp;&amp; response.body()?.code == &quot;200&quot;) &#123;</span><br><span class="line">                    val today = DateUtils.formatDate(Calendar.getInstance().time)</span><br><span class="line">                    val todayWeather = response.body()?.daily?.firstOrNull &#123; it.fxDate == today &#125;</span><br><span class="line">                    if (todayWeather != null) &#123;</span><br><span class="line">                        val weatherText = todayWeather.textDay</span><br><span class="line">                        binding.weatherTextView.text = weatherText</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.e(&quot;AddDiaryActivity&quot;, &quot;获取天气信息失败: $&#123;response.message()&#125;, 响应代码: $&#123;response.code()&#125;, 响应体: $&#123;response.errorBody()?.string()&#125;&quot;)</span><br><span class="line">                    showToastOnUiThread(&quot;获取天气信息失败&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;WeatherResponse&gt;, t: Throwable) &#123;</span><br><span class="line">                Log.e(&quot;AddDiaryActivity&quot;, &quot;获取天气信息网络请求失败: $&#123;t.message&#125;&quot;, t)</span><br><span class="line">                showToastOnUiThread(&quot;获取天气信息网络请求失败&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun saveDiary() &#123;</span><br><span class="line">        Executors.newSingleThreadExecutor().execute &#123;</span><br><span class="line">            val title = binding.titleEditText.text.toString()</span><br><span class="line">            val content = binding.contentEditText.text.toString()</span><br><span class="line">            val localImagePath = selectedLocalImageUri?.toString()</span><br><span class="line">            val date = DateUtils.formatDate(Calendar.getInstance().time)</span><br><span class="line">            val weather = binding.weatherTextView.text.toString()</span><br><span class="line">            val location = binding.locationTextView.text.toString()</span><br><span class="line"></span><br><span class="line">            val diary = Diary(</span><br><span class="line">                title = title,</span><br><span class="line">                content = content,</span><br><span class="line">                localImagePath = localImagePath,</span><br><span class="line">                networkImageUrl = networkImageUrl,</span><br><span class="line">                date = date,</span><br><span class="line">                weather = weather,</span><br><span class="line">                location = location</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            diaryDatabase.diaryDao().insertDiary(diary)</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                Toast.makeText(this, &quot;日记保存成功&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                val intent = Intent(&quot;SAVED&quot;) // 或者 &quot;com.example.app.DIARY_SAVED&quot;</span><br><span class="line">                sendBroadcast(intent)</span><br><span class="line">                finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="DetailUtils"><a href="#DetailUtils" class="headerlink" title="DetailUtils"></a>DetailUtils</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final.utils</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Date</span><br><span class="line">import java.util.Locale</span><br><span class="line"></span><br><span class="line">object DateUtils &#123;</span><br><span class="line">    private const val DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;</span><br><span class="line"></span><br><span class="line">    // 线程安全的 SimpleDateFormat 生成</span><br><span class="line">    private fun getDateFormat(pattern: String): SimpleDateFormat &#123;</span><br><span class="line">        return SimpleDateFormat(pattern, Locale.getDefault())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 格式化日期（默认格式 &quot;yyyy-MM-dd&quot;）</span><br><span class="line">    fun formatDate(date: Date, pattern: String = DEFAULT_DATE_FORMAT): String &#123;</span><br><span class="line">        return getDateFormat(pattern).format(date)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取当前日期的格式化字符串</span><br><span class="line">    fun getCurrentDate(pattern: String = DEFAULT_DATE_FORMAT): String &#123;</span><br><span class="line">        return formatDate(Date(), pattern)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LocationUtils"><a href="#LocationUtils" class="headerlink" title="LocationUtils"></a>LocationUtils</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final.utils</span><br><span class="line"></span><br><span class="line">import android.Manifest</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.pm.PackageManager</span><br><span class="line">import android.location.Location</span><br><span class="line">import android.location.LocationListener</span><br><span class="line">import android.location.LocationManager</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.core.app.ActivityCompat</span><br><span class="line"></span><br><span class="line">class LocationUtils(private val context: Context) &#123;</span><br><span class="line"></span><br><span class="line">    private val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager</span><br><span class="line">    private var locationListener: LocationListener? = null</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前位置</span><br><span class="line">     */</span><br><span class="line">    fun getLocation(onLocationReceived: (Location) -&gt; Unit) &#123;</span><br><span class="line">        // 权限检查</span><br><span class="line">        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;</span><br><span class="line">            ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">        ) &#123;</span><br><span class="line">            return // 没有权限，直接返回</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取上次已知位置（可能会加快首次获取速度）</span><br><span class="line">        val lastKnownLocation: Location? = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER)</span><br><span class="line">            ?: locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)</span><br><span class="line">        if (lastKnownLocation != null) &#123;</span><br><span class="line">            onLocationReceived(lastKnownLocation)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 监听实时位置更新</span><br><span class="line">        locationListener = object : LocationListener &#123;</span><br><span class="line">            override fun onLocationChanged(location: Location) &#123;</span><br><span class="line">                onLocationReceived(location)</span><br><span class="line">                removeLocationUpdates() // 获取到位置后移除监听</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) &#123;&#125;</span><br><span class="line">            override fun onProviderEnabled(provider: String) &#123;&#125;</span><br><span class="line">            override fun onProviderDisabled(provider: String) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 请求位置更新（优先使用 GPS，网络作为备用）</span><br><span class="line">        try &#123;</span><br><span class="line">            locationManager.requestLocationUpdates(</span><br><span class="line">                LocationManager.GPS_PROVIDER,</span><br><span class="line">                5000L, // 5秒更新一次</span><br><span class="line">                10f,   // 10米变化更新</span><br><span class="line">                locationListener!!</span><br><span class="line">            )</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            locationManager.requestLocationUpdates(</span><br><span class="line">                LocationManager.NETWORK_PROVIDER,</span><br><span class="line">                5000L,</span><br><span class="line">                10f,</span><br><span class="line">                locationListener!!</span><br><span class="line">            )</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除位置更新监听，防止内存泄漏</span><br><span class="line">     */</span><br><span class="line">    fun removeLocationUpdates() &#123;</span><br><span class="line">        locationListener?.let &#123;</span><br><span class="line">            locationManager.removeUpdates(it)</span><br><span class="line">            locationListener = null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin语法</title>
      <link href="/2025/03/03/Kotlin%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/03/Kotlin%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-作用域函数"><a href="#1-作用域函数" class="headerlink" title="1. 作用域函数"></a>1. 作用域函数</h2><p>Kotlin 提供了一系列作用域函数，它们可以让你在对象的特定作用域内执行代码，从而避免重复引用对象（如 <code>this</code> 或 <code>it</code>），提高代码简洁性与可读性。</p><h3 id="1-1-apply-在对象自身作用域内修改对象"><a href="#1-1-apply-在对象自身作用域内修改对象" class="headerlink" title="1.1 apply - 在对象自身作用域内修改对象"></a>1.1 apply - 在对象自身作用域内修改对象</h3><ul><li><strong>返回值</strong>：调用者本身（this）</li><li><strong>使用场景</strong>：<ul><li>用于初始化对象，避免多次调用 set 方法</li><li>支持链式调用</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val person = Person().apply &#123;</span><br><span class="line">    name = &quot;Alice&quot;</span><br><span class="line">    age = 20</span><br><span class="line">&#125;</span><br><span class="line">println(person.name) // Alice</span><br><span class="line">println(person.age)  // 20</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br> 在 <code>apply</code> 的代码块中，<code>this</code> 代表当前对象，通过直接修改属性，最后返回修改后的对象本身。</p><hr><h3 id="1-2-let-适用于非空值的操作"><a href="#1-2-let-适用于非空值的操作" class="headerlink" title="1.2 let - 适用于非空值的操作"></a>1.2 let - 适用于非空值的操作</h3><ul><li><strong>返回值</strong>：Lambda 表达式的最后一行结果</li><li><strong>使用场景</strong>：<ul><li>针对可空对象进行操作，避免 NullPointerException</li><li>控制变量的作用域</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val name: String? = &quot;Kotlin&quot;</span><br><span class="line">name?.let &#123;</span><br><span class="line">    println(it.uppercase())  // KOTLIN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另一示例（变量作用域控制）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val number = 5</span><br><span class="line">val square = number.let &#123;</span><br><span class="line">    val result = it * it</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line">println(square) // 25</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-run-在对象作用域内执行代码并返回计算结果"><a href="#1-3-run-在对象作用域内执行代码并返回计算结果" class="headerlink" title="1.3 run - 在对象作用域内执行代码并返回计算结果"></a>1.3 run - 在对象作用域内执行代码并返回计算结果</h3><ul><li><strong>返回值</strong>：Lambda 表达式的最后一行结果</li><li><strong>使用场景</strong>：<ul><li>需要在对象上执行多个操作并返回一个结果</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val personInfo = Person().run &#123;</span><br><span class="line">    name = &quot;Bob&quot;</span><br><span class="line">    age = 25</span><br><span class="line">    &quot;名字是 $name, 年龄是 $age&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(personInfo)  // 名字是 Bob, 年龄是 25</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br> <code>run</code> 在对象作用域内执行操作，返回最后一行表达式的结果，而不是对象本身。</p><hr><h3 id="1-4-also-适用于对象的额外操作"><a href="#1-4-also-适用于对象的额外操作" class="headerlink" title="1.4 also - 适用于对象的额外操作"></a>1.4 also - 适用于对象的额外操作</h3><ul><li><strong>返回值</strong>：调用者本身（this）</li><li><strong>使用场景</strong>：<ul><li>记录日志、调试等额外操作，不改变对象本身</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = mutableListOf(1, 2, 3).also &#123;</span><br><span class="line">    println(&quot;原始列表: $it&quot;) // 输出：原始列表: [1, 2, 3]</span><br><span class="line">&#125;.apply &#123;</span><br><span class="line">    add(4)</span><br><span class="line">&#125;</span><br><span class="line">println(numbers) // 输出：[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br> <code>also</code> 用于执行副作用（如日志打印），返回原对象，而后续的 <code>apply</code> 则对对象进行修改。</p><hr><h3 id="1-5-with-用于非扩展对象的作用域调用"><a href="#1-5-with-用于非扩展对象的作用域调用" class="headerlink" title="1.5 with - 用于非扩展对象的作用域调用"></a>1.5 with - 用于非扩展对象的作用域调用</h3><ul><li><strong>返回值</strong>：Lambda 表达式的最后一行结果</li><li><strong>使用场景</strong>：<ul><li>对非扩展对象执行一系列操作，并返回计算结果</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val person = Person()</span><br><span class="line">val result = with(person) &#123;</span><br><span class="line">    name = &quot;Charlie&quot;</span><br><span class="line">    age = 30</span><br><span class="line">    &quot;名字: $name, 年龄: $age&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(result)  // 输出：名字: Charlie, 年龄: 30</span><br></pre></td></tr></table></figure><hr><h3 id="1-6-作用域函数对比总结"><a href="#1-6-作用域函数对比总结" class="headerlink" title="1.6 作用域函数对比总结"></a>1.6 作用域函数对比总结</h3><table><thead><tr><th>函数</th><th>使用场景</th><th>作用域内对象引用</th><th>返回值</th></tr></thead><tbody><tr><td><strong>apply</strong></td><td>修改对象本身</td><td><code>this</code></td><td>对象本身</td></tr><tr><td><strong>let</strong></td><td>针对可空对象或局部变量</td><td><code>it</code></td><td>Lambda 最后一行结果</td></tr><tr><td><strong>run</strong></td><td>执行操作并返回计算结果</td><td><code>this</code></td><td>Lambda 最后一行结果</td></tr><tr><td><strong>also</strong></td><td>执行额外操作（日志、调试等）</td><td><code>it</code></td><td>对象本身</td></tr><tr><td><strong>with</strong></td><td>对普通对象执行操作并返回结果</td><td><code>this</code></td><td>Lambda 最后一行结果</td></tr></tbody></table><p><strong>最佳实践提示：</strong></p><ul><li>修改对象并返回对象本身时，选择 <code>apply</code></li><li>针对可空对象操作时，选择 <code>let</code></li><li>需要返回计算结果时，选择 <code>run</code> 或 <code>with</code></li><li>仅执行副作用操作时，选择 <code>also</code></li></ul><hr><h2 id="2-时间输出"><a href="#2-时间输出" class="headerlink" title="2. 时间输出"></a>2. 时间输出</h2><p>下面的代码展示了如何在 Kotlin 中获取当前时间、格式化时间、解析字符串为日期，以及通过 Calendar 获取时间组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final</span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Calendar</span><br><span class="line">import java.util.Date</span><br><span class="line">import java.util.Locale</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    // 获取当前时间，并格式化为字符串</span><br><span class="line">    val date = Date() // 当前时间</span><br><span class="line">    val sdf = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())</span><br><span class="line">    val formattedDate = sdf.format(date)</span><br><span class="line">    println(formattedDate)  // 输出格式化日期，例如：2025-03-15 14:08:23</span><br><span class="line">    </span><br><span class="line">    // 将字符串解析为 Date 类型</span><br><span class="line">    val dateString = &quot;2025-03-09 14:45:30&quot;</span><br><span class="line">    val sdfp = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())</span><br><span class="line">    val datep = sdfp.parse(dateString)</span><br><span class="line">    println(datep)  // 输出: Sun Mar 09 14:45:30 GMT 2025</span><br><span class="line">    </span><br><span class="line">    // 使用 Calendar 获取当前时间的时、分、秒</span><br><span class="line">    val calendar = Calendar.getInstance()</span><br><span class="line">    val hour = calendar.get(Calendar.HOUR_OF_DAY)</span><br><span class="line">    val minute = calendar.get(Calendar.MINUTE)</span><br><span class="line">    val second = calendar.get(Calendar.SECOND)</span><br><span class="line">    println(&quot;当前时间: $hour:$minute:$second&quot;)</span><br><span class="line">    </span><br><span class="line">    // 格式化输出时间（24小时制）</span><br><span class="line">    val formattedTime = String.format(&quot;%02d:%02d:%02d&quot;, hour, minute, second)</span><br><span class="line">    println(&quot;当前时间: $formattedTime&quot;)</span><br><span class="line">    println(&quot;当前时间: $&#123;String.format(&quot;%02d:%02d:%02d&quot;, hour, minute, second)&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>使用 <code>SimpleDateFormat</code> 格式化和解析日期</li><li><code>Calendar</code> 用于提取当前时间的各个字段</li></ul><hr><h2 id="3-回调机制"><a href="#3-回调机制" class="headerlink" title="3. 回调机制"></a>3. 回调机制</h2><h3 id="3-1-什么是回调？"><a href="#3-1-什么是回调？" class="headerlink" title="3.1 什么是回调？"></a>3.1 什么是回调？</h3><p>回调类似于“任务完成后通知我”。例如，让朋友去买咖啡，买完后打电话告诉你。在编程中，回调指的是任务完成后自动调用的函数。</p><h3 id="3-2-示例：不使用回调（同步等待）"><a href="#3-2-示例：不使用回调（同步等待）" class="headerlink" title="3.2 示例：不使用回调（同步等待）"></a>3.2 示例：不使用回调（同步等待）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun buyGroceries() &#123;</span><br><span class="line">    Thread.sleep(2000) // 模拟买东西耗时2秒</span><br><span class="line">    println(&quot;买完了！&quot;) // 买完后通知</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;请帮我去买东西...&quot;)</span><br><span class="line">    buyGroceries()</span><br><span class="line">    println(&quot;我收到通知了&quot;) // 等待任务完成后执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：主线程会被阻塞，无法同时处理其他任务。</p><hr><h3 id="3-3-示例：使用回调（异步通知）"><a href="#3-3-示例：使用回调（异步通知）" class="headerlink" title="3.3 示例：使用回调（异步通知）"></a>3.3 示例：使用回调（异步通知）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun buyGroceries(callback: () -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        Thread.sleep(2000) // 模拟买东西耗时2秒</span><br><span class="line">        println(&quot;买完了！&quot;)</span><br><span class="line">        callback() // 任务完成后执行回调</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;请帮我去买东西...&quot;)</span><br><span class="line">    buyGroceries &#123;</span><br><span class="line">        println(&quot;我收到通知了！&quot;) // 任务完成后调用回调</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;我可以做别的事情，不用等&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br> 使用回调后，任务在后台执行，主线程可继续执行其他操作，待任务完成后自动调用回调函数。</p><hr><h3 id="3-4-回调在-Android-开发中的应用"><a href="#3-4-回调在-Android-开发中的应用" class="headerlink" title="3.4 回调在 Android 开发中的应用"></a>3.4 回调在 Android 开发中的应用</h3><ul><li><p><strong>按钮点击事件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    println(&quot;按钮被点击了！&quot;) // 按钮点击后的回调</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>网络请求：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun fetchData(callback: (String) -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        Thread.sleep(2000) // 模拟网络请求耗时</span><br><span class="line">        callback(&quot;数据加载成功了哈哈哈！&quot;)</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;开始请求数据...&quot;)</span><br><span class="line">    fetchData &#123; result -&gt;</span><br><span class="line">        println(result) // 数据返回后的回调</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;请求已经发送，我先做别的事情&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="4-Lambda-表达式"><a href="#4-Lambda-表达式" class="headerlink" title="4. Lambda 表达式"></a>4. Lambda 表达式</h2><h3 id="4-1-什么是-Lambda-表达式？"><a href="#4-1-什么是-Lambda-表达式？" class="headerlink" title="4.1 什么是 Lambda 表达式？"></a>4.1 什么是 Lambda 表达式？</h3><p>Lambda 表达式是匿名函数的一种写法，用于简化代码。其基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; 参数 -&gt; 表达式 &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-示例：基本用法"><a href="#4-2-示例：基本用法" class="headerlink" title="4.2 示例：基本用法"></a>4.2 示例：基本用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 Lambda 表达式，接受两个 Int 参数并返回它们的和</span><br><span class="line">val add: (Int, Int) -&gt; Int = &#123; a, b -&gt; a + b &#125;</span><br><span class="line">println(add(2, 3))  // 输出：5</span><br></pre></td></tr></table></figure><h3 id="4-3-Lambda-在高阶函数中的应用"><a href="#4-3-Lambda-在高阶函数中的应用" class="headerlink" title="4.3 Lambda 在高阶函数中的应用"></a>4.3 Lambda 在高阶函数中的应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个高阶函数，接受一个操作函数作为参数</span><br><span class="line">fun calculate(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;</span><br><span class="line">    return operation(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    // 使用尾随 Lambda 语法</span><br><span class="line">    val result = calculate(10, 5) &#123; x, y -&gt; x + y &#125;</span><br><span class="line">    println(result)  // 输出：15</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-单参数-Lambda-示例"><a href="#4-4-单参数-Lambda-示例" class="headerlink" title="4.4 单参数 Lambda 示例"></a>4.4 单参数 Lambda 示例</h3><p>当 Lambda 只有一个参数时，可以使用默认变量 <code>it</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val doubled = numbers.map &#123; it * 2 &#125;</span><br><span class="line">println(doubled)  // 输出：[2, 4, 6, 8]</span><br></pre></td></tr></table></figure><hr><h2 id="5-泛型与委托"><a href="#5-泛型与委托" class="headerlink" title="5. 泛型与委托"></a>5. 泛型与委托</h2><h3 id="5-1-泛型"><a href="#5-1-泛型" class="headerlink" title="5.1 泛型"></a>5.1 泛型</h3><p>泛型允许你编写适用于任意数据类型的通用代码，从而提高代码复用性和类型安全性。</p><h4 id="5-1-1-泛型类示例"><a href="#5-1-1-泛型类示例" class="headerlink" title="5.1.1 泛型类示例"></a>5.1.1 泛型类示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个泛型类 Box，可以存放任意类型的数据</span><br><span class="line">class Box&lt;T&gt;(var value: T)</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val intBox = Box(123)      // T 被推断为 Int</span><br><span class="line">    val strBox = Box(&quot;Hello&quot;)  // T 被推断为 String</span><br><span class="line">    println(intBox.value)      // 输出：123</span><br><span class="line">    println(strBox.value)      // 输出：Hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-泛型函数示例"><a href="#5-1-2-泛型函数示例" class="headerlink" title="5.1.2 泛型函数示例"></a>5.1.2 泛型函数示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个泛型函数，返回一个只包含一个元素的列表</span><br><span class="line">fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123;</span><br><span class="line">    return listOf(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val numbers = singletonList(42)      // T 被推断为 Int</span><br><span class="line">    val words = singletonList(&quot;Kotlin&quot;)    // T 被推断为 String</span><br><span class="line">    println(numbers) // 输出：[42]</span><br><span class="line">    println(words)   // 输出：[Kotlin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-3-类型参数的限定"><a href="#5-1-3-类型参数的限定" class="headerlink" title="5.1.3 类型参数的限定"></a>5.1.3 类型参数的限定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 泛型 T 限制为 Number 或其子类</span><br><span class="line">fun &lt;T : Number&gt; add(a: T, b: T): Double &#123;</span><br><span class="line">    return a.toDouble() + b.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(add(10, 20))      // 输出：30.0</span><br><span class="line">    // println(add(&quot;a&quot;, &quot;b&quot;)) // 错误，String 不是 Number 的子类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-4-协变与逆变"><a href="#5-1-4-协变与逆变" class="headerlink" title="5.1.4 协变与逆变"></a>5.1.4 协变与逆变</h4><h4 id="感觉不如书上P418讲得好"><a href="#感觉不如书上P418讲得好" class="headerlink" title="(感觉不如书上P418讲得好)"></a>(感觉不如书上P418讲得好)</h4><p><strong>1. 什么是协变和逆变？</strong></p><p>它们解决的是<strong>泛型的子类型关系</strong>，也就是<strong>泛型类 <code>A&lt;T&gt;</code> 和 <code>A&lt;U&gt;</code> 之间是否可以互相赋值</strong>。</p><p>先看普通的子类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑open class Parent</span><br><span class="line">class Child : Parent()</span><br><span class="line"></span><br><span class="line">val parent: Parent = Child() // ✅ 子类可以赋值给父类</span><br></pre></td></tr></table></figure><p>这个没问题，<code>Child</code> 是 <code>Parent</code> 的子类。但如果是<strong>泛型</strong>呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val childList: List&lt;Child&gt; = listOf(Child())</span><br><span class="line">// val parentList: List&lt;Parent&gt; = childList // ❌ 报错！</span><br></pre></td></tr></table></figure><p>Kotlin <strong>不允许</strong> <code>List&lt;Child&gt;</code> 赋值给 <code>List&lt;Parent&gt;</code>，因为泛型默认是**不变（Invariant）**的，即 <code>List&lt;Child&gt;</code> 和 <code>List&lt;Parent&gt;</code> 没有任何继承关系。</p><hr><h5 id="协变（Covariance）——-out-T"><a href="#协变（Covariance）——-out-T" class="headerlink" title="协变（Covariance）—— out T"></a><strong>协变（Covariance）—— <code>out T</code></strong></h5><p> <strong>让 <code>List&lt;Child&gt;</code> 赋值给 <code>List&lt;Parent&gt;</code></strong></p><p>如果我们想让 <code>List&lt;Child&gt;</code> 赋值给 <code>List&lt;Parent&gt;</code>，就要用<strong>协变</strong>（<code>out</code> 关键字）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> interface Producer&lt;out T&gt; &#123; // T 只能“生产”，不能“消费”</span><br><span class="line">    fun produce(): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val childProducer: Producer&lt;Child&gt; = object : Producer&lt;Child&gt; &#123;</span><br><span class="line">    override fun produce(): Child = Child()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 可以把 Producer&lt;Child&gt; 赋值给 Producer&lt;Parent&gt;</span><br><span class="line">val parentProducer: Producer&lt;Parent&gt; = childProducer</span><br></pre></td></tr></table></figure><p> <strong>为什么 <code>out</code> 只允许读取（生产）？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Producer&lt;out T&gt; &#123;</span><br><span class="line">    fun produce(): T // ✅ 只能提供 T</span><br><span class="line">    // fun consume(item: T) // ❌ 错误，不能接收 T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>out T</code> <strong>只能作为返回值（生产者）</strong>，不能作为参数（消费者）。</li><li>因为 <code>Producer&lt;Child&gt;</code> 赋值给 <code>Producer&lt;Parent&gt;</code> 后，如果允许 <code>consume(item: T)</code>，那就可能往 <code>Producer&lt;Child&gt;</code> 里面放 <code>Parent</code>，导致类型错误。</li></ul><p> <strong>示例：生产者</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Book</span><br><span class="line">class ScienceBook : Book()</span><br><span class="line"></span><br><span class="line">fun getScienceBooks(): List&lt;ScienceBook&gt; &#123;</span><br><span class="line">    return listOf(ScienceBook())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 使用 `out T` 让子类泛型可以赋值给父类泛型</span><br><span class="line">fun readBooks(books: List&lt;out Book&gt;) &#123;</span><br><span class="line">    for (book in books) &#123;</span><br><span class="line">        println(book)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val scienceBooks = getScienceBooks()</span><br><span class="line">readBooks(scienceBooks) // ✅ OK，因为 List&lt;ScienceBook&gt; 可以赋值给 List&lt;out Book&gt;</span><br></pre></td></tr></table></figure><p><strong>口诀：</strong></p><blockquote><p><strong>Producer Out（生产者用 <code>out</code>，只能读，不能写）</strong></p></blockquote><hr><h5 id="逆变（Contravariance）——-in-T"><a href="#逆变（Contravariance）——-in-T" class="headerlink" title="逆变（Contravariance）—— in T"></a><strong>逆变（Contravariance）—— <code>in T</code></strong></h5><p> <strong>让 <code>Consumer&lt;Parent&gt;</code> 赋值给 <code>Consumer&lt;Child&gt;</code></strong></p><p>如果我们想让 <code>Consumer&lt;Parent&gt;</code> 赋值给 <code>Consumer&lt;Child&gt;</code>，就要用<strong>逆变</strong>（<code>in</code> 关键字）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Consumer&lt;in T&gt; &#123; // T 只能“消费”，不能“生产”</span><br><span class="line">    fun consume(item: T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val parentConsumer: Consumer&lt;Parent&gt; = object : Consumer&lt;Parent&gt; &#123;</span><br><span class="line">    override fun consume(item: Parent) &#123;</span><br><span class="line">        println(&quot;Consumed a Parent&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 可以把 Consumer&lt;Parent&gt; 赋值给 Consumer&lt;Child&gt;</span><br><span class="line">val childConsumer: Consumer&lt;Child&gt; = parentConsumer</span><br></pre></td></tr></table></figure><p> <strong>为什么 <code>in</code> 只允许写入（消费）？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Consumer&lt;in T&gt; &#123;</span><br><span class="line">    fun consume(item: T) // ✅ 只能消费 T</span><br><span class="line">    // fun produce(): T // ❌ 错误，不能返回 T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>in T</code> <strong>只能作为参数（消费者）</strong>，不能作为返回值（生产者）。</li><li>因为 <code>Consumer&lt;Parent&gt;</code> 赋值给 <code>Consumer&lt;Child&gt;</code> 后，如果允许 <code>produce()</code>，就可能返回 <code>Parent</code>，但 <code>Consumer&lt;Child&gt;</code> 只能处理 <code>Child</code>，导致类型错误。</li></ul><p> <strong>示例：消费者</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">class Dog : Animal()</span><br><span class="line"></span><br><span class="line">fun trainDogs(trainers: MutableList&lt;in Dog&gt;) &#123;</span><br><span class="line">    trainers.add(Dog()) // ✅ 可以添加 Dog</span><br><span class="line">    // val dog: Dog = trainers[0] // ❌ 不能安全地读取</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val animals = mutableListOf&lt;Animal&gt;()</span><br><span class="line">trainDogs(animals) // ✅ OK，因为 `MutableList&lt;in Dog&gt;` 允许 `MutableList&lt;Animal&gt;` 作为参数</span><br></pre></td></tr></table></figure><p><strong>口诀：</strong></p><blockquote><p><strong>Consumer In（消费者用 <code>in</code>，只能写，不能读）</strong></p></blockquote><hr><h5 id="记住这两个原则"><a href="#记住这两个原则" class="headerlink" title="记住这两个原则"></a><strong>记住这两个原则</strong></h5><table><thead><tr><th>泛型类型</th><th>关键字</th><th>读取</th><th>写入</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>协变</strong></td><td><code>out T</code></td><td>✅ 允许</td><td>❌ 禁止</td><td><strong>生产者</strong>（只读）</td></tr><tr><td><strong>逆变</strong></td><td><code>in T</code></td><td>❌ 只能用 <code>Any?</code> 读取</td><td>✅ 允许</td><td><strong>消费者</strong>（只写）</td></tr></tbody></table><p> <strong>最简单的记忆口诀</strong></p><ul><li><strong>“生产者用 out”</strong>（Producer Out） → 只能读，不能写。</li><li><strong>“消费者用 in”</strong>（Consumer In） → 只能写，不能安全地读。</li></ul><hr><h5 id="生活中的例子"><a href="#生活中的例子" class="headerlink" title="生活中的例子"></a><strong>生活中的例子</strong></h5><p> <strong>🔵 协变（<code>out</code>）：只读，不写</strong></p><p>假设你去<strong>看书</strong> 📖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kotlin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">val books: List&lt;out Book&gt; = listOf(ScienceBook())</span><br></pre></td></tr></table></figure><ul><li>你可以<strong>拿起一本书来看</strong>（<code>val book: Book = books[0]</code> ✅）。</li><li>但你<strong>不能往书架上随便放书</strong>（<code>books.add(Book())</code> ❌），因为这可能是科学书架，只能放《科学书》。</li></ul><p> <strong>🔴 逆变（<code>in</code>）：只写，不读</strong></p><p>假设你有一个<strong>捐书箱</strong> 📦：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kotlin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">val donateBox: MutableList&lt;in ScienceBook&gt; = mutableListOf&lt;Book&gt;()</span><br></pre></td></tr></table></figure><ul><li>你可以<strong>往里面放一本科学书</strong>（<code>donateBox.add(ScienceBook())</code> ✅）。</li><li>但你<strong>取出来的书不一定是科学书</strong>（<code>val sb: ScienceBook = donateBox[0]</code> ❌），可能是一本普通书，甚至是一本字典 📚。</li></ul><hr><p> <strong>6. 协变逆变总结</strong></p><ol><li><strong><code>out</code>（协变） → 只读</strong><br> ✅ <code>List&lt;ScienceBook&gt;</code> 可以赋值给 <code>List&lt;out Book&gt;</code>，但不能 <code>add()</code>。</li><li><strong><code>in</code>（逆变） → 只写</strong><br> ✅ <code>MutableList&lt;Book&gt;</code> 可以赋值给 <code>MutableList&lt;in ScienceBook&gt;</code>，但不能安全 <code>get()</code>。</li><li><strong><code>in</code> + <code>out</code> 不能混用</strong>（同时 <code>in</code> 和 <code>out</code> 会报错）。</li></ol><h4 id="5-1-5-泛型实化（reified）"><a href="#5-1-5-泛型实化（reified）" class="headerlink" title="5.1.5 泛型实化（reified）"></a>5.1.5 泛型实化（reified）</h4><p>由于泛型在运行时会被擦除，使用 <code>reified</code> 可以保留类型信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 错误示例：无法在运行时获取 T 的类型信息</span><br><span class="line">fun &lt;T&gt; getType(): String &#123;</span><br><span class="line">    return T::class.java.name  // ❌</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确示例：使用 reified 保留类型信息</span><br><span class="line">inline fun &lt;reified T&gt; getType(): String &#123;</span><br><span class="line">    return T::class.java.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(getType&lt;String&gt;())  // 输出: java.lang.String</span><br><span class="line">    println(getType&lt;Int&gt;())     // 输出: int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-委托"><a href="#5-2-委托" class="headerlink" title="5.2 委托"></a>5.2 委托</h3><p>委托是一种设计模式，可以将部分工作交由其他对象来处理，使代码更简洁和灵活。</p><h4 id="5-2-1-属性委托"><a href="#5-2-1-属性委托" class="headerlink" title="5.2.1 属性委托"></a>5.2.1 属性委托</h4><p><strong>lazy 委托</strong>：延迟计算，首次访问时计算结果并缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 lazy 委托属性，只有首次访问时计算值</span><br><span class="line">val lazyValue: String by lazy &#123;</span><br><span class="line">    println(&quot;开始计算&quot;)</span><br><span class="line">    &quot;Hello, Kotlin&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;程序开始&quot;)</span><br><span class="line">    println(lazyValue) // 第一次调用时输出计算过程和结果</span><br><span class="line">    println(lazyValue) // 第二次调用时直接输出结果，无重复计算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>observable 委托</strong>：监听属性变化，每次属性改变时触发回调。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line">var name: String by Delegates.observable(&quot;初始值11&quot;) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">    println(&quot;属性 $&#123;property.name&#125; 从 $oldValue 变成了 $newValue&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    name = &quot;Kotlin22&quot;  // 输出：属性 name 从 初始值11 变成了 Kotlin22</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-类委托"><a href="#5-2-2-类委托" class="headerlink" title="5.2.2 类委托"></a>5.2.2 类委托</h4><p>通过类委托，可以将接口的实现任务交由其他类处理，避免重复实现相同的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个接口</span><br><span class="line">interface Printer &#123;</span><br><span class="line">    fun print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义接口实现类</span><br><span class="line">class PrinterImpl(val message: String) : Printer &#123;</span><br><span class="line">    override fun print() &#123;</span><br><span class="line">        println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类委托：DelegatingPrinter 将 Printer 接口的实现委托给传入的 printer 对象</span><br><span class="line">class DelegatingPrinter(printer: Printer) : Printer by printer</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val printerImpl = PrinterImpl(&quot;Hello from PrinterImpl&quot;)</span><br><span class="line">    val delegatingPrinter = DelegatingPrinter(printerImpl)</span><br><span class="line">    delegatingPrinter.print() // 实际调用 PrinterImpl 的 print() 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>作用域函数</strong>：通过 <code>apply</code>、<code>let</code>、<code>run</code>、<code>also</code> 和 <code>with</code> 简化对象操作，选择合适的函数可提高代码简洁性和可读性。</li><li><strong>时间输出</strong>：使用 <code>SimpleDateFormat</code> 和 <code>Calendar</code> 实现日期格式化、解析和时间组件获取。</li><li><strong>回调机制</strong>：回调可以在任务完成时通知你，避免阻塞主线程，常用于 UI 事件、网络请求等场景。</li><li><strong>Lambda 表达式</strong>：用于编写匿名函数，简化代码，尤其在高阶函数中应用广泛。</li><li><strong>泛型与委托</strong>：泛型提高代码通用性和类型安全；委托（属性委托和类委托）使代码更加简洁灵活，避免重复实现。</li></ul><h2 id="inline-函数是什么"><a href="#inline-函数是什么" class="headerlink" title="inline 函数是什么"></a>inline 函数是什么</h2><p>在 Kotlin 中，<strong>inline 函数</strong> 是一种优化手段，其核心思想是在编译期将函数体直接替换到调用处，从而避免函数调用的开销，特别适用于高阶函数（即接受 lambda 参数的函数）。</p><hr><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li><strong>目的</strong>：减少函数调用带来的性能开销，尤其在使用 lambda 表达式时，避免创建额外的对象。</li><li><strong>工作原理</strong>：编译器在编译时将 inline 函数的代码“内联”（inline）到调用该函数的位置，而不是在运行时调用。</li></ul><hr><h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h3><ul><li><strong>高阶函数</strong>：当函数接受 lambda 参数时，使用 inline 可以减少 lambda 对象的创建，提高性能。</li><li><strong>小型函数</strong>：适用于那些频繁调用的小函数，可以提高效率。</li><li><strong>泛型实化</strong>：与 <code>reified</code> 关键字结合使用，可以在运行时获取泛型参数的具体类型。</li></ul><hr><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><h4 id="3-1-基本示例"><a href="#3-1-基本示例" class="headerlink" title="3.1 基本示例"></a>3.1 基本示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 inline 函数</span><br><span class="line">inline fun performOperation(operation: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;操作开始&quot;)</span><br><span class="line">    operation()</span><br><span class="line">    println(&quot;操作结束&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    performOperation &#123;</span><br><span class="line">        println(&quot;执行具体操作&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：在编译时，<code>performOperation</code> 的代码会直接内联到调用处，从而减少了函数调用的额外开销。</p><hr><h4 id="3-2-与-reified-结合"><a href="#3-2-与-reified-结合" class="headerlink" title="3.2 与 reified 结合"></a>3.2 与 reified 结合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用 inline 和 reified 实现一个泛型函数，获取类型名称</span><br><span class="line">inline fun &lt;reified T&gt; getTypeName(): String &#123;</span><br><span class="line">    return T::class.java.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(getTypeName&lt;String&gt;()) // 输出: java.lang.String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>使用 <code>reified</code> 后，泛型参数在运行时不会被擦除，可以直接获取类型信息。</li><li><code>reified</code> 关键字必须和 <code>inline</code> 函数一起使用。</li></ul><hr><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul><li><strong>代码膨胀</strong>：由于 inline 函数会将函数体复制到每个调用处，如果函数体过大或者调用次数很多，可能会导致生成的字节码变大。</li><li><strong>适用限制</strong>：某些情况下（例如递归调用）不适合使用 inline 函数。</li></ul><hr><h3 id="inline函数总结"><a href="#inline函数总结" class="headerlink" title="inline函数总结"></a>inline函数总结</h3><p>inline 函数主要用于优化高阶函数，通过在编译期内联函数体来减少运行时的函数调用开销。同时，它可以与 <code>reified</code> 结合使用，以在运行时保留泛型类型信息。虽然 inline 函数能够提高性能，但在使用时也需注意避免代码膨胀问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2025/02/24/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/02/24/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h1><p>使用#</p><h1 id="二-字体"><a href="#二-字体" class="headerlink" title="二.字体"></a>二.字体</h1><h2 id="1-粗体"><a href="#1-粗体" class="headerlink" title="1.粗体"></a>1.粗体</h2><p>两个*</p><p><strong>M</strong></p><p><strong>M</strong></p><h2 id="2-斜体"><a href="#2-斜体" class="headerlink" title="2.斜体"></a>2.斜体</h2><p>一个*</p><p><em>M</em></p><p><em>M</em></p><h2 id="3-粗体加斜体"><a href="#3-粗体加斜体" class="headerlink" title="3.粗体加斜体"></a>3.粗体加斜体</h2><p>三个*</p><p><em><strong>M</strong></em></p><p><em><strong>M</strong></em></p><h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h2><p>使用两个波浪线</p><p><del>M</del></p><p><del>M</del></p><h1 id="三-引用"><a href="#三-引用" class="headerlink" title="三.引用"></a>三.引用</h1><p>使用大于号</p><blockquote><p>M</p></blockquote><blockquote><p>M</p></blockquote><h1 id="四-分割线"><a href="#四-分割线" class="headerlink" title="四.分割线"></a>四.分割线</h1><p>三个*或者三个-</p><h1 id="五-图片"><a href="#五-图片" class="headerlink" title="五.图片"></a>五.图片</h1><p>!+[]+()，其中[]内填写名字，()内填写图片地址</p><p><img src="/"></p><h1 id="六-超链接"><a href="#六-超链接" class="headerlink" title="六.超链接"></a>六.超链接</h1><p>[]+()，其中[]内填写名字，()内填写网址</p><p><a href="www.baidu.com">hh</a></p><h1 id="七-列表"><a href="#七-列表" class="headerlink" title="七.列表"></a>七.列表</h1><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>数字加”.”,再加空格，即生成有序列表</p><ol><li>A</li><li>B</li></ol><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>-加空格</p><ul><li>1</li><li>2</li></ul><h1 id="八-表格"><a href="#八-表格" class="headerlink" title="八.表格"></a>八.表格</h1><p>1.右键，选择插入，选择表格</p><p>2.Ctrl+T</p><p>3.原始人模式</p><p>先写好格式如下</p><p>X|Y|Z</p><p>–|–|–</p><p>1|2|3</p><p>然后点击左下角图案&lt;&#x2F;&gt;，开启源代码模式，把各行之间的空行删除，即可生成表格。</p><h1 id="九-插入代码块"><a href="#九-插入代码块" class="headerlink" title="九.插入代码块"></a>九.插入代码块</h1><p>使用三个&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据库</title>
      <link href="/2025/02/24/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2025/02/24/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>进度1:32:06</p><h1 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一.数据类型"></a>一.数据类型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INT                    --整数</span><br><span class="line">DECIMAL(3,2)   --有小数点的数</span><br><span class="line">VARCHAR(10)            --字串</span><br><span class="line">BLOB                   --(Binary Large Object) 图片 影片 档案...</span><br><span class="line">DATA                   --&#x27;YYYY-MM-DD&#x27; 日期</span><br><span class="line">TIMESTAMP              --&#x27;YYYY-MM-DD HH:MM:SS&#x27; 记录时间</span><br></pre></td></tr></table></figure><h1 id="二-简单例子"><a href="#二-简单例子" class="headerlink" title="二.简单例子"></a>二.简单例子</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> dATABASE `sql_tutorial`;</span><br><span class="line"><span class="keyword">SHOW</span> DAtABaSES;</span><br><span class="line">USE `sql_tutorial`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `student`(</span><br><span class="line">`student_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> auto_increment,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> ,  <span class="comment">-- 这是一个注释，记得是减减加空格</span></span><br><span class="line">`major` <span class="type">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">default</span> <span class="string">&#x27;历史&#x27;</span>,</span><br><span class="line">`score` <span class="type">INT</span> <span class="keyword">default</span> <span class="number">100</span> <span class="comment">-- 最后一个属性不用加逗号</span></span><br><span class="line">);      <span class="comment">/*最后有;相当于一句话的结束？*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dESCriBe</span> `student`;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">TABLE</span> `student`;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">ADD</span> gpa <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.00</span>; <span class="comment">-- 新增属性</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> gpa; <span class="comment">-- 删除属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `student`;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;历史&#x27;</span>,<span class="number">100</span>); <span class="comment">-- 插入数据，注意是用单引号’而不是`</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;小绿&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`major`,`student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小蓝&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="number">4</span>); </span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`major`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="keyword">NULL</span>); <span class="comment">-- 不写id是因为auto_increment自动生成id</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `student` <span class="keyword">WHERE</span> `student_id` <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">-- 删除id为4的那一行</span></span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES<span class="operator">=</span><span class="number">0</span> ;<span class="comment">-- 用于关闭安全更新模式，允许你执行 UPDATE 或 DELETE 语句，即使没有 WHERE 条件或没有主键索引。</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` </span><br><span class="line"><span class="keyword">SET</span> `major` <span class="operator">=</span><span class="string">&#x27;英语文学&#x27;</span> <span class="comment">-- 不是行列名等，要使用&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> `major` <span class="operator">=</span><span class="string">&#x27;英语&#x27;</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;小1&#x27;</span> <span class="keyword">WHERE</span> `name`<span class="operator">=</span><span class="string">&#x27;小绿&#x27;</span> <span class="keyword">or</span> `name`<span class="operator">=</span> <span class="string">&#x27;小白&#x27;</span>;  <span class="comment">-- 更新表格</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;小灰&#x27;</span>,`major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span> <span class="keyword">WHERE</span> `student_id`<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `name`<span class="operator">=</span><span class="string">&#x27;小灰&#x27;</span> <span class="keyword">and</span> `major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span>; <span class="comment">-- where用and连接</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `score`<span class="operator">&lt;</span><span class="number">60</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` ;<span class="comment">-- 把student内数据全部删除</span></span><br><span class="line"><span class="comment">-- 取得资料</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student`;</span><br><span class="line"><span class="keyword">Select</span> `name` <span class="keyword">from</span> `student` ;</span><br><span class="line"><span class="keyword">select</span> `name` , `major` <span class="keyword">from</span> `student`; <span class="comment">-- 中间用,而不是and</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score` ; <span class="comment">-- 从低到高，或者在order by后面加上ASC</span></span><br><span class="line"><span class="keyword">selecT</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score` <span class="keyword">DESC</span>;<span class="comment">-- 从高到低</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score`<span class="keyword">DESC</span>,`student_id`  Limit <span class="number">3</span>; <span class="comment">-- 先根据score降序排序，若是score一样，则按student_id升序排序，只返回前三个</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `major`<span class="operator">=</span><span class="string">&#x27;英语&#x27;</span> <span class="keyword">and</span> `student_id`<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- where用and连接</span></span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>1.<em><strong>注释</strong></em>有– 和&#x2F;**&#x2F;两种–后面要跟空格</p><p>2.一个引号是一句，比如虽然CREATE TABLE <code>student</code> 有那么多行，其实只有一句，所以cursor指向容易一行就可以执行整个语句</p><p>3.闪电只会闪电一句话，比如你没有执行USE sql_tutorial 这一句话，去执行dESCriBe <code>student</code>;就会报错，记住<em><strong>一定要先执行USE sql_tutorial这句话</strong></em></p><p>4.关键字的大小写是无所谓的，但建议关键字全用大写，上面例子只是为了体现大小写任意的特征，实际上一个全部大写，自己定义的字建议使用&#96;&#96;包括起来，并使用小写</p><p>5.&gt;大于   &lt;小于   &gt;&#x3D;大于等于   &#x3D;等于    &lt;&gt;不等于</p><p>6.where用and，or连接？</p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用AS的准备</title>
      <link href="/2025/02/16/%E4%BD%BF%E7%94%A8AS%E7%9A%84%E5%87%86%E5%A4%87/"/>
      <url>/2025/02/16/%E4%BD%BF%E7%94%A8AS%E7%9A%84%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="1-viewbinding"><a href="#1-viewbinding" class="headerlink" title="1.viewbinding"></a>1.viewbinding</h1><p>build.gradle.kts中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">...</span><br><span class="line">buildFeatures &#123;</span><br><span class="line">    viewBinding = true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-compileSdk"><a href="#2-compileSdk" class="headerlink" title="2.compileSdk"></a>2.compileSdk</h1><p>build.gradle.kts中compileSdk&#x3D;34改成compileSdk&#x3D;35</p><h1 id="3-dependencies"><a href="#3-dependencies" class="headerlink" title="3.dependencies"></a>3.dependencies</h1><p>在dependencies中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">implementation(&quot;androidx.fragment:fragment:1.6.2&quot;)</span><br><span class="line">   implementation(&quot;com.squareup.okhttp3:okhttp:4.10.0&quot;)</span><br><span class="line">   implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)</span><br><span class="line">   implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)</span><br><span class="line">   implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)</span><br><span class="line">   implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1&quot;)</span><br><span class="line">   implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&quot;)</span><br><span class="line">   implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.4.0&quot;)</span><br><span class="line">   implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)</span><br><span class="line">   implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0&quot;)</span><br><span class="line">   implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)</span><br><span class="line">   kapt(&quot;androidx.room:room-compiler:2.6.1&quot;)</span><br><span class="line">   implementation(&quot;androidx.work:work-runtime:2.10.0&quot;)</span><br><span class="line">   implementation(&quot;com.github.bumptech.glide:glide:4.15.1&quot;)</span><br><span class="line">   implementation (&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.3.1&quot;)</span><br><span class="line">   implementation (&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1&quot;)</span><br><span class="line">   implementation (&quot;com.github.bumptech.glide:glide:4.13.0&quot;)</span><br><span class="line">   annotationProcessor (&quot;com.github.bumptech.glide:compiler:4.13.0&quot;)</span><br><span class="line">   implementation(&quot;androidx.room:room-runtime:2.5.2&quot;)</span><br><span class="line">   kapt(&quot;androidx.room:room-compiler:2.5.2&quot;)</span><br><span class="line">   implementation(&quot;androidx.room:room-ktx:2.5.2&quot;)</span><br></pre></td></tr></table></figure><p>解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">implementation(&quot;androidx.fragment:fragment-ktx:1.6.2&quot;)</span><br><span class="line">implementation(&quot;com.squareup.okhttp3:okhttp:4.10.0&quot;)//引用OkHttp库</span><br><span class="line">implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)//使用gson</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)//使用Retrofit,会自动将Retrofit、OkHttp、和Okio这几个库一起下载，不用再手动引入OkHttp库。</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)//使用Retrofit，这是一个Retrofit的转换库，它是借助GSON来解析JSON数据的，所以会自动将GSON库下载下来，所以不用手动引入GSON库了</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1&quot;)//协程</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&quot;)//协程</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.4.0&quot;)//使用ViewModel组件</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)//使用ViewModel、livedata组件</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0&quot;)//使用ViewModel组件</span><br><span class="line">implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)//room</span><br><span class="line">kapt(&quot;androidx.room:room-compiler:2.6.1&quot;)//room</span><br><span class="line">implementation(&quot;androidx.work:work-runtime:2.10.0&quot;)//WorkManager</span><br><span class="line">implementation(&quot;com.github.bumptech.glide:glide:4.15.1&quot;)/*Glide,另外，Glide中需要用到网络功能，因此你还得在AndroidManifest.xml中声明一下网络权限才行：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-plugins"><a href="#4-plugins" class="headerlink" title="4.plugins"></a>4.plugins</h1><p>添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(&quot;kotlin-kapt&quot;)</span><br></pre></td></tr></table></figure><p>解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(&quot;kotlin-kapt&quot;)//为了dependencies中能使用kapt(&quot;...&quot;)这样的语法</span><br></pre></td></tr></table></figure><h1 id="5-binding"><a href="#5-binding" class="headerlink" title="5.binding"></a>5.binding</h1><p>改用binding.root</p><h1 id="6-声明网络权限"><a href="#6-声明网络权限" class="headerlink" title="6.声明网络权限"></a>6.声明网络权限</h1><p>在AndroidManifest.xml开头添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如下面例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><h1 id="7-使用HTTP"><a href="#7-使用HTTP" class="headerlink" title="7.使用HTTP"></a>7.使用HTTP</h1><p>在res-&gt;xml文件夹下，新建network_config.xml文件，然后修改文件中内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">    &lt;base-config cleartextTrafficPermitted=&quot;true&quot;&gt;</span><br><span class="line">        &lt;trust-anchors&gt;</span><br><span class="line">            &lt;certificates src=&quot;system&quot;/&gt;</span><br><span class="line">        &lt;/trust-anchors&gt;</span><br><span class="line">    &lt;/base-config&gt;</span><br><span class="line">&lt;/network-security-config&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段配置文件的意思是允许我们以明文的方式在网络上传输数据，而HTTP使用的就是明文传输方式。</p><p>接下来修改AndroidManifest.xml中的代码来启用我们刚才创建的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        android:allowBackup=&quot;true&quot;</span><br><span class="line">        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;</span><br><span class="line">        android:fullBackupContent=&quot;@xml/backup_rules&quot;</span><br><span class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;</span><br><span class="line">        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:supportsRtl=&quot;true&quot;</span><br><span class="line">        android:theme=&quot;@style/Theme.NetworkTest&quot;</span><br><span class="line">        tools:targetApi=&quot;31&quot;</span><br><span class="line">        android:networkSecurityConfig=&quot;@xml/network_config&quot;//就是添加这一行哦</span><br><span class="line">        &gt;</span><br></pre></td></tr></table></figure><h1 id="AndroidManifest-xml的权限声明"><a href="#AndroidManifest-xml的权限声明" class="headerlink" title="AndroidManifest.xml的权限声明"></a>AndroidManifest.xml的权限声明</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; </span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;</span><br><span class="line">&lt;!-- 普通前台服务权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot;/&gt;</span><br><span class="line">&lt;!-- MediaPlayback 类型的前台服务需要额外的权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK&quot;/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task-4</title>
      <link href="/2025/02/10/Task-4/"/>
      <url>/2025/02/10/Task-4/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第四讲"><a href="#寒假第四讲" class="headerlink" title="寒假第四讲"></a>寒假第四讲</h1><h2 id="一-有理数取余"><a href="#一-有理数取余" class="headerlink" title="一.有理数取余"></a>一.有理数取余</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该问题要求计算有理数 c&#x3D;ab<em>c</em>&#x3D;<em>b**a</em> 对19260817取模的值。根据模运算的性质，这相当于求解方程 bx≡amod  19260817<em>b**x</em>≡<em>a</em>mod19260817。解的存在性取决于 b<em>b</em> 是否存在模19260817的逆元。具体步骤如下：</p><ol><li><strong>大数取模</strong>：由于输入的 a<em>a</em> 和 b<em>b</em> 可能非常大（最多10001位），需要将这两个数转换为模19260817后的值。这可以通过逐位处理字符串并取模来实现。</li><li><strong>判断逆元存在性</strong>：若 b<em>b</em> 模19260817的结果为0，则方程无解，直接输出“Angry!”。否则，利用费马小定理计算 b<em>b</em> 的逆元，因为19260817是质数。</li><li><strong>计算最终结果</strong>：将 a<em>a</em> 的模值与逆元相乘后再次取模，得到最终结果。</li></ol><h3 id="2-对应代码"><a href="#2-对应代码" class="headerlink" title="2.对应代码"></a>2.对应代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MOD = 19260817;</span><br><span class="line"></span><br><span class="line">int mod(const string&amp; s, int m) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (char c : s) &#123;</span><br><span class="line">        res = (res * 10LL + (c - &#x27;0&#x27;)) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long pow_mod(long long a, long long b, int mod) &#123;</span><br><span class="line">    long long res = 1;</span><br><span class="line">    a %= mod;</span><br><span class="line">    while (b &gt; 0) &#123;</span><br><span class="line">        if (b % 2 == 1) res = (res * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string a_str, b_str;</span><br><span class="line">    cin &gt;&gt; a_str &gt;&gt; b_str;</span><br><span class="line"></span><br><span class="line">    int a_mod = mod(a_str, MOD);</span><br><span class="line">    int b_mod = mod(b_str, MOD);</span><br><span class="line"></span><br><span class="line">    if (b_mod == 0) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Angry!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        long long inv_b = pow_mod(b_mod, MOD - 2, MOD);</span><br><span class="line">        long long ans = (a_mod * inv_b) % MOD;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li><strong>大数取模技巧</strong>：处理超大数时，可以通过逐位取模的方式避免数值溢出。例如，将字符串的每一位依次转换为当前结果的10倍加上该位数字，然后立即取模。</li><li><strong>逆元计算</strong>：当模数为质数时，可以利用费马小定理快速计算逆元（即 ap−2mod  p<em>a**p</em>−2mod<em>p</em>），时间复杂度为 O(log⁡p)<em>O</em>(log<em>p</em>)。</li><li><strong>输入处理</strong>：注意输入的数值范围，使用字符串处理大数，并确保处理过程中不会溢出。</li><li><strong>边界条件</strong>：题目保证输入的 a<em>a</em> 和 b<em>b</em> 不同时是模数的倍数，因此当 b<em>b</em> 的模为0时，直接判定无解。</li></ol><p>该问题结合了数论中的模运算和逆元知识，同时考察了处理大数的技巧，综合应用了多种算法和编程技术。</p><h2 id="二-Minimal-Coprime"><a href="#二-Minimal-Coprime" class="headerlink" title="二.Minimal Coprime"></a>二.Minimal Coprime</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>对于每一个测试用例，我们需要找出区间 [l, r] 内所有的最小互质区间。由于我们要判断区间是否是最小互质，实际操作时可以考虑以下几点：</p><ol><li>如果 l &#x3D;&#x3D; r，那么只有一个单一的数，需要检查该数是否与自身互质，显然，对于任意数 a，<code>gcd(a, a) ≠ 1</code>，因此这类区间无法构成互质区间。</li><li>如果 l !&#x3D; r，则要判断区间 [l, r] 内每一个单元素子区间是否互质，同时对于更大的区间是否是最小互质区间。</li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">const int N = 1e6 + 10,mod = 19260817,INT = 1e17,M = 5e6;</span><br><span class="line"> </span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"> </span><br><span class="line">int qmi(int a,int k)&#123;</span><br><span class="line">int res = 1;</span><br><span class="line">while(k)&#123;</span><br><span class="line">if(k&amp;1) res = res * a % mod;</span><br><span class="line">a = a * a % mod; </span><br><span class="line">k &gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void slove()&#123;</span><br><span class="line">string a,b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">int na = 0,nb = 0;</span><br><span class="line">for(auto c:a)&#123;</span><br><span class="line">na = (na * 10 + c - &#x27;0&#x27;) % mod;</span><br><span class="line">&#125;</span><br><span class="line">for(auto c:b) nb = (nb * 10 + c - &#x27;0&#x27;) % mod;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; na * qmi(nb,mod - 2) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);cin.tie(nullptr);</span><br><span class="line">int T = 1;</span><br><span class="line">while(T--) slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>最大公约数 (gcd)</strong>：在这道题中，我们频繁使用 <code>gcd</code> 来判断两个数是否互质。通过辗转相除法，可以有效地求出两个数的最大公约数，进而判断它们是否互质。</p><p><strong>区间内互质判断</strong>：对于每一个子区间，需要检查它们是否互质，并且判断是否包含更小的互质子区间。这要求我们在求解时要小心处理每个区间，避免遗漏。</p><p><strong>最小互质区间的判定</strong>：最小互质区间需要满足不包含任何其他互质区间，这一点是解题的关键。通过遍历区间的所有子区间，并确保它们不含更小的互质区间，可以确保找到所有最小互质区间。</p><p><strong>优化</strong>：虽然本解法直接暴力枚举所有区间，但考虑到题目中区间范围较大，应该在实际使用中进行一些优化，如剪枝等策略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task 3</title>
      <link href="/2025/02/06/Task-3/"/>
      <url>/2025/02/06/Task-3/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第三讲"><a href="#寒假第三讲" class="headerlink" title="寒假第三讲"></a>寒假第三讲</h1><h2 id="一-priority-queue"><a href="#一-priority-queue" class="headerlink" title="一.priority queue"></a>一.priority queue</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求实现一个优先队列，支持插入操作 <code>insert(k)</code> 和提取最大元素操作 <code>extractMax</code>。在 C++ 中，我们可以使用 <code>priority_queue</code> 来实现这一结构。<code>priority_queue</code> 默认是最大堆，插入操作将元素添加到堆中，而提取操作返回并删除堆顶的元素。</p><p>首先，输入包含多个操作，每个操作可能是 <code>insert k</code>（插入整数 k）、<code>extract</code>（提取最大元素）或 <code>end</code>（结束输入）。对于每个 <code>insert k</code> 操作，我们将元素插入到优先队列中。对于每个 <code>extract</code> 操作，我们从堆中提取并输出当前最大值。</p><p>C++ 的 <code>priority_queue</code> 数据结构默认按降序排列（即最大堆），因此无需额外处理即可满足题目要求。程序通过循环读取操作，针对 <code>insert</code> 进行堆插入，针对 <code>extract</code> 进行堆顶元素提取并输出，直到遇到 <code>end</code> 操作停止。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Compare &#123;</span><br><span class="line">    bool operator()(int a, int b) &#123;</span><br><span class="line">        return a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, Compare&gt; pq; </span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    while (getline(cin, line)) &#123;</span><br><span class="line">        if (line.empty()) continue;</span><br><span class="line"></span><br><span class="line">        stringstream ss(line);</span><br><span class="line">        string command;</span><br><span class="line">        ss &gt;&gt; command;</span><br><span class="line"></span><br><span class="line">        if (command == &quot;insert&quot;) &#123;</span><br><span class="line">            int k;</span><br><span class="line">            ss &gt;&gt; k;</span><br><span class="line">            pq.push(k);</span><br><span class="line">        &#125; else if (command == &quot;extract&quot;) &#123;</span><br><span class="line">            if (!pq.empty()) &#123;</span><br><span class="line">                cout &lt;&lt; pq.top() &lt;&lt; endl; </span><br><span class="line">                pq.pop(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (command == &quot;end&quot;) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>通过实现这个优先队列，了解了 C++ 中 <code>priority_queue</code> 的基本使用方法。<code>priority_queue</code> 使用最大堆结构，自动保证每次提取的都是当前最大元素，因此插入和提取操作的时间复杂度为 <code>O(log n)</code>，非常高效。此外，使用 <code>priority_queue</code> 还可以避免手动维护堆结构，从而减少了程序复杂度。通过输入和输出流的处理，我也更深入地理解了如何高效处理大规模数据输入。特别是对于题目中限制的 200 万次操作，我们需要确保程序的输入输出效率，因此应该尽量减少不必要的操作，使用合适的输入输出方法提高程序性能。</p><h2 id="ST表-RMQ问题"><a href="#ST表-RMQ问题" class="headerlink" title="ST表&amp;&amp;RMQ问题"></a>ST表&amp;&amp;RMQ问题</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该程序利用 ST 表进行静态区间最大值查询。首先，使用 <code>preprocess</code> 函数构建 ST 表，预处理时间复杂度为 O(N log N)。<br>对于每个查询，我们利用对数表 <code>log_table</code> 预计算查询范围的最优分块，使得查询复杂度降为 O(1)。<br>通过 <code>read()</code> 进行高效输入，减少 IO 时间，适用于大数据量场景。</p><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 100000;</span><br><span class="line">const int LOG = 17;</span><br><span class="line">int st[MAX_N][LOG];</span><br><span class="line">int log_table[MAX_N + 1];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;) f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preprocess(const vector&lt;int&gt;&amp; arr, int n) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        st[i][0] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">        for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i++) &#123;</span><br><span class="line">            st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log_table[1] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        log_table[i] = log_table[i / 2] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int l, int r) &#123;</span><br><span class="line">    int j = log_table[r - l + 1];</span><br><span class="line">    return max(st[l][j], st[r - (1 &lt;&lt; j) + 1][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = read(), m = read();</span><br><span class="line">    vector&lt;int&gt; arr(n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line">    preprocess(arr, n);</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int l = read() - 1, r = read() - 1;</span><br><span class="line">        printf(&quot;%d\n&quot;, query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>ST 表适用于静态查询，预处理代价较高，但查询极快。</li><li>利用 <code>log_table</code> 预计算对数值可以减少 <code>log</code> 函数调用，提高查询效率。</li><li>快速输入 <code>read()</code> 可有效减少时间开销，适用于高强度数据。</li><li>ST 表的核心思想是利用区间的重叠性，通过 <code>dp</code> 方式高效存储区间信息</li></ol><h2 id="合并果子"><a href="#合并果子" class="headerlink" title="合并果子"></a>合并果子</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题可以通过哈夫曼树（Huffman Tree）的思想来解决，使用最小堆（优先队列）进行贪心合并。<br>每次取出当前最小的两堆果子进行合并，合并的代价是两者之和，并将新堆重新加入优先队列。<br>这个过程持续 n-1 次，最终优先队列中只剩下一堆，累加所有合并的代价，即为最小的体力耗费。<br>由于使用了最小堆，每次插入与删除的复杂度是 O(log n)，整体复杂度为 O(n log n)。</p><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;) f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = read();</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        pq.push(read());</span><br><span class="line">    &#125;</span><br><span class="line">    int total_cost = 0;</span><br><span class="line">    while (pq.size() &gt; 1) &#123;</span><br><span class="line">        int a = pq.top(); pq.pop();</span><br><span class="line">        int b = pq.top(); pq.pop();</span><br><span class="line">        int cost = a + b;</span><br><span class="line">        total_cost += cost;</span><br><span class="line">        pq.push(cost);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, total_cost);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>本题是典型的贪心算法应用，通过局部最优（每次合并最小的两堆）达到全局最优。</li><li>最小堆（优先队列）是一种有效的数据结构，适用于处理动态集合中的最小值问题。</li><li>哈夫曼树的构造与本题类似，它用于最优前缀编码问题，具有广泛应用。</li><li>由于 n 最大为 10000，使用 O(n log n) 复杂度的方法是合理可行的，若用 O(n^2) 的方法会超时。</li><li>通过 <code>priority_queue</code> 的 <code>greater&lt;int&gt;</code> 实现最小堆，提高代码可读性和效率。</li></ol><h2 id="四-约瑟夫问题"><a href="#四-约瑟夫问题" class="headerlink" title="四.约瑟夫问题"></a>四.约瑟夫问题</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该题是经典的约瑟夫环问题。我们通过模拟报数过程来解决，使用双端队列（<code>deque</code>）来模拟每次出圈的操作。首先将所有人的编号依次加入队列，每次将前 mmm 个人报数，第 mmm 个人出列，再从下一个人开始继续报数。该过程重复直到所有人都出列。通过队列的 <code>push_back</code> 和 <code>pop_front</code> 操作来模拟循环报数，保证每个出圈人的编号按顺序输出。</p><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    deque&lt;int&gt; people;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        people.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    while (!people.empty()) &#123;</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            people.push_back(people.front());</span><br><span class="line">            people.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        cout &lt;&lt; people.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">        people.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h3><p><strong>约瑟夫环问题</strong>：是经典的动态结构问题，使用队列模拟能够有效解决。</p><p><strong>队列操作</strong>：队列的 <code>push_back</code> 和 <code>pop_front</code> 操作时间复杂度为 O(1)，适合进行循环模拟。</p><p><strong>循环过程理解</strong>：通过理解每次从队列中移除第 mmm 个人，并将下一个人重新从头开始报数，可以轻松解决问题。</p><p><strong>时间复杂度</strong>：对于 n 和 m 较小的情况，O(n * m) 的时间复杂度是可行的。</p><p><strong>应用范围</strong>：这种方法适用于类似的循环排列问题，理解其实现方式对于解决其他类似问题非常有帮助。</p><h2 id="五-Look-Up-S"><a href="#五-Look-Up-S" class="headerlink" title="五.Look Up S"></a>五.Look Up S</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题的核心在于查找每个奶牛的右侧第一个比她高的奶牛。通过使用栈（stack）数据结构，可以高效地维护一个递减的序列。每次遇到一个奶牛时，将其与栈顶的奶牛进行比较，如果栈顶奶牛的身高不大于当前奶牛，就将其弹出，直到栈顶奶牛的身高大于当前奶牛或栈为空。此时栈顶元素即为当前奶牛的仰望对象。</p><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1e5 + 5;</span><br><span class="line">int h[MAXN];</span><br><span class="line">int ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; stk;</span><br><span class="line">    for (int i = n; i &gt;= 1; --i) &#123;</span><br><span class="line">        while (!stk.empty() &amp;&amp; h[stk.back()] &lt;= h[i]) &#123;</span><br><span class="line">            stk.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = stk.empty() ? 0 : stk.back();</span><br><span class="line">        stk.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>栈的应用</strong>：本题运用了栈来解决查找“右侧第一个更大元素”的问题。栈非常适合解决递增&#x2F;递减问题，能够避免不必要的重复计算。</p><p><strong>时间复杂度优化</strong>：通过栈的方式，每个奶牛的身高最多入栈和出栈一次，整体时间复杂度为 O(N)，满足大规模数据的需求。</p><p><strong>贪心策略</strong>：栈的使用体现了贪心策略，通过逐步找出最优解。每次都保证栈中的奶牛按递减顺序排列，能快速找到每个奶牛的第一个仰望对象。</p><p><strong>解决类似问题</strong>：掌握栈的应用可以解决许多类似的“寻找下一个更大&#x2F;小元素”类型的问题。</p><h2 id="五-国旗计划"><a href="#五-国旗计划" class="headerlink" title="五.国旗计划"></a>五.国旗计划</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p><strong>区间转化</strong>：</p><ul><li>每个边防战士常驻两个边防站 <code>C_i</code> 和 <code>D_i</code>，其奔袭区间为从 <code>C_i</code> 到 <code>D_i</code>。如果 <code>C_i &gt; D_i</code>，说明该区间跨越了边境，需要加上边境的总长度 <code>M</code>，这样就能确保所有区间都是线性区间，方便后续处理。</li></ul><p><strong>排序</strong>：</p><ul><li>由于区间覆盖问题通常需要按顺序处理，所有边防战士的奔袭区间按照左端点 <code>l</code> 排序。排序后的数组使得我们可以方便地逐一处理每个边防战士，并计算出最少需要多少战士来覆盖边境。</li></ul><p><strong>动态规划和跳跃法</strong>：</p><ul><li>采用动态规划来解决每个边防战士覆盖的最远区间问题。通过二分查找，找到每个战士能覆盖的最远位置，记录在二维数组 <code>go</code> 中。<code>go[i][0]</code> 存储战士 <code>i</code> 覆盖区间的最远战士 <code>k</code> 的下标。为了更高效地查询最大覆盖，代码通过多级跳跃的方式，构建了 <code>go</code> 数组，并通过动态规划实现快速查询。</li></ul><p><strong>查询最小战士数量</strong>：</p><ul><li>在查询每个战士必须参与的前提下，我们从该战士的起始位置开始，依次找到能够覆盖区间的最远战士，通过二分查找的方式迭代跳跃，最后计算出最少需要的战士数量。</li></ul><p><strong>输出结果</strong>：</p><ul><li>对于每个战士，输出必须参与的前提下，最少需要多少个战士来覆盖整个边境线。</li></ul></li></ol><h3 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, res[200005];</span><br><span class="line">struct soldier &#123;</span><br><span class="line">int id, l, r;</span><br><span class="line">&#125; s[400005];</span><br><span class="line">int cmp(soldier a, soldier b)</span><br><span class="line">&#123;</span><br><span class="line">return a.l &lt; b.l; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int go[400005][20];</span><br><span class="line"></span><br><span class="line">void pre()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1, p = i; i &lt;= 2 * n; i++) &#123;</span><br><span class="line">while(p &lt;= 2 * n &amp;&amp; s[p].l &lt;= s[i].r)</span><br><span class="line">p++;</span><br><span class="line">int pos = p - 1;</span><br><span class="line">go[i][0] = pos;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">for(int j = 1; j &lt;= 2 * n; j++) &#123;</span><br><span class="line">go[j][i] = go[go[j][i - 1]][i - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void search(int k)</span><br><span class="line">&#123;</span><br><span class="line">int lmt = s[k].l + m, ans = 1, p = k;</span><br><span class="line">for(int i = 19; i &gt;= 0; i--) &#123;</span><br><span class="line">if(go[k][i] != 0 &amp;&amp; s[go[k][i]].r &lt; lmt) &#123;</span><br><span class="line">ans += (1 &lt;&lt; i);</span><br><span class="line">k = go[k][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res[s[p].id] = ans + 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s[i].l &gt;&gt; s[i].r;</span><br><span class="line">if(s[i].r &lt; s[i].l)</span><br><span class="line">s[i].r += m;</span><br><span class="line">s[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(s + 1, s + 1 + n, cmp);</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">s[i + n] = s[i];</span><br><span class="line">s[i + n].l = s[i].l + m;</span><br><span class="line">s[i + n].r = s[i].r + m;</span><br><span class="line">&#125;</span><br><span class="line">pre();</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">search(i);</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="学习总结-1"><a href="#学习总结-1" class="headerlink" title="学习总结"></a>学习总结</h3><p>这段代码实现了一个经典的区间覆盖问题，核心思想是通过排序和动态规划来高效地解决覆盖区间的最小边防战士数量。具体做法是将所有的区间转化成线性区间，使用排序保证覆盖的顺序性，再通过二分查找和动态规划的结合，优化查询效率。这个思路对于解决类似的区间覆盖问题非常有效，尤其是在大规模数据输入时，能够显著减少计算复杂度。通过合理使用跳跃表和二分查找，代码实现了较高的效率，是学习算法设计和优化的重要案例。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task 2</title>
      <link href="/2025/02/06/Task-2/"/>
      <url>/2025/02/06/Task-2/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第二讲-“二分”"><a href="#寒假第二讲-“二分”" class="headerlink" title="寒假第二讲:“二分”"></a>寒假第二讲:“二分”</h1><h2 id="一-二分查找"><a href="#一-二分查找" class="headerlink" title="一.二分查找"></a>一.二分查找</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这个问题的要求是通过二分查找，在一个已经按升序排列的整数序列中查找是否包含查询的整数。对于每次查询，若该整数在序列中出现，则输出 “Yes”，否则输出 “No”。</p><ol><li><strong>输入处理</strong>：<ul><li>输入一个整数 nnn，表示数组的大小。</li><li>接下来输入 nnn 个整数，这些整数已排序。</li><li>接着输入一个整数 qqq，表示查询次数。</li><li>对于每次查询，输入一个整数 mmm，需要判断 mmm 是否出现在排序数组中。</li></ul></li><li><strong>二分查找</strong>：<ul><li>二分查找是一种高效的查找方法，在一个已排序的数组中查找某个元素的时间复杂度为 O(log⁡n)O(\log n)O(logn)。</li><li>使用标准库的 <code>lower_bound</code> 函数来实现二分查找。它会返回一个指向数组中第一个大于或等于查询值的迭代器。如果迭代器指向的元素与查询值相同，则表示该元素存在。</li></ul></li><li><strong>输出</strong>：<ul><li>如果查询值在数组中存在，则输出 “Yes”；否则输出 “No”。</li></ul></li></ol><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;  // For lower_bound</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; arr(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class="line">        int m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">      </span><br><span class="line">        auto it = lower_bound(arr.begin(), arr.end(), m);</span><br><span class="line">  </span><br><span class="line">        if (it != arr.end() &amp;&amp; *it == m) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>该问题要求在已排序的数组中进行多个查找操作，最直观的做法是使用二分查找。二分查找能够将查找时间从 O(n)O(n)O(n) 降低到 O(log⁡n)O(\log n)O(logn)，因此对于大规模数据，能够显著提高效率。利用 C++ STL 提供的 <code>lower_bound</code> 函数，可以高效地实现二分查找，避免手动实现查找算法。通过这种方法，每次查询的时间复杂度为 O(log⁡n)O(\log n)O(logn)，因此总的时间复杂度为 O(qlog⁡n)O(q \log n)O(qlogn)，适合处理较大规模的输入数据。</p><p>这个解法对于最大值 n&#x3D;100000n &#x3D; 100000n&#x3D;100000 和 q&#x3D;100000q &#x3D; 100000q&#x3D;100000 的情况也是可行的，满足时间限制。</p><h2 id="二-A-B数对"><a href="#二-A-B数对" class="headerlink" title="二.A-B数对"></a>二.A-B数对</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>给定数列以及常数 CCC，要求计算满足条件 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C 的数对个数。这个问题要求判断在数列中，存在多少对 (A,B)(A, B)(A,B)，使得 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C，即 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C。</p><h4 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h4><ol><li><strong>数学转换</strong>：<ul><li>给定条件 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C，可转化为 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C。因此，对于每个 BBB，我们只需要判断 B+CB + CB+C 是否出现在数列中。</li></ul></li><li><strong>使用哈希表</strong>：<ul><li>使用哈希表（<code>unordered_map</code>）来记录数列中每个数字的出现次数。遍历数列，对于每个数 BBB，计算 B+CB + CB+C，然后检查哈希表中是否有这个数。如果有，则计数增加。</li></ul></li><li><strong>效率问题</strong>：<ul><li>用哈希表统计数列中各个数字的出现次数，查找某个数是否存在的操作是 O(1)O(1)O(1)，所以该算法的时间复杂度是 O(N)O(N)O(N)，适用于大规模数据。</li></ul></li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, C;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; C;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; arr(N);</span><br><span class="line">    unordered_map&lt;int, int&gt; freq;  </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        ++freq[arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    long long count = 0; </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        int B = arr[i];</span><br><span class="line">        int A = B + C;  // 计算A = B + C</span><br><span class="line">       </span><br><span class="line">        if (freq.find(A) != freq.end()) &#123;</span><br><span class="line">            count += freq[A];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>哈希表</strong>： 哈希表在处理需要快速查找的场景中非常有用。在本题中，哈希表帮助我们在 O(1)O(1)O(1) 的时间复杂度内查找某个元素是否存在，使得整体复杂度从 O(N2)O(N^2)O(N2) 降低到 O(N)O(N)O(N)。</p><p><strong>优化思维</strong>： 通过将问题转化为查找数列中是否存在某个数 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C，我们避免了枚举所有数对的低效方法。这是典型的通过数学转化优化问题的思路。</p><p><strong>时间与空间复杂度</strong>： 学习如何平衡时间和空间复杂度。通过使用哈希表，虽然增加了额外的空间开销，但极大地提高了算法效率，适应了问题的大数据规模。</p><p><strong>实际应用</strong>： 哈希表和集合操作在实际开发中有着广泛应用，例如数据库的索引、缓存系统等，了解并掌握这些基本数据结构对解决实际问题至关重要。</p><h2 id="三-分巧克力"><a href="#三-分巧克力" class="headerlink" title="三.分巧克力"></a>三.分巧克力</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求我们从 <code>N</code> 块巧克力中切出 <code>K</code> 块正方形巧克力，且每块正方形的边长尽可能大。我们需要通过切割巧克力的长方形，得到大小相同的正方形。</p><h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><ol><li><strong>正方形的大小</strong>：<ul><li>对于每一块巧克力 Hi×WiH_i \times W_iHi×Wi，我们能够从中切出多少个 S×SS \times SS×S 的正方形（其中 SSS 为正方形的边长）？</li><li>我们可以通过将 HiH_iHi 和 WiW_iWi 分别除以 SSS，计算每个长方形可以切出的正方形数量： 个数&#x3D;⌊HiS⌋×⌊WiS⌋\text{个数} &#x3D; \left\lfloor \frac{H_i}{S} \right\rfloor \times \left\lfloor \frac{W_i}{S} \right\rfloor个数&#x3D;⌊SHi⌋×⌊SWi⌋</li><li>我们需要找到一个 SSS，使得从所有 NNN 块巧克力中切出的正方形总数至少为 KKK。</li></ul></li><li><strong>二分查找</strong>：<ul><li>由于我们希望切出的正方形边长尽可能大，最直观的办法是使用二分查找来确定边长 SSS 的最大值。范围从 1 到每块巧克力的最大边长（即 min⁡(Hi,Wi)\min(H_i, W_i)min(Hi,Wi)）。</li></ul></li><li><strong>检查条件</strong>：<ul><li>对于每个 SSS，我们计算出所有巧克力切出的正方形数量，并判断是否能够满足至少有 KKK 块巧克力。如果能满足，说明 SSS 是一个可能的解，我们可以继续尝试更大的 SSS；否则，尝试更小的 SSS。</li></ul></li></ol><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 判断给定边长 S 能否从所有巧克力中切出至少 K 块正方形</span><br><span class="line">bool canCutSquares(const vector&lt;pair&lt;int, int&gt;&gt;&amp; chocolates, int S, int K) &#123;</span><br><span class="line">    long long totalCount = 0;  // 记录切出的正方形总数</span><br><span class="line">    for (const auto&amp; chocolate : chocolates) &#123;</span><br><span class="line">        int H = chocolate.first;</span><br><span class="line">        int W = chocolate.second;</span><br><span class="line">        totalCount += (H / S) * (W / S);  // 计算该巧克力能切出多少个 S * S 的正方形</span><br><span class="line">        if (totalCount &gt;= K) return true;  // 如果已达到要求的数量，提前返回</span><br><span class="line">    &#125;</span><br><span class="line">    return totalCount &gt;= K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, K;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; chocolates(N);</span><br><span class="line">    int maxSide = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; chocolates[i].first &gt;&gt; chocolates[i].second;</span><br><span class="line">        maxSide = max(maxSide, min(chocolates[i].first, chocolates[i].second));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int low = 1, high = maxSide, bestSide = 0;</span><br><span class="line"></span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (canCutSquares(chocolates, mid, K)) &#123;</span><br><span class="line">            bestSide = mid;  </span><br><span class="line">            low = mid + 1;  </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            high = mid - 1;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bestSide &lt;&lt; endl; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>二分查找的应用</strong>：通过二分查找可以高效地求解正方形的最大边长，尤其是在边长空间较大时，能够显著降低时间复杂度。</p><p><strong>空间利用</strong>：通过使用哈希表和二分查找，我们在时间和空间上达到了较优的平衡，能够处理最大规模的数据。</p><p><strong>问题的数学转化</strong>：通过将切割问题转化为数目判断问题，利用二分查找可以有效避免暴力破解的高时间复杂度。</p><h2 id="四-卡牌"><a href="#四-卡牌" class="headerlink" title="四.卡牌"></a>四.卡牌</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p><strong>减少重复计算</strong>：</p><ul><li>在 <code>canMakeKSets</code> 函数中，我们每次都需要计算空白卡牌的数量。考虑到 <code>a[i]</code> 和 <code>b[i]</code> 对于每个卡牌是固定的，我们可以提前计算每种卡牌的补充量，然后直接通过前缀和计算每个 <code>k</code> 的所需补充卡牌数。</li></ul><p><strong>通过前缀和优化卡牌需求计算</strong>：</p><ul><li>计算需要补充的空白卡牌数时，如果我们能提前计算出每种卡牌在每个 <code>k</code> 值下需要多少空白卡牌，可以加速查找。</li><li>我们可以使用 <strong>贪心策略</strong> 或者 <strong>扫描算法</strong>，避免每次都全量扫描 <code>n</code> 个卡牌。</li></ul><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n, m, a[N + 5], b[N + 5];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    bool f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    for (; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) f ^= (ch == &#x27;-&#x27;);</span><br><span class="line">    for (; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool check(int mid) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cnt += max(0LL, mid - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt &lt;= m;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Kafka() &#123;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line">    </span><br><span class="line">    int L = 1, R = n * 2;</span><br><span class="line"> </span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i] = read();</span><br><span class="line">        R = min(a[i] + b[i], R);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二分查找最大套牌数</span><br><span class="line">    while (L &lt; R) &#123;</span><br><span class="line">        int mid = (L + R + 1) &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) &#123;</span><br><span class="line">            L = mid;  </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            R = mid - 1; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; L &lt;&lt; &#x27;\n&#x27;;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>提前计算补充数量</strong>：通过一次遍历计算每个 <code>k</code> 需要的补充卡牌数量，可以减少时间复杂度，避免重复计算。</p><p><strong>二分查找的技巧</strong>：通过二分查找可以有效缩小搜索范围，每次判断可以集中判断某个 <code>k</code> 是否可行。</p><p><strong>空间优化</strong>：只使用简单的数组来存储卡牌数量和补充限制，空间复杂度为 <code>O(n)</code>，符合题目要求。</p><h2 id="五-书的复制"><a href="#五-书的复制" class="headerlink" title="五.书的复制"></a>五.书的复制</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题目要求将 <code>m</code> 本有顺序的书分给 <code>k</code> 个人复制，每个人抄写的书是连续的，并且需要尽可能最短的复制时间。复制时间指的是抄写页数最多的人所用的时间，目标是尽可能减少这个时间。</p><p>为了解决这个问题，采用了 <strong>二分查找</strong> 和 <strong>贪心算法</strong> 结合的策略：</p><ol><li><strong>二分查找</strong>：<ul><li>对于复制时间的最大值 <code>max_time</code>（即抄写页数最多的人的时间），我们可以进行二分查找。</li><li>初始时，设置 <code>L = 1</code>（最小值）和 <code>R = sum(a)</code>（最大值，所有书页加起来）。</li><li>对于每个中间值 <code>mid</code>，我们要判断是否能在 <code>mid</code> 的最大时间限制下，合理分配书籍给 <code>k</code> 个人。</li></ul></li><li><strong>贪心算法</strong>：<ul><li>每次尝试用当前的 <code>mid</code> 来分配书籍：从书籍列表中依次分配，如果当前人的已分配页数超过 <code>mid</code>，就开始分配给下一个人。</li><li>通过这种方式，我们可以确定在当前的 <code>mid</code> 时间下，能分配给 <code>k</code> 个人。</li></ul></li><li><strong>过程描述</strong>：<ul><li>对于每次二分查找的 <code>mid</code>，我们从第 1 个人开始，贪心地分配书籍。如果当前书籍无法分配给当前人（超出了 <code>mid</code> 时间），就换给下一个人，直到所有书籍分配完。</li><li>如果我们能够在 <code>k</code> 个人内完成分配，那么说明当前的 <code>mid</code> 值是可行的，我们尝试缩小 <code>mid</code>；否则，增大 <code>mid</code>。</li></ul></li><li><strong>结果输出</strong>：<ul><li>二分查找结束后，最终的最优时间就是 <code>L</code>，然后根据该时间输出每个人抄写的书籍区间。</li></ul></li></ol><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int K=500;</span><br><span class="line">int m,k,a[K+5];</span><br><span class="line">int st[K+5],ed[K+5];</span><br><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int x=0;bool f=1;char ch=getchar();</span><br><span class="line">    for(;ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;;ch=getchar())f^=(ch==&#x27;-&#x27;);</span><br><span class="line">    for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar())x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);</span><br><span class="line">    return f?x:-x;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int mid)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt=1,now=mid;</span><br><span class="line">    for(int i=1;i&lt;=m&amp;&amp;cnt&lt;=k;++i) </span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&gt;now) ++cnt,--i,now=mid;</span><br><span class="line">        else now-=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line">void Kafka()</span><br><span class="line">&#123;</span><br><span class="line">    m=read(),k=read();</span><br><span class="line">    int L=1,R=0;</span><br><span class="line">    for(int i=1;i&lt;=m;++i) a[i]=read(),R+=a[i];</span><br><span class="line">    for(int mid=L+R&gt;&gt;1;L&lt;R;check(mid)?R=mid:L=mid+1)mid=L+R&gt;&gt;1;</span><br><span class="line">    ed[k]=m,st[1]=1;</span><br><span class="line">    for(int i=k,j=m,now=L;i;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        for(;now&gt;=a[j]&amp;&amp;j;--j) now-=a[j];</span><br><span class="line">        st[i]=j+1,ed[i-1]=j,now=L;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=k;++i) cout&lt;&lt;st[i]&lt;&lt;&#x27; &#x27;&lt;&lt;ed[i]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-4"><a href="#3-学习总结-4" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>本题考察了 <strong>二分查找</strong> 和 <strong>贪心算法</strong> 的结合使用。通过二分查找高效地探索最优解空间，再结合贪心算法快速判断是否能在指定时间内完成分配，使得问题得以高效解决。这种类型的问题不仅能够加深对算法思维的理解，还能帮助解决实际中遇到的类似最优化问题。</p><h2 id="六-青蛙过河"><a href="#六-青蛙过河" class="headerlink" title="六.青蛙过河"></a>六.青蛙过河</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求小青蛙在河对岸和学校之间来回跳跃，以最小化跳跃的能力（即最小的跳跃距离）。每次小青蛙必须从一块石头起跳，并且跳跃的距离不能超过某个值。为了确保小青蛙能够完成指定的跳跃次数（2x次），我们需要找到一个合适的跳跃距离，使得它能够在有限的跳跃次数内成功完成任务。</p><ul><li><p>首先我们需要确定最小跳跃能力的范围。最小值为 <code>1</code>，最大值为 <code>n-1</code>（即河宽度），即从河的起点到终点的最大跳跃距离。</p></li><li><p>我们可以使用二分查找来缩小跳跃能力的范围。通过不断尝试不同的跳跃能力 <code>mid</code>，并判断是否能够完成 <code>2x</code> 次跳跃。</p></li><li><p>为了判断某个跳跃能力是否合适，模拟小青蛙的跳跃过程：从起点开始，每次尝试跳跃尽可能远的石头（跳跃的距离不超过当前的 <code>mid</code>），并尽量减少跳跃的次数。</p></li><li><p>如果跳跃次数小于或等于 <code>2x</code>，则当前跳跃能力 <code>mid</code> 是可行的。</p></li><li><p>否则，当前跳跃能力 <code>mid</code> 太小，不能完成任务。</p></li><li><p>通过二分查找不断调整跳跃能力的范围，直到找到最小的可行跳跃能力。</p></li></ul><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n, x, H[N + 5], sum[N + 5];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0; bool f = 1; char ch = getchar();</span><br><span class="line">    for (; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) f ^= (ch == &#x27;-&#x27;);</span><br><span class="line">    for (; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check(int mid) &#123;</span><br><span class="line">    int cnt = 0, last = 0;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        if (i - last &gt; mid) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            last = i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n - last &gt; mid) cnt++;</span><br><span class="line">    return cnt &lt;= 2 * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Kafka() &#123;</span><br><span class="line">    n = read(), x = read();</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        H[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int L = 1, R = n, ans = n;</span><br><span class="line">    while (L &lt;= R) &#123;</span><br><span class="line">        int mid = (L + R) &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            R = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            L = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-5"><a href="#3-学习总结-5" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>二分查找的应用</strong><br>二分查找通常用来在有序区间中查找某个满足条件的值。在本题中，我们通过二分查找来找到最小的跳跃能力，这种问题通常被称为“最小最大化问题”。</p><p><strong>模拟问题的实现</strong><br>本题中模拟了小青蛙的跳跃过程，模拟的关键是如何判断是否能在有限的跳跃次数内完成任务。通过检查每个 <code>mid</code> 跳跃能力是否能够完成 <code>2x</code> 次跳跃，判断当前跳跃能力的可行性。</p><p><strong>问题求解中的二分查找优化</strong><br>由于本题的跳跃能力是一个整数范围，且通过验证跳跃能力的可行性可以在常数时间内完成，所以二分查找在这个问题中是一种高效的求解方法。</p><p><strong>复杂度分析</strong></p><ul><li>二分查找的时间复杂度是 <code>O(log n)</code>。</li><li>对每个 <code>mid</code> 值，我们需要遍历石头进行一次跳跃模拟，最坏情况下是 <code>O(n)</code>。</li><li>因此，总的时间复杂度是 <code>O(n log n)</code>，对于 <code>n</code> 最大为 <code>10^5</code> 的数据，能够有效地在时间限制内完成计算。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task 1</title>
      <link href="/2025/02/06/Task-1/"/>
      <url>/2025/02/06/Task-1/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第一讲：C-基础"><a href="#寒假第一讲：C-基础" class="headerlink" title="寒假第一讲：C++ 基础"></a>寒假第一讲：C++ 基础</h1><h2 id="一-Long-Loong"><a href="#一-Long-Loong" class="headerlink" title="一.Long Loong"></a>一.Long Loong</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>思路较为简单，就是先固定输出L，再根据输入的N得到应该输出多少o，最后再固定输出ng。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; &#x27;L&#x27;;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">cout &lt;&lt; &#x27;o&#x27;;</span><br><span class="line">cout &lt;&lt; &quot;ng&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>学到了for循环的基本用法，对我帮助极大，受益良多。</p><h2 id="二-YES-or-YES"><a href="#二-YES-or-YES" class="headerlink" title="二.YES or YES?"></a>二.YES or YES?</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>思路就是将输入的字符串全部大写，然后判断是否等于YES，如果等于就输出YES，不等于就输出NO。</p><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t; </span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        transform(s.begin(), s.end(), s.begin(), ::toupper);</span><br><span class="line">        if (s == &quot;YES&quot;) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>字符串处理：通过 <code>transform</code> 配合 <code>tolower</code> 或 <code>toupper</code>，可以快速将字符串统一为小写或大写，便于比较。</li><li>循环与分支：利用 <code>while (t--)</code> 循环高效处理多组输入，结合 <code>if-else</code> 判断分类处理逻辑。</li><li>时间复杂度：转换大小写或比较字符串的复杂度为 O(字符串长度)O(\text{字符串长度})O(字符串长度)。整体复杂度为 O(t)O(t)O(t)，适用于测试用例较多的情况。</li><li>STL 使用：标准库函数如 <code>transform</code> 和字符串直接比较提升了代码简洁性和可靠性。</li></ol><h2 id="三-Even-Odd-G"><a href="#三-Even-Odd-G" class="headerlink" title="三.Even? Odd? G"></a>三.Even? Odd? G</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这个程序的主要任务是根据输入的一组超大整数，判断每个整数的奇偶性（即最后一位数字是偶数还是奇数）。由于数的范围可能非常大（高达 106010^{60}1060），无法直接使用普通整数类型（如 <code>int</code> 或 <code>long long</code>），所以采用字符串处理的方式。</p><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    int N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; results;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        string number;</span><br><span class="line">        cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">        char lastDigit = number[number.length() - 1];</span><br><span class="line">        if ((lastDigit - &#x27;0&#x27;) % 2 == 0) &#123;</span><br><span class="line">            results.push_back(&quot;even&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            results.push_back(&quot;odd&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (const string&amp; result : results) &#123;</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>字符串处理大数</strong>：</p><ul><li>当数字的范围超过内置类型的支持时，可以用字符串表示并处理。</li><li>判断奇偶性只需关注数字的最后一位，简化了大数的操作。</li></ul><p><strong>模运算的应用</strong>：</p><ul><li>奇偶性的本质是看数字能否被 222 整除，通过 mod  2\mod 2mod2 运算即可实现。</li></ul><h2 id="四-Problem-Generator"><a href="#四-Problem-Generator" class="headerlink" title="四.Problem Generator"></a>四.Problem Generator</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li>输入处理</li></ol><ul><li>读取测试用例数量 <code>t</code>。</li><li>对于每个测试用例，读取两个整数 <code>n</code>（题库题目数量）和 <code>m</code>（比赛轮次），以及一个字符串 <code>a</code> 表示题库中的题目难度。</li></ul><ol start="2"><li>统计题目数量</li></ol><ul><li>使用7个变量 <code>n1</code> 到 <code>n7</code> 分别记录每种难度（A到G）的题目数量。</li><li>遍历字符串 <code>a</code>，通过比较字符 <code>c</code> 是否为 ‘A’ 到 ‘G’ 来对每种难度的题目计数。</li></ul><ol start="3"><li>每种难度的最大需求</li></ol><ul><li>每轮比赛需要一个完整的难度级别（A到G），即每种难度最多需要 mmm 道题。</li></ul><ol start="4"><li>计算需要补充的题目数量</li></ol><ul><li><p>每轮比赛需要7种难度的题目，因此总需求为 7×m7 \times m7×m。</p></li><li><p>当前已有的题目总量为 n1+n2+⋯+n7n1 + n2 + \dots + n7n1+n2+⋯+n7。</p></li><li><p>需要补充的题目数量为： 需要补充&#x3D;max⁡(0,7×m−当前已有的题目总量)\text{需要补充} &#x3D; \max(0, 7 \times m - \text{当前已有的题目总量})需要补充&#x3D;max(0,7×m−当前已有的题目总量)</p></li><li><p>如果已有题目足够，则补充为0；否则补充缺少的题目数量。</p></li></ul><ol start="5"><li>输出结果</li></ol><ul><li>将每个测试用例的结果输出在单独的一行。</li></ul><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;   </span><br><span class="line"> </span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        string a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        int n1 = 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0, n6 = 0, n7 = 0;</span><br><span class="line">        for (char c : a)</span><br><span class="line">        &#123;</span><br><span class="line">            if (c == &#x27;A&#x27;)</span><br><span class="line">                n1++;</span><br><span class="line">            if (c == &#x27;B&#x27;)</span><br><span class="line">                n2++;</span><br><span class="line">            if (c == &#x27;C&#x27;)</span><br><span class="line">                n3++;</span><br><span class="line">            if (c == &#x27;D&#x27;)</span><br><span class="line">                n4++;</span><br><span class="line">            if (c == &#x27;E&#x27;)</span><br><span class="line">                n5++;</span><br><span class="line">            if (c == &#x27;F&#x27;)</span><br><span class="line">                n6++;</span><br><span class="line">            if (c == &#x27;G&#x27;)</span><br><span class="line">                n7++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n1 &gt; m)</span><br><span class="line">            n1 = m;</span><br><span class="line">        if (n2 &gt; m)</span><br><span class="line">            n2 = m;</span><br><span class="line">        if (n3 &gt; m)</span><br><span class="line">            n3 = m;</span><br><span class="line">        if (n4 &gt; m)</span><br><span class="line">            n4 = m;</span><br><span class="line">        if (n5 &gt; m)</span><br><span class="line">            n5 = m;</span><br><span class="line">        if (n6 &gt; m)</span><br><span class="line">            n6 = m;</span><br><span class="line">        if (n7 &gt; m)</span><br><span class="line">            n7 = m;</span><br><span class="line">        cout &lt;&lt; max(0, 7 * m - n1 - n2 - n3 - n4 - n5 - n6 - n7) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ul><li><p>本题通过统计每种难度题目的数量解决问题。这是字符频率统计的典型应用。</p></li><li><p>通过遍历字符串并比较字符，可以有效统计各类别出现次数。</p></li></ul><h2 id="五-rules"><a href="#五-rules" class="headerlink" title="五.rules"></a>五.rules</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这段代码解决的问题是考察规则是否符合民意，主要步骤如下：</p><ol><li><p>输入数据：首先读取居民总数 <code>n</code>、记录天数 <code>m</code> 以及规则代号 <code>k</code>。</p></li><li><p>统计符合民意的天数：</p><p>循环 <code>m</code> 次，表示逐天处理记录。</p><p>对每一天，统计有多少居民遵守了规则 <code>k</code>（计数器 <code>c2</code>）。</p><p>如果遵守规则 <code>k</code> 的人数大于等于一半 (<code>c2 * 2 &gt;= n</code>)，则该天规则符合民意，符合民意的天数计数器 <code>c1</code> 加一。</p></li><li><p>判断规则正确性</p><p>：如果符合民意的天数大于等于记录天数的一半 (<code>c1 * 2 &gt;= m</code>)，输出 “YES” 表示规则正确，否则输出 “NO”。</p></li></ol><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m, n, k;</span><br><span class="line">int c1 = 0, c2 = 0;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">for (int i = 0; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">c2 = 0;</span><br><span class="line">for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">if (t == k)</span><br><span class="line">&#123;</span><br><span class="line">c2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if ( c2*2 &gt;=  n)</span><br><span class="line">&#123;</span><br><span class="line">c1++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;if ( c1*2 &gt;=  m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;YES&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-4"><a href="#3-学习总结-4" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>这道题目涉及多重循环的处理，是学习数组与条件判断的重要练习。通过这段代码可以总结如下：</p><ol><li><p>理解核心逻辑</p><p>问题的核心在于两层判断：一是某天规则是否符合民意，二是统计符合民意的天数是否达到要求。这种多层嵌套条件是常见的编程模式。</p></li><li><p>优化循环效率</p><p>本代码通过双重循环按天和按人处理问题，时间复杂度为 O(m×n)O(m \times n)O(m×n)。这种结构在处理范围较大时可能需要优化。</p></li><li><p>掌握计数逻辑</p><p>使用计数器 <code>c2</code> 和 <code>c1</code> 逐步累积数据，并通过条件判断更新状态。这种逻辑清晰、简洁，适合复杂问题分步解决。</p></li></ol><h2 id="六-Many-Replacement"><a href="#六-Many-Replacement" class="headerlink" title="六.Many Replacement"></a>六.Many Replacement</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p>初始化映射表：</p><p>创建一个 <code>mapping</code> 数组，长度为 26（表示字母表），初始化为 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 的对应字母。这个表将用于记录字母替换关系。</p></li><li><p>处理替换操作：</p><p>对每个替换指令 <code>(c, d)</code>，遍历 <code>mapping</code> 数组，将所有值等于 <code>c</code> 的项替换为 <code>d</code>。</p><p>这种方式确保了间接替换链条也能正确生效。例如，如果先将 <code>a</code> 替换为 <code>b</code>，再将 <code>b</code> 替换为 <code>c</code>，最终 <code>a</code> 也会被替换为 <code>c</code>。</p></li><li><p>修改字符串：</p><p>遍历字符串 <code>S</code> 的每个字符，根据 <code>mapping</code> 数组中的映射关系，将字符替换为最终映射的目标字符。</p></li><li><p>输出结果：</p><p>输出修改后的字符串 <code>S</code>。</p></li></ol><p>通过使用 <code>mapping</code> 数组记录全局映射关系，避免直接修改字符串多次，提高了处理效率。</p><h3 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, Q;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    string S;</span><br><span class="line">    cin &gt;&gt; S;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    vector&lt;char&gt; mapping(26);</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">        mapping[i] = &#x27;a&#x27; + i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; Q; i++) &#123;</span><br><span class="line">        char c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        for (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">            if (mapping[j] == c) &#123;</span><br><span class="line">                mapping[j] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (char &amp;ch : S) &#123;</span><br><span class="line">        ch = mapping[ch - &#x27;a&#x27;]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-5"><a href="#3-学习总结-5" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>1.高效处理替换链：</p><p>  使用一个映射表 (<code>mapping</code> 数组) 将字符替换逻辑统一管理，避免了直接在字符串中进行多次替换操作，降低了时间复杂度。</p><p>2.间接替换链的处理：</p><p>  通过在处理替换指令时遍历整个映射表，确保链式替换得到正确结果。这种方法适用于有依赖关系的替换问题。</p><p>3.复杂度优化：</p><p>  替换操作遍历 <code>mapping</code> 的复杂度为 O(Q×26)O(Q \times 26)O(Q×26)，字符串替换为 O(N)O(N)O(N)，整体复杂度约为 O(Q+N)O(Q + N)O(Q+N)，足以处理较大输入规模。</p><p>4.边界条件考虑：</p><p>  替换字符可以是相同的（<code>c = d</code>），这种情况不会影响映射表。</p><p>  某些字符可能不存在于字符串中，但替换逻辑依然可以正常处理。</p><h2 id="更好的交换"><a href="#更好的交换" class="headerlink" title="更好的交换"></a>更好的交换</h2><h3 id="1-对应思路-6"><a href="#1-对应思路-6" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p>输入与初始化：</p><p>读取矩阵大小 <code>n</code> 和操作次数 <code>m</code>。</p><p>读取矩阵内容并存储在 <code>matrix</code> 中。</p><p>初始化两个数组 <code>row_map</code> 和 <code>col_map</code>，分别记录行和列的映射关系，初始值为 <code>[0, 1, 2, ..., n-1]</code>。</p></li><li><p>操作处理：</p><p>遍历每个操作，根据操作类型：</p><p>  若 <code>op == 1</code>（交换行），则交换 <code>row_map[x]</code> 和 <code>row_map[y]</code>。</p><p>  若 <code>op == 0</code>（交换列），则交换 <code>col_map[x]</code> 和 <code>col_map[y]</code>。</p><p>通过修改 <code>row_map</code> 和 <code>col_map</code> 的映射关系，而非直接修改矩阵，节省了时间复杂度。</p></li><li><p>输出矩阵：</p><p>根据最终的 <code>row_map</code> 和 <code>col_map</code>，重新按映射顺序输出矩阵。<code>matrix[row_map[i]][col_map[j]]</code> 得到正确的映射值。</p></li></ol><p>通过这种间接映射法，避免了每次交换直接操作矩阵，提高了效率，适合大规模输入。</p><h3 id="2-代码-6"><a href="#2-代码-6" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n));</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; row_map(n), col_map(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        row_map[i] = i; </span><br><span class="line">        col_map[i] = i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        --x; </span><br><span class="line">        --y;</span><br><span class="line">        if (op == 1) &#123;</span><br><span class="line">            swap(row_map[x], row_map[y]); </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            swap(col_map[x], col_map[y]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; matrix[row_map[i]][col_map[j]] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-6"><a href="#3-学习总结-6" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>间接映射优化：</p><p>​    直接交换矩阵行列会带来高昂的时间复杂度，间接通过映射数组调整顺序是一种高效的解决方式。</p><p>空间与时间的平衡：</p><p>​    增加两个映射数组 <code>row_map</code> 和 <code>col_map</code>，用空间换取了时间的优化。</p><p>​    在 mmm 次操作和 n2n^2n2 次矩阵访问中，复杂度降低为 O(n2+m)O(n^2 + m)O(n2+m)，适合处理大规模 n,mn, mn,m。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog用法</title>
      <link href="/2025/02/06/blog%E7%94%A8%E6%B3%95/"/>
      <url>/2025/02/06/blog%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h1 id="本地网站"><a href="#本地网站" class="headerlink" title="本地网站"></a>本地网站</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/06/hello-world/"/>
      <url>/2025/02/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
