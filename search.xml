<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AsyncTask的用法示例</title>
      <link href="/2025/03/27/AsyncTask%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/27/AsyncTask%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-中-AsyncTask-的使用教程"><a href="#Kotlin-中-AsyncTask-的使用教程" class="headerlink" title="Kotlin 中 AsyncTask 的使用教程"></a>Kotlin 中 AsyncTask 的使用教程</h1><p>AsyncTask 用于将耗时操作放到后台线程执行，同时在任务开始和结束时在主线程更新 UI。本文将逐步讲解其基本概念、生命周期方法，并提供一个简单的示例代码。</p><p>值得注意的是， 从 Android 11 开始，AsyncTask 已被弃用，建议在新项目中使用 Kotlin 协程、WorkManager 或其他异步方案，本文仅做学习记录使用。</p><hr><h2 id="1-AsyncTask-的基本概念"><a href="#1-AsyncTask-的基本概念" class="headerlink" title="1. AsyncTask 的基本概念"></a>1. AsyncTask 的基本概念</h2><p>AsyncTask 使用三个泛型参数来确定任务的输入、进度和结果类型：</p><ul><li><strong>Params</strong>：传递给任务的参数类型。</li><li><strong>Progress</strong>：任务执行中更新进度时使用的数据类型。</li><li><strong>Result</strong>：任务执行完毕后返回的结果类型。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class MyTask : AsyncTask&lt;Void, Int, String&gt;() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>表示该任务不需要输入参数（Void）、进度为 Int 类型、最终结果为 String。</p><hr><h2 id="2-AsyncTask-的生命周期方法"><a href="#2-AsyncTask-的生命周期方法" class="headerlink" title="2. AsyncTask 的生命周期方法"></a>2. AsyncTask 的生命周期方法</h2><p>AsyncTask 定义了多个回调方法，每个方法在任务执行的不同阶段被调用：</p><ul><li><strong>onPreExecute()</strong><br> 在任务开始前调用，通常用于初始化 UI（例如显示进度条）。</li><li><strong>doInBackground(vararg params: Params)</strong><br> 在后台线程中执行耗时操作。此方法不能直接更新 UI，但可以调用 <code>publishProgress()</code> 触发进度更新。</li><li><strong>onProgressUpdate(vararg values: Progress)</strong><br> 当调用 <code>publishProgress()</code> 时在主线程中执行，用于更新 UI 中的进度显示。</li><li><strong>onPostExecute(result: Result)</strong><br> 在后台任务执行完毕后调用，运行在主线程中，可以使用任务返回的结果更新 UI。</li><li><strong>onCancelled()</strong><br> 当任务被取消时调用，可用于清理操作。</li></ul><hr><h2 id="3-Kotlin-示例代码"><a href="#3-Kotlin-示例代码" class="headerlink" title="3. Kotlin 示例代码"></a>3. Kotlin 示例代码</h2><p>下面的示例展示了如何使用 AsyncTask 在后台模拟一个耗时任务（例如计数操作），并在 UI 上更新进度和显示结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import android.os.AsyncTask</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.widget.ProgressBar</span><br><span class="line">import android.widget.TextView</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var progressBar: ProgressBar</span><br><span class="line">    private lateinit var textView: TextView</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        progressBar = findViewById(R.id.progressBar)</span><br><span class="line">        textView = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">        // 执行 AsyncTask</span><br><span class="line">        MyTask().execute()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内部类可以使用 Kotlin 内部类的形式定义 AsyncTask</span><br><span class="line">    private inner class MyTask : AsyncTask&lt;Void, Int, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        override fun onPreExecute() &#123;</span><br><span class="line">            super.onPreExecute()</span><br><span class="line">            // 初始化 UI，显示进度条</span><br><span class="line">            progressBar.progress = 0</span><br><span class="line">            textView.text = &quot;任务开始...&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun doInBackground(vararg params: Void?): String &#123;</span><br><span class="line">            for (i in 0..100) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 模拟耗时操作，例如计数，每次暂停 50 毫秒</span><br><span class="line">                    Thread.sleep(50)</span><br><span class="line">                &#125; catch (e: InterruptedException) &#123;</span><br><span class="line">                    e.printStackTrace()</span><br><span class="line">                &#125;</span><br><span class="line">                // 更新进度</span><br><span class="line">                publishProgress(i)</span><br><span class="line">            &#125;</span><br><span class="line">            // 返回结果</span><br><span class="line">            return &quot;任务完成！&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onProgressUpdate(vararg values: Int?) &#123;</span><br><span class="line">            super.onProgressUpdate(*values)</span><br><span class="line">            // 更新进度条和文本显示</span><br><span class="line">            values[0]?.let &#123; progress -&gt;</span><br><span class="line">                progressBar.progress = progress</span><br><span class="line">                textView.text = &quot;当前进度: $progress%&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onPostExecute(result: String?) &#123;</span><br><span class="line">            super.onPostExecute(result)</span><br><span class="line">            // 任务完成后更新 UI</span><br><span class="line">            textView.text = result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onCancelled() &#123;</span><br><span class="line">            super.onCancelled()</span><br><span class="line">            textView.text = &quot;任务取消&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ul><li><strong>onPreExecute()</strong><br> 初始化 ProgressBar 和 TextView 的显示状态。</li><li><strong>doInBackground()</strong><br> 在后台执行一个简单的循环操作，每次循环暂停 50 毫秒，并调用 <code>publishProgress()</code> 更新 UI 的进度。</li><li><strong>onProgressUpdate()</strong><br> 接收到进度后，在主线程更新 ProgressBar 和 TextView。</li><li><strong>onPostExecute()</strong><br> 当任务执行完毕后，显示完成消息。</li></ul><hr><h2 id="4-注意事项与最佳实践"><a href="#4-注意事项与最佳实践" class="headerlink" title="4. 注意事项与最佳实践"></a>4. 注意事项与最佳实践</h2><ul><li><strong>内存泄漏问题</strong><br> 如果 AsyncTask 是作为 Activity 的内部类存在，当 Activity 被销毁时可能导致内存泄漏。建议将 AsyncTask 定义为静态内部类，并通过 WeakReference 持有 Activity 的引用。</li><li><strong>执行策略</strong><br> 在 API 11（Android 3.0）及以上版本，AsyncTask 默认串行执行。如果需要并行执行，可以使用 <code>executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)</code>。</li><li><strong>已弃用提醒</strong><br> 从 Android 11 开始，AsyncTask 已被弃用，建议在新项目中使用 Kotlin 协程、WorkManager 或其他异步方案。</li></ul><hr><h2 id="5-为什么推荐-Kotlin-协程？"><a href="#5-为什么推荐-Kotlin-协程？" class="headerlink" title="5. 为什么推荐 Kotlin 协程？"></a>5. 为什么推荐 Kotlin 协程？</h2><ul><li><strong>代码简洁</strong><br> Kotlin 协程可以让异步代码写得像同步代码，减少回调层级和代码冗余。</li><li><strong>更好的错误处理与取消机制</strong><br> 协程内置了结构化并发，便于管理任务生命周期和异常处理。</li><li><strong>官方支持</strong><br> 谷歌和 JetBrains 都推荐在 Android 项目中使用 Kotlin 协程来处理异步任务。</li></ul><hr><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文详细介绍了在 Kotlin 中使用 AsyncTask 的方法，包括各个生命周期回调的作用和示例代码。虽然 AsyncTask 曾经为 Android 异步处理提供了简化方案，但随着技术的发展，Kotlin 协程已成为更推荐的选择。在学习 AsyncTask 的同时，建议大家尽快熟悉并尝试使用 Kotlin 协程以提升代码的简洁性和可维护性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>infix用法示例</title>
      <link href="/2025/03/26/inflix%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/26/inflix%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-infix-函数？"><a href="#什么是-infix-函数？" class="headerlink" title="什么是 infix 函数？"></a><strong>什么是 <code>infix</code> 函数？</strong></h3><p><code>infix</code> 关键字可以让 <strong>单参数的函数</strong> 以 <strong>更自然的语法</strong> 书写，使代码更易读。<br> 你可以把它理解为 <strong>一种特殊的调用方式</strong>，不需要 <code>.</code> 和 <code>()</code>，让代码像 <strong>自然语言</strong> 一样流畅。</p><p>要使用 <code>infix</code>，需要满足 <strong>三个条件</strong>：</p><ol><li><strong>必须是成员函数或扩展函数</strong>（它必须属于某个类或某种类型）。</li><li><strong>必须只有且只能有一个参数</strong>（如果有多个参数，就不能用 <code>infix</code>）。</li><li>⭐⭐⭐⭐⭐⭐<strong>调用时可以省略 <code>.</code> 和 <code>()</code></strong>（但仍然可以用 <code>.</code> 调用）。</li></ol><hr><h3 id="简单示例-1：数字比较"><a href="#简单示例-1：数字比较" class="headerlink" title="简单示例 1：数字比较"></a><strong>简单示例 1：数字比较</strong></h3><h4 id="不使用-infix"><a href="#不使用-infix" class="headerlink" title="不使用 infix"></a><strong>不使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun isBigger(a: Int, b: Int): Boolean &#123;</span><br><span class="line">    return a &gt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(isBigger(10, 5)) // 输出：true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数 <code>isBigger(10, 5)</code> 可读性一般，我们可以用 <code>infix</code> 改写它。</p><hr><h4 id="使用-infix"><a href="#使用-infix" class="headerlink" title="使用 infix"></a><strong>使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">infix fun Int.isBiggerThan(other: Int): Boolean &#123;</span><br><span class="line">    return this &gt; other</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(10 isBiggerThan 5) // 输出：true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <code>10 isBiggerThan 5</code> 读起来就像 <strong>自然语言</strong>，比 <code>isBigger(10, 5)</code> 更易懂。</p><hr><h3 id="简单示例-2：创建-“名字-值”-对"><a href="#简单示例-2：创建-“名字-值”-对" class="headerlink" title="简单示例 2：创建 “名字-值” 对"></a><strong>简单示例 2：创建 “名字-值” 对</strong></h3><h4 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a><strong>普通方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun pair(key: String, value: String): Pair&lt;String, String&gt; &#123;</span><br><span class="line">    return Pair(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val result = pair(&quot;name&quot;, &quot;Alice&quot;)</span><br><span class="line">    println(result) // 输出： (name, Alice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="使用-infix-1"><a href="#使用-infix-1" class="headerlink" title="使用 infix"></a><strong>使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">infix fun String.with(value: String): Pair&lt;String, String&gt; &#123;</span><br><span class="line">    return Pair(this, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val result = &quot;name&quot; with &quot;Alice&quot;</span><br><span class="line">    println(result) // 输出： (name, Alice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <code>&quot;name&quot; with &quot;Alice&quot;</code> 读起来更像 <strong>自然语言</strong>，比 <code>pair(&quot;name&quot;, &quot;Alice&quot;)</code> 更直观。</p><hr><h3 id="简单示例-3：自定义数学运算"><a href="#简单示例-3：自定义数学运算" class="headerlink" title="简单示例 3：自定义数学运算"></a><strong>简单示例 3：自定义数学运算</strong></h3><h4 id="普通加法"><a href="#普通加法" class="headerlink" title="普通加法"></a><strong>普通加法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    fun add(other: Point): Point &#123;</span><br><span class="line">        return Point(this.x + other.x, this.y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(2, 3)</span><br><span class="line">    val p2 = Point(4, 5)</span><br><span class="line">    val result = p1.add(p2)</span><br><span class="line"></span><br><span class="line">    println(&quot;($&#123;result.x&#125;, $&#123;result.y&#125;)&quot;) // 输出：(6, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="使用-infix-2"><a href="#使用-infix-2" class="headerlink" title="使用 infix"></a><strong>使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    infix fun add(other: Point): Point &#123;</span><br><span class="line">        return Point(this.x + other.x, this.y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(2, 3)</span><br><span class="line">    val p2 = Point(4, 5)</span><br><span class="line">    val result = p1 add p2  // 👈 重点：不需要 `.` 和 `()` 了！</span><br><span class="line"></span><br><span class="line">    println(&quot;($&#123;result.x&#125;, $&#123;result.y&#125;)&quot;) // 输出：(6, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <code>p1 add p2</code> <strong>比 <code>p1.add(p2)</code> 更像数学公式</strong>，可读性更强。</p><h4 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    infix fun Point.add(other: Point): Point &#123; //和正确例子唯一差别就是这一行</span><br><span class="line">        return Point(this.x + other.x, this.y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(2, 3)</span><br><span class="line">    val p2 = Point(4, 5)</span><br><span class="line">    val result = p1 add p2  // 👈 重点：不需要 . 和 () 了！</span><br><span class="line"></span><br><span class="line">    println(&quot;($&#123;result.x&#125;, $&#123;result.y&#125;)&quot;) // 输出：(6, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>不能编译</strong>，是因为 <strong>infix 函数不能在类内部对自身类型（<code>Point</code>）扩展</strong>。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><strong><code>infix</code> 让代码更像自然语言，增强可读性</strong>。</li><li><strong>只能用于</strong>：<ul><li><strong>类的成员函数</strong>（如 <code>Point</code> 里的 <code>add</code>）。</li><li><strong>扩展函数</strong>（如 <code>String.with()</code>）。</li><li><strong>且只接受一个参数</strong>。</li></ul></li><li><strong>调用时可以省略 <code>.</code> 和 <code>()</code></strong>，让代码更流畅。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide的基本用法</title>
      <link href="/2025/03/24/Glide%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-%E4%B8%80/"/>
      <url>/2025/03/24/Glide%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/guolin_blog/article/details/53759439">Glide用法一</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/53939176">Glide用法二</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/54895665">Glide用法三</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/70215985">Glide用法四</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/71524668">Glide用法五</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/72866313">Glide用法六</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/78357251">Glide用法七</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/78582548">Glide用法八</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Bitmap.createBitmap()用法示例</title>
      <link href="/2025/03/24/Android-Bitmap-createBitmap-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/24/Android-Bitmap-createBitmap-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-Bitmap-createBitmap-用法全解析"><a href="#Android-Bitmap-createBitmap-用法全解析" class="headerlink" title="Android Bitmap.createBitmap() 用法全解析"></a>Android Bitmap.createBitmap() 用法全解析</h1><p>在 Android 开发中，<code>Bitmap.createBitmap()</code> 是一个非常强大的方法，可以用来 <strong>创建新的位图</strong>，并且可以 <strong>进行旋转、缩放、平移、镜像翻转、裁剪等操作</strong>。本篇文章将详细介绍 <code>Bitmap.createBitmap()</code> 的各种用法。</p><hr><h2 id="1-Bitmap-createBitmap-基础用法"><a href="#1-Bitmap-createBitmap-基础用法" class="headerlink" title="1. Bitmap.createBitmap() 基础用法"></a>1. <code>Bitmap.createBitmap()</code> 基础用法</h2><h3 id="1-1-创建一个空白-Bitmap"><a href="#1-1-创建一个空白-Bitmap" class="headerlink" title="1.1 创建一个空白 Bitmap"></a><strong>1.1 创建一个空白 Bitmap</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)</span><br></pre></td></tr></table></figure><ul><li><code>width</code>：Bitmap 的宽度。</li><li><code>height</code>：Bitmap 的高度。</li><li><code>Bitmap.Config.ARGB_8888</code>：像素格式，支持透明度。</li></ul><blockquote><p><strong>用途</strong>：用于创建空白的 <code>Bitmap</code>，然后通过 <code>Canvas</code> 进行绘制。</p></blockquote><hr><h2 id="2-旋转（Rotate）"><a href="#2-旋转（Rotate）" class="headerlink" title="2. 旋转（Rotate）"></a>2. 旋转（Rotate）</h2><p>如果拍照后的图片方向不正确，可以使用 <code>Matrix</code> 进行旋转。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rotateBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, degree: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postRotate(degree.toFloat()) <span class="comment">// 旋转 degree 度</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>postRotate(degree)</code>：将图片旋转指定角度。</li></ul><p><strong>示例：旋转 90 度</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rotatedBitmap = rotateBitmap(originalBitmap, <span class="number">90</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="3-缩放（Scale）"><a href="#3-缩放（Scale）" class="headerlink" title="3. 缩放（Scale）"></a>3. 缩放（Scale）</h2><p>如果想要调整图片大小，可以使用 <code>postScale()</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scaleBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, sx: <span class="type">Float</span>, sy: <span class="type">Float</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postScale(sx, sy) <span class="comment">// 设置缩放比例</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：缩小 50%</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scaledBitmap = scaleBitmap(originalBitmap, <span class="number">0.5f</span>, <span class="number">0.5f</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="4-平移（Translate）"><a href="#4-平移（Translate）" class="headerlink" title="4. 平移（Translate）"></a>4. 平移（Translate）</h2><p>可以使用 <code>postTranslate()</code> 来移动 <code>Bitmap</code> 位置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">translateBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, dx: <span class="type">Float</span>, dy: <span class="type">Float</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postTranslate(dx, dy) <span class="comment">// X 方向右移 dx，Y 方向下移 dy</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：右移 50px，下移 100px</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> translatedBitmap = translateBitmap(originalBitmap, <span class="number">50f</span>, <span class="number">100f</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="5-镜像翻转（Flip）"><a href="#5-镜像翻转（Flip）" class="headerlink" title="5. 镜像翻转（Flip）"></a>5. 镜像翻转（Flip）</h2><h3 id="5-1-左右翻转（水平镜像）"><a href="#5-1-左右翻转（水平镜像）" class="headerlink" title="5.1 左右翻转（水平镜像）"></a><strong>5.1 左右翻转（水平镜像）</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">flipHorizontal</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postScale(-<span class="number">1f</span>, <span class="number">1f</span>) <span class="comment">// 水平方向镜像</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-上下翻转（垂直镜像）"><a href="#5-2-上下翻转（垂直镜像）" class="headerlink" title="5.2 上下翻转（垂直镜像）"></a><strong>5.2 上下翻转（垂直镜像）</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">flipVertical</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postScale(<span class="number">1f</span>, -<span class="number">1f</span>) <span class="comment">// 垂直方向镜像</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：左右翻转</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> flippedBitmap = flipHorizontal(originalBitmap)</span><br></pre></td></tr></table></figure><hr><h2 id="6-裁剪（Crop）"><a href="#6-裁剪（Crop）" class="headerlink" title="6. 裁剪（Crop）"></a>6. 裁剪（Crop）</h2><p>如果只想截取 <code>Bitmap</code> 的一部分，可以使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cropBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, x: <span class="type">Int</span>, y: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, x, y, width, height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：从 (50,50) 开始，裁剪 200x200 区域</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> croppedBitmap = cropBitmap(originalBitmap, <span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="7-综合变换：旋转-缩放-平移"><a href="#7-综合变换：旋转-缩放-平移" class="headerlink" title="7. 综合变换：旋转 + 缩放 + 平移"></a>7. 综合变换：旋转 + 缩放 + 平移</h2><p>可以组合多个变换，比如 <strong>先旋转 45°，再缩小 80%，然后平移</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transformBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postRotate(<span class="number">45f</span>)      <span class="comment">// 旋转 45 度</span></span><br><span class="line">    matrix.postScale(<span class="number">0.8f</span>, <span class="number">0.8f</span>) <span class="comment">// 缩小 80%</span></span><br><span class="line">    matrix.postTranslate(<span class="number">100f</span>, <span class="number">50f</span>) <span class="comment">// 右移 100，下移 50</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：应用组合变换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> transformedBitmap = transformBitmap(originalBitmap)</span><br></pre></td></tr></table></figure><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><table><thead><tr><th>操作</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td><strong>创建空白 Bitmap</strong></td><td><code>Bitmap.createBitmap(width, height, config)</code></td><td><code>Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888)</code></td></tr><tr><td><strong>旋转</strong></td><td><code>postRotate(degree)</code></td><td><code>postRotate(90f)</code></td></tr><tr><td><strong>缩放</strong></td><td><code>postScale(sx, sy)</code></td><td><code>postScale(0.5f, 0.5f)</code></td></tr><tr><td><strong>平移</strong></td><td><code>postTranslate(dx, dy)</code></td><td><code>postTranslate(50f, 100f)</code></td></tr><tr><td><strong>水平翻转</strong></td><td><code>postScale(-1f, 1f)</code></td><td><code>postScale(-1f, 1f)</code></td></tr><tr><td><strong>垂直翻转</strong></td><td><code>postScale(1f, -1f)</code></td><td><code>postScale(1f, -1f)</code></td></tr><tr><td><strong>裁剪</strong></td><td><code>Bitmap.createBitmap(bitmap, x, y, w, h)</code></td><td><code>Bitmap.createBitmap(bitmap, 50, 50, 200, 200)</code></td></tr></tbody></table><h3 id="📌-结论："><a href="#📌-结论：" class="headerlink" title="📌 结论："></a><strong>📌 结论：</strong></h3><p><code>Bitmap.createBitmap()</code> <strong>不仅能创建 Bitmap，还能旋转、缩放、平移、镜像翻转、裁剪，几乎所有图片变换都可以搞定！</strong> 🚀</p><p>希望这篇文章能帮你更好地理解 <code>Bitmap.createBitmap()</code> 的使用！ 😊</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通知的用法示例</title>
      <link href="/2025/03/24/%E9%80%9A%E7%9F%A5%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/24/%E9%80%9A%E7%9F%A5%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="Android-通知（Notification）完全指南"><a href="#Android-通知（Notification）完全指南" class="headerlink" title="Android 通知（Notification）完全指南"></a><strong>Android 通知（Notification）完全指南</strong></h2><h3 id="1-通知的作用"><a href="#1-通知的作用" class="headerlink" title="1. 通知的作用"></a><strong>1. 通知的作用</strong></h3><ul><li><strong>用户提示</strong>：告知用户重要事件，如新消息、下载进度等。</li><li><strong>交互入口</strong>：用户点击通知可跳转至应用的特定页面。</li><li><strong>持续展示</strong>：某些通知需要常驻状态栏，如后台任务提醒。</li></ul><hr><h3 id="2-关键组件"><a href="#2-关键组件" class="headerlink" title="2. 关键组件"></a><strong>2. 关键组件</strong></h3><ul><li><strong>NotificationManager</strong>：管理通知的发布、更新、取消。</li><li><strong>NotificationCompat.Builder</strong>：构建通知，确保兼容低版本 Android。</li><li><strong>NotificationChannel（Android 8.0+）</strong>：管理通知的重要性、声音、震动等。</li><li><strong>PendingIntent</strong>：设定用户点击通知后的操作。</li></ul><hr><h3 id="3-创建通知"><a href="#3-创建通知" class="headerlink" title="3. 创建通知"></a><strong>3. 创建通知</strong></h3><h4 id="3-0-权限"><a href="#3-0-权限" class="headerlink" title="3.0 权限"></a>3.0 权限</h4><p>在 <strong>AndroidManifest.xml</strong> 添加权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="3-1-创建通知频道（Android-8-0-必须）"><a href="#3-1-创建通知频道（Android-8-0-必须）" class="headerlink" title="3.1 创建通知频道（Android 8.0+ 必须）"></a><strong>3.1 创建通知频道（Android 8.0+ 必须）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    val channelId = &quot;channel_id_example&quot;</span><br><span class="line">    val channelName = &quot;通知频道&quot;</span><br><span class="line">    val importance = NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">    val channel = NotificationChannel(channelId, channelName, importance).apply &#123;</span><br><span class="line">        description = &quot;这个频道用于普通通知&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val notificationManager = getSystemService(NotificationManager::class.java)</span><br><span class="line">    notificationManager.createNotificationChannel(channel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-2-发送基础通知"><a href="#3-2-发送基础通知" class="headerlink" title="3.2 发送基础通知"></a><strong>3.2 发送基础通知</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val channelId = &quot;channel_id_example&quot;</span><br><span class="line">val builder = NotificationCompat.Builder(this, channelId)</span><br><span class="line">    .setSmallIcon(R.drawable.ic_notification)</span><br><span class="line">    .setContentTitle(&quot;通知标题&quot;)</span><br><span class="line">    .setContentText(&quot;通知内容&quot;)</span><br><span class="line">    .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line"></span><br><span class="line">val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager</span><br><span class="line">notificationManager.notify(1, builder.build())</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="4-添加交互（PendingIntent）"><a href="#4-添加交互（PendingIntent）" class="headerlink" title="4. 添加交互（PendingIntent）"></a><strong>4. 添加交互（PendingIntent）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, MainActivity::class.java)</span><br><span class="line">val pendingIntent = PendingIntent.getActivity(</span><br><span class="line">    this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">builder.setContentIntent(pendingIntent)</span><br><span class="line">       .setAutoCancel(true)  // 用户点击后自动清除通知</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="5-丰富通知内容（setStyle）"><a href="#5-丰富通知内容（setStyle）" class="headerlink" title="5. 丰富通知内容（setStyle）"></a><strong>5. 丰富通知内容（setStyle）</strong></h3><h4 id="5-1-长文本通知（BigTextStyle）"><a href="#5-1-长文本通知（BigTextStyle）" class="headerlink" title="5.1 长文本通知（BigTextStyle）"></a><strong>5.1 长文本通知（BigTextStyle）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.setStyle(NotificationCompat.BigTextStyle()</span><br><span class="line">    .bigText(&quot;这里是详细的通知内容，适合展示更多的文字信息&quot;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-2-大图通知（BigPictureStyle）"><a href="#5-2-大图通知（BigPictureStyle）" class="headerlink" title="5.2 大图通知（BigPictureStyle）"></a><strong>5.2 大图通知（BigPictureStyle）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val bigPicture = BitmapFactory.decodeResource(resources, R.drawable.big_image)</span><br><span class="line">builder.setStyle(NotificationCompat.BigPictureStyle()</span><br><span class="line">    .bigPicture(bigPicture)</span><br><span class="line">    .setBigContentTitle(&quot;大图通知&quot;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-3-多条信息通知（InboxStyle）"><a href="#5-3-多条信息通知（InboxStyle）" class="headerlink" title="5.3 多条信息通知（InboxStyle）"></a><strong>5.3 多条信息通知（InboxStyle）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">builder.setStyle(NotificationCompat.InboxStyle()</span><br><span class="line">    .addLine(&quot;第一条信息&quot;)</span><br><span class="line">    .addLine(&quot;第二条信息&quot;)</span><br><span class="line">    .setSummaryText(&quot;共2条信息&quot;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="6-高级用法"><a href="#6-高级用法" class="headerlink" title="6. 高级用法"></a><strong>6. 高级用法</strong></h3><ul><li><strong>自定义通知布局</strong>：使用 <code>RemoteViews</code> 创建个性化界面。</li><li><strong>前台服务通知</strong>：后台任务运行时显示不可清除的通知。</li><li><strong>分组通知</strong>：合并多个相关通知，减少干扰。</li></ul><hr><h3 id="7-重要注意事项"><a href="#7-重要注意事项" class="headerlink" title="7. 重要注意事项"></a><strong>7. 重要注意事项</strong></h3><ul><li><strong>Android 8.0+ 必须使用 NotificationChannel，否则通知不会显示。</strong></li><li><strong>使用 NotificationCompat 确保低版本 Android 兼容性。</strong></li><li><strong>合理管理通知，避免频繁弹出影响用户体验。</strong></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过 <strong>NotificationManager</strong> 发送通知，使用 <strong>PendingIntent</strong> 响应点击操作，并通过 <strong>setStyle</strong> 增强通知的可读性和交互性。在 Android 8.0 及以上版本，必须创建 <strong>NotificationChannel</strong>，确保通知正常显示。结合这些技巧，可以打造更优雅、实用的通知系统。 🚀</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ContentProvider+ContentResolver+UriMatcher+SQLite的用法示例</title>
      <link href="/2025/03/19/ContentProvider-ContentResolver-UriMatcher%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/19/ContentProvider-ContentResolver-UriMatcher%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>在 Android 中，数据共享是应用开发中非常重要的一部分。为了在不同应用之间共享数据，Android 提供了 <strong>ContentProvider</strong> 机制，通过该机制，应用能够访问其他应用的数据或向其他应用提供自己的数据。结合 <strong>SQLite</strong> 数据库、<strong>ContentProvider</strong>、<strong>ContentResolver</strong> 和 <strong>UriMatcher</strong>，我们可以方便地实现数据的持久化存储、查询、插入、更新和删除操作，同时还能够保证数据访问的安全性。</p><p>本文将介绍如何结合 <strong>SQLite</strong> 数据库、<strong>ContentProvider</strong>、<strong>ContentResolver</strong> 和 <strong>UriMatcher</strong> 实现一个完整的应用数据共享系统，并通过一个具体的示例进行详细说明。</p><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><h3 id="2-1-SQLite-数据库"><a href="#2-1-SQLite-数据库" class="headerlink" title="2.1 SQLite 数据库"></a>2.1 SQLite 数据库</h3><p>SQLite 是 Android 中推荐的本地数据库，它是一个轻量级的关系型数据库管理系统。SQLite 可以嵌入到应用中，支持 SQL 查询、数据持久化存储。</p><ul><li><strong>优点</strong>：开销小、无需服务器，适合单机应用。</li><li><strong>缺点</strong>：功能相对较简单，适用于小型应用和中小规模的数据存储。</li></ul><h3 id="2-2-ContentProvider"><a href="#2-2-ContentProvider" class="headerlink" title="2.2 ContentProvider"></a>2.2 ContentProvider</h3><p>ContentProvider 是一个提供数据存取接口的组件。它允许不同的应用共享数据，支持跨进程调用和跨应用访问。ContentProvider 通过 URI（统一资源标识符）来标识数据资源，并通过 SQL 查询操作来处理数据。</p><ul><li><strong>方法</strong>：<code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code>、<code>getType()</code> 等。</li><li><strong>作用</strong>：提供统一的接口，允许不同应用之间共享数据，避免直接暴露内部数据库结构。</li></ul><h3 id="2-3-ContentResolver"><a href="#2-3-ContentResolver" class="headerlink" title="2.3 ContentResolver"></a>2.3 ContentResolver</h3><p>ContentResolver 是一个访问 ContentProvider 的接口。通过 ContentResolver，我们可以向 ContentProvider 发起查询、插入、更新和删除操作。</p><ul><li><strong>方法</strong>：<code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code> 等。</li><li><strong>作用</strong>：通过 ContentResolver，应用可以操作 ContentProvider 中的数据，不需要知道数据存储的具体实现细节。</li><li><a href="https://goshenc.github.io/2025/03/17/ContentResolver%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/">ContentResolver的增删改查方法示例 | GoshenC</a></li></ul><h3 id="2-4-UriMatcher"><a href="#2-4-UriMatcher" class="headerlink" title="2.4 UriMatcher"></a>2.4 UriMatcher</h3><p>UriMatcher 是一个帮助 ContentProvider 匹配 URI 的工具，它根据 URI 的路径来判断进行操作的数据表或者数据项。通过 UriMatcher，我们可以根据传入的 URI 判断用户请求的是整个数据表的数据，还是某一条特定的数据记录。</p><ul><li><strong>作用</strong>：根据 URI 匹配不同的数据处理操作，帮助 ContentProvider 做出正确的响应。</li></ul><h3 id="2-5-概念及它们之间的关系"><a href="#2-5-概念及它们之间的关系" class="headerlink" title="2.5 概念及它们之间的关系"></a>2.5 概念及它们之间的关系</h3><ul><li><p><strong>ContentProvider</strong></p><ul><li><strong>作用</strong>：用于对外暴露应用的数据（例如 SQLite 数据库、文件等），支持跨进程或跨应用数据共享。</li><li><strong>关键方法</strong>：<code>onCreate()</code>（初始化）、<code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code>、<code>getType()</code>。</li></ul></li><li><p><strong>UriMatcher</strong></p><ul><li><strong>作用</strong>：帮助 ContentProvider 根据传入的 URI 判断需要操作的数据类型或数据集合。</li><li><strong>工作原理</strong>：预先注册一系列 URI 模式，每个模式对应一个整数代码；在请求时根据 URI 返回相应代码，以便在代码中进行判断和分支处理。</li></ul></li><li><p><strong>ContentResolver</strong></p><ul><li><p><strong>作用</strong>：作为数据访问者，由外部（或本应用内其他组件）调用，用于向 ContentProvider 发送数据操作请求（如查询、插入等）。</p></li><li><p>使用方式</p><p>：直接在 Activity、Service 等继承了 Context 的组件中调用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>这三者一起工作，实现了应用间（或应用内）的数据共享：</p><ol><li><strong>ContentResolver</strong> 发起请求，传入一个 URI。</li><li><strong>ContentProvider</strong> 通过内部的 <strong>UriMatcher</strong> 匹配 URI，判断请求的数据类型。</li><li>根据匹配结果，<strong>ContentProvider</strong> 调用相应的数据库操作，并返回数据（Cursor、Uri、影响行数等）。</li></ol><h2 id="3-使用-SQLite-ContentProvider-ContentResolver-UriMatcher-实现数据共享"><a href="#3-使用-SQLite-ContentProvider-ContentResolver-UriMatcher-实现数据共享" class="headerlink" title="3. 使用 SQLite + ContentProvider + ContentResolver + UriMatcher 实现数据共享"></a>3. 使用 SQLite + ContentProvider + ContentResolver + UriMatcher 实现数据共享</h2><h3 id="3-1-数据库实现"><a href="#3-1-数据库实现" class="headerlink" title="3.1 数据库实现"></a>3.1 数据库实现</h3><p>首先，我们需要创建一个 SQLite 数据库并定义数据表。下面是一个简单的 SQLiteOpenHelper 类，它管理一个名为 <code>diary</code> 的表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DiaryDatabaseHelper(context: Context) : SQLiteOpenHelper(context, &quot;DiaryDB&quot;, null, 1) &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase) &#123;</span><br><span class="line">        val createTableSQL = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE diary (</span><br><span class="line">                id INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                title TEXT,</span><br><span class="line">                date INTEGER,</span><br><span class="line">                content TEXT</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;.trimIndent()</span><br><span class="line">        db.execSQL(createTableSQL)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        db.execSQL(&quot;DROP TABLE IF EXISTS diary&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个数据库中，<code>diary</code> 表包含 <code>id</code>（主键）、<code>title</code>（标题）、<code>date</code>（日期）和 <code>content</code>（内容）等字段。</p><h3 id="3-2-ContentProvider-实现"><a href="#3-2-ContentProvider-实现" class="headerlink" title="3.2 ContentProvider 实现"></a>3.2 ContentProvider 实现</h3><p>接下来，我们要实现一个 ContentProvider，它将使用我们刚刚定义的数据库。通过 ContentProvider，外部应用可以通过 URI 来访问我们提供的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class DiaryProvider : ContentProvider() &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val AUTHORITY = &quot;com.example.providerdemo.diaryprovider&quot;</span><br><span class="line">        const val TABLE_DIARY = &quot;diary&quot;</span><br><span class="line">        val CONTENT_URI: Uri = Uri.parse(&quot;content://$AUTHORITY/$TABLE_DIARY&quot;)</span><br><span class="line">        const val DIARY_DIR = 1</span><br><span class="line">        const val DIARY_ITEM = 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private lateinit var dbHelper: DiaryDatabaseHelper</span><br><span class="line">    private val uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply &#123;</span><br><span class="line">        addURI(AUTHORITY, TABLE_DIARY, DIARY_DIR)</span><br><span class="line">        </span><br><span class="line">  /*DIARY_Dir是一个整数值，用来标识这个 URI 模式对应的操作。在后面的 ContentProvider 中，我们会使用这个整数值来确定执行哪些操作（例如查询、插入、更新、删除等）。DIARY_1Dir 是你在代码中定义的常量。比如后面的return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt;...&#125;*/</span><br><span class="line">            </span><br><span class="line">        addURI(AUTHORITY, &quot;$TABLE_DIARY/#&quot;, DIARY_ITEM)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(): Boolean &#123;</span><br><span class="line">        dbHelper = DiaryDatabaseHelper(context!!)</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun query(uri: Uri, projection: Array&lt;String&gt;?, selection: String?, selectionArgs: Array&lt;String&gt;?, sortOrder: String?): Cursor? &#123;</span><br><span class="line">        val db = dbHelper.readableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; db.query(TABLE_DIARY, projection, selection, selectionArgs, null, null, sortOrder)</span><br><span class="line">            DIARY_ITEM -&gt; &#123;</span><br><span class="line">                val id = uri.lastPathSegment</span><br><span class="line">                db.query(TABLE_DIARY, projection, &quot;id=?&quot;, arrayOf(id), null, null, sortOrder)</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun insert(uri: Uri, values: ContentValues?): Uri? &#123;</span><br><span class="line">        val db = dbHelper.writableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; &#123;</span><br><span class="line">                val id = db.insert(TABLE_DIARY, null, values)</span><br><span class="line">                Uri.withAppendedPath(CONTENT_URI, id.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun update(uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array&lt;String&gt;?): Int &#123;</span><br><span class="line">        val db = dbHelper.writableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; db.update(TABLE_DIARY, values, selection, selectionArgs)</span><br><span class="line">            DIARY_ITEM -&gt; &#123;</span><br><span class="line">                val id = uri.lastPathSegment</span><br><span class="line">                db.update(TABLE_DIARY, values, &quot;id=?&quot;, arrayOf(id))</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun delete(uri: Uri, selection: String?, selectionArgs: Array&lt;String&gt;?): Int &#123;</span><br><span class="line">        val db = dbHelper.writableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; db.delete(TABLE_DIARY, selection, selectionArgs)</span><br><span class="line">            DIARY_ITEM -&gt; &#123;</span><br><span class="line">                val id = uri.lastPathSegment</span><br><span class="line">                db.delete(TABLE_DIARY, &quot;id=?&quot;, arrayOf(id))</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getType(uri: Uri): String? &#123;</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; &quot;vnd.android.cursor.dir/vnd.$AUTHORITY.$TABLE_DIARY&quot;</span><br><span class="line">            DIARY_ITEM -&gt; &quot;vnd.android.cursor.item/vnd.$AUTHORITY.$TABLE_DIARY&quot;</span><br><span class="line">            else -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-UriMatcher-配置"><a href="#3-3-UriMatcher-配置" class="headerlink" title="3.3 UriMatcher 配置"></a>3.3 UriMatcher 配置</h3><p>在 ContentProvider 中，我们使用 UriMatcher 来判断传入的 URI 属于哪个类型。UriMatcher 会匹配表名（<code>diary</code>）或者某个具体的记录（通过 ID 来识别）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply &#123;</span><br><span class="line">    addURI(AUTHORITY, TABLE_DIARY, DIARY_DIR) // 匹配整个 diary 表</span><br><span class="line">    addURI(AUTHORITY, &quot;$TABLE_DIARY/#&quot;, DIARY_ITEM) // 匹配单条 diary 记录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>DIARY_DIR</strong>：匹配整个表的 URI。</li><li><strong>DIARY_ITEM</strong>：匹配单条数据记录的 URI，带有 <code>#</code> 通配符，表示记录的 ID。</li></ul><h3 id="3-4-ContentResolver-的使用"><a href="#3-4-ContentResolver-的使用" class="headerlink" title="3.4 ContentResolver 的使用"></a>3.4 ContentResolver 的使用</h3><p>ContentResolver 是外部应用用来访问 ContentProvider 的接口。在外部应用中，我们可以通过 ContentResolver 来执行查询、插入、更新和删除操作。例如，查询所有标题包含“心情”的日记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//构造 content:// 开头的 Uri，它用于标识数据库中的某条数据。</span><br><span class="line">val uri = Uri.parse(&quot;content://com.example.providerdemo.diaryprovider/diary&quot;)</span><br><span class="line">val projection = arrayOf(&quot;id&quot;, &quot;title&quot;, &quot;date&quot;, &quot;content&quot;)</span><br><span class="line">val selection = &quot;title LIKE ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;%心情%&quot;)</span><br><span class="line">val sortOrder = &quot;date DESC&quot;</span><br><span class="line"></span><br><span class="line">// 查询操作</span><br><span class="line">val cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)</span><br><span class="line">cursor?.use &#123;</span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val id = it.getInt(it.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val title = it.getString(it.getColumnIndexOrThrow(&quot;title&quot;))</span><br><span class="line">        val date = it.getLong(it.getColumnIndexOrThrow(&quot;date&quot;))</span><br><span class="line">        val content = it.getString(it.getColumnIndexOrThrow(&quot;content&quot;))</span><br><span class="line">        println(&quot;ID: $id, Title: $title, Date: $date, Content: $content&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过结合 <strong>SQLite</strong> 数据库、<strong>ContentProvider</strong>、<strong>ContentResolver</strong> 和 <strong>UriMatcher</strong>，我们可以实现一个完整的跨应用数据共享机制。ContentProvider 作为数据提供者，向外部应用提供访问接口，ContentResolver 则充当请求者的角色，发起查询、插入、更新和删除等操作，UriMatcher 则帮助我们根据 URI 匹配具体的数据操作。</p><p>这种架构不仅保证了数据共享的高效性和安全性，同时还使得应用内部数据管理变得更加清晰和规范。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecycleView使用示例</title>
      <link href="/2025/03/17/RecycleView%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/17/RecycleView%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="🚀-RecyclerView-进阶优化指南"><a href="#🚀-RecyclerView-进阶优化指南" class="headerlink" title="🚀 RecyclerView 进阶优化指南"></a><strong>🚀 RecyclerView 进阶优化指南</strong></h1><p>相比之前的版本，这次的改进包括：</p><ul><li>✅ <strong>使用 <code>DiffUtil</code> 优化数据更新</strong>（避免 <code>notifyDataSetChanged()</code>）</li><li>✅ <strong>使用 <code>ViewBinding</code> 简化 <code>ViewHolder</code> 代码</strong></li><li>✅ <strong>封装 <code>Adapter</code> 支持 <code>MutableList</code>（支持增删改查）</strong></li><li>✅ <strong>优化 <code>onClick</code> 事件，让 <code>RecyclerView</code> 更易扩展</strong></li><li>✅ <strong>支持 Grid&#x2F;瀑布流&#x2F;线性布局</strong></li></ul><hr><h2 id="1️⃣-添加-RecyclerView-依赖"><a href="#1️⃣-添加-RecyclerView-依赖" class="headerlink" title="1️⃣ 添加 RecyclerView 依赖"></a><strong>1️⃣ 添加 RecyclerView 依赖</strong></h2><p>确保你的 <code>build.gradle</code> 添加了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;androidx.recyclerview:recyclerview:1.3.2&#x27;</span><br><span class="line">    implementation &#x27;androidx.viewbinding:viewbinding:7.3.1&#x27; // 使用 ViewBinding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-在-activity-main-xml-中添加-RecyclerView"><a href="#2️⃣-在-activity-main-xml-中添加-RecyclerView" class="headerlink" title="2️⃣ 在 activity_main.xml 中添加 RecyclerView"></a><strong>2️⃣ 在 <code>activity_main.xml</code> 中添加 <code>RecyclerView</code></strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">    android:id=&quot;@+id/recyclerView&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;/&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="3️⃣-创建数据模型"><a href="#3️⃣-创建数据模型" class="headerlink" title="3️⃣ 创建数据模型"></a><strong>3️⃣ 创建数据模型</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data class Diary(</span><br><span class="line">    val id: Int,         // 方便更新和删除</span><br><span class="line">    val title: String,  </span><br><span class="line">    val content: String, </span><br><span class="line">    val date: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="4️⃣-使用-DiffUtil-优化-Adapter"><a href="#4️⃣-使用-DiffUtil-优化-Adapter" class="headerlink" title="4️⃣ 使用 DiffUtil 优化 Adapter"></a><strong>4️⃣ 使用 <code>DiffUtil</code> 优化 <code>Adapter</code></strong></h2><p>🚀 <code>DiffUtil</code> 可以高效更新 <code>RecyclerView</code>，避免全量刷新，提高性能。</p><h3 id="创建-DiaryDiffCallback"><a href="#创建-DiaryDiffCallback" class="headerlink" title="创建 DiaryDiffCallback"></a><strong>创建 <code>DiaryDiffCallback</code></strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class DiaryDiffCallback(</span><br><span class="line">    private val oldList: List&lt;Diary&gt;,</span><br><span class="line">    private val newList: List&lt;Diary&gt;</span><br><span class="line">) : DiffUtil.Callback() &#123;</span><br><span class="line">    </span><br><span class="line">    override fun getOldListSize(): Int = oldList.size</span><br><span class="line">    override fun getNewListSize(): Int = newList.size</span><br><span class="line"></span><br><span class="line">    // 判断是否是同一项（通常比较 ID）</span><br><span class="line">    override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean &#123;</span><br><span class="line">        return oldList[oldItemPosition].id == newList[newItemPosition].id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断内容是否相同（避免不必要的刷新）</span><br><span class="line">    override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean &#123;</span><br><span class="line">        return oldList[oldItemPosition] == newList[newItemPosition]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5️⃣-优化-Adapter（使用-ViewBinding）"><a href="#5️⃣-优化-Adapter（使用-ViewBinding）" class="headerlink" title="5️⃣ 优化 Adapter（使用 ViewBinding）"></a><strong>5️⃣ 优化 <code>Adapter</code>（使用 <code>ViewBinding</code>）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class DiaryAdapter(</span><br><span class="line">    private var diaryList: MutableList&lt;Diary&gt;, // 让数据可变</span><br><span class="line">    private val onItemClick: (Diary) -&gt; Unit</span><br><span class="line">) : RecyclerView.Adapter&lt;DiaryAdapter.DiaryViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    // 使用 ViewBinding 简化 ViewHolder</span><br><span class="line">    class DiaryViewHolder(val binding: ItemDiaryBinding) : RecyclerView.ViewHolder(binding.root)</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): DiaryViewHolder &#123;</span><br><span class="line">        val binding = ItemDiaryBinding.inflate(LayoutInflater.from(parent.context), parent, false)</span><br><span class="line">        return DiaryViewHolder(binding)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: DiaryViewHolder, position: Int) &#123;</span><br><span class="line">        val diary = diaryList[position]</span><br><span class="line">        with(holder.binding) &#123;</span><br><span class="line">            tvTitle.text = diary.title</span><br><span class="line">            tvContent.text = diary.content</span><br><span class="line">            tvDate.text = diary.date</span><br><span class="line">            root.setOnClickListener &#123; onItemClick(diary) &#125; // 处理点击事件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getItemCount(): Int = diaryList.size</span><br><span class="line"></span><br><span class="line">    // 🚀 使用 DiffUtil 刷新数据，避免全量刷新</span><br><span class="line">    fun updateData(newList: List&lt;Diary&gt;) &#123;</span><br><span class="line">        val diffResult = DiffUtil.calculateDiff(DiaryDiffCallback(diaryList, newList))</span><br><span class="line">        diaryList.clear()</span><br><span class="line">        diaryList.addAll(newList)</span><br><span class="line">        diffResult.dispatchUpdatesTo(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 增删改查方法</span><br><span class="line">    fun addDiary(diary: Diary) &#123;</span><br><span class="line">        diaryList.add(0, diary)  // 插入到第一个位置</span><br><span class="line">        notifyItemInserted(0)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun removeDiary(position: Int) &#123;</span><br><span class="line">        if (position in diaryList.indices) &#123;</span><br><span class="line">            diaryList.removeAt(position)</span><br><span class="line">            notifyItemRemoved(position)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6️⃣-创建-item-diary-xml"><a href="#6️⃣-创建-item-diary-xml" class="headerlink" title="6️⃣ 创建 item_diary.xml"></a><strong>6️⃣ 创建 <code>item_diary.xml</code></strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;</span><br><span class="line">    android:background=&quot;@android:color/white&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tvTitle&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;18sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/black&quot;</span><br><span class="line">        android:textStyle=&quot;bold&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tvContent&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;16sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/darker_gray&quot;</span><br><span class="line">        android:maxLines=&quot;2&quot;</span><br><span class="line">        android:ellipsize=&quot;end&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tvDate&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;14sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/holo_blue_dark&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="7️⃣-在-MainActivity-绑定-RecyclerView"><a href="#7️⃣-在-MainActivity-绑定-RecyclerView" class="headerlink" title="7️⃣ 在 MainActivity 绑定 RecyclerView"></a><strong>7️⃣ 在 <code>MainActivity</code> 绑定 <code>RecyclerView</code></strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    </span><br><span class="line">    private lateinit var recyclerView: RecyclerView</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        recyclerView = findViewById(R.id.recyclerView)</span><br><span class="line">        recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line"></span><br><span class="line">        // 初始数据</span><br><span class="line">        val diaryList = mutableListOf(</span><br><span class="line">            Diary(1, &quot;今日心情&quot;, &quot;今天天气很好，心情愉快！&quot;, &quot;2025-03-17&quot;),</span><br><span class="line">            Diary(2, &quot;学习 Kotlin&quot;, &quot;RecyclerView 真的很好用！&quot;, &quot;2025-03-16&quot;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // 绑定 Adapter</span><br><span class="line">        diaryAdapter = DiaryAdapter(diaryList) &#123; diary -&gt;</span><br><span class="line">            Toast.makeText(this, &quot;点击了: $&#123;diary.title&#125;&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        recyclerView.adapter = diaryAdapter</span><br><span class="line"></span><br><span class="line">        // 模拟 3 秒后刷新数据</span><br><span class="line">        Handler(Looper.getMainLooper()).postDelayed(&#123;</span><br><span class="line">            val newData = diaryList + Diary(3, &quot;记账&quot;, &quot;今天吃了火锅，花了 120 元&quot;, &quot;2025-03-15&quot;)</span><br><span class="line">            diaryAdapter.updateData(newData)</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8️⃣-可选优化"><a href="#8️⃣-可选优化" class="headerlink" title="8️⃣ 可选优化"></a><strong>8️⃣ 可选优化</strong></h2><h3 id="（1）网格布局"><a href="#（1）网格布局" class="headerlink" title="（1）网格布局"></a><strong>（1）网格布局</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.layoutManager = GridLayoutManager(this, 2) // 2 列</span><br></pre></td></tr></table></figure><h3 id="（2）瀑布流布局"><a href="#（2）瀑布流布局" class="headerlink" title="（2）瀑布流布局"></a><strong>（2）瀑布流布局</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-总结"><a href="#🎯-总结" class="headerlink" title="🎯 总结"></a><strong>🎯 总结</strong></h2><table><thead><tr><th>改进点</th><th>说明</th></tr></thead><tbody><tr><td>✅ <strong>使用 <code>DiffUtil</code></strong></td><td><strong>优化数据更新</strong>，避免 <code>notifyDataSetChanged()</code></td></tr><tr><td>✅ <strong>使用 <code>ViewBinding</code></strong></td><td><strong>减少 <code>findViewById</code> 代码</strong>，提高可读性</td></tr><tr><td>✅ <strong>封装增删改查方法</strong></td><td><code>addDiary()</code> 和 <code>removeDiary()</code></td></tr><tr><td>✅ <strong>支持 <code>MutableList</code></strong></td><td><strong>让数据可变</strong>，更方便操作</td></tr><tr><td>✅ <strong>支持 Grid&#x2F;瀑布流布局</strong></td><td><strong>适配不同 UI 需求</strong></td></tr></tbody></table><hr><p>🚀 <strong>这样写的 <code>RecyclerView</code> 更高效、更易扩展！你可以直接用在 Kotlin 日记本 App 里。</strong> 🎉</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ContentResolver的增删改查方法示例</title>
      <link href="/2025/03/17/ContentResolver%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/17/ContentResolver%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-中-ContentResolver-的增删改查详解"><a href="#Android-中-ContentResolver-的增删改查详解" class="headerlink" title="Android 中 ContentResolver 的增删改查详解"></a><strong>Android 中 <code>ContentResolver</code> 的增删改查详解</strong></h2><p><code>ContentResolver</code> 是 Android 提供的 API，用于在不同应用程序之间访问和操作数据，通常与 <code>ContentProvider</code> 一起使用。它提供 <strong>增（insert）、删（delete）、改（update）、查（query）</strong> 操作，常见于访问系统数据库（如通讯录、媒体库等）或应用自定义的数据库（如日记本、笔记等）。</p><hr><h2 id="📌-使用-ContentResolver-的步骤"><a href="#📌-使用-ContentResolver-的步骤" class="headerlink" title="📌 使用 ContentResolver 的步骤"></a><strong>📌 使用 <code>ContentResolver</code> 的步骤</strong></h2><ol><li><strong>确定 <code>ContentProvider</code> 提供的数据 URI</strong>（<code>content://</code> 格式）</li><li><strong>获取 <code>ContentResolver</code></strong> 对象</li><li><strong>执行增、删、改、查操作</strong></li><li><strong>处理权限（如果是访问系统数据）</strong></li><li><strong>关闭 <code>Cursor</code> 以释放资源（仅 <code>query</code> 需要）</strong></li></ol><hr><h2 id="💡-1-获取-ContentResolver"><a href="#💡-1-获取-ContentResolver" class="headerlink" title="💡 1. 获取 ContentResolver"></a><strong>💡 1. 获取 <code>ContentResolver</code></strong></h2><p>在 <code>Activity</code> 或 <code>Fragment</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val contentResolver = context.contentResolver</span><br></pre></td></tr></table></figure><p>在 <code>Service</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val contentResolver = applicationContext.contentResolver</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-2-查询数据（query）"><a href="#🔍-2-查询数据（query）" class="headerlink" title="🔍 2. 查询数据（query）"></a><strong>🔍 2. 查询数据（query）</strong></h2><p>查询 <code>ContentProvider</code> 提供的数据，返回 <code>Cursor</code>，需手动遍历和关闭。</p><h3 id="示例：查询日记"><a href="#示例：查询日记" class="headerlink" title="示例：查询日记"></a><strong>示例：查询日记</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 1. 目标 ContentProvider 的 URI</span><br><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line">//构造 content:// 开头的 Uri，它用于标识数据库中的某条数据。</span><br><span class="line"></span><br><span class="line">// 2. 查询的字段（列）</span><br><span class="line">val projection = arrayOf(&quot;id&quot;, &quot;title&quot;, &quot;date&quot;)</span><br><span class="line"></span><br><span class="line">// 3. 查询条件（WHERE）</span><br><span class="line">val selection = &quot;title LIKE ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;%心情%&quot;) // 查询包含“心情”的日记</span><br><span class="line">//这表示查询 title 列，要求 title 的内容包含“心情”两个字。</span><br><span class="line">//LIKE 是 SQL 语法，用于进行模糊查询。</span><br><span class="line">//? 是占位符，用来防止 SQL 注入，具体值由 selectionArgs 提供。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 4. 排序方式</span><br><span class="line">val sortOrder = &quot;date DESC&quot;</span><br><span class="line"></span><br><span class="line">// 5. 执行查询</span><br><span class="line">val cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)</span><br><span class="line"></span><br><span class="line">cursor?.use &#123; </span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val id = it.getInt(it.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val title = it.getString(it.getColumnIndexOrThrow(&quot;title&quot;))</span><br><span class="line">        val date = it.getLong(it.getColumnIndexOrThrow(&quot;date&quot;))</span><br><span class="line">        println(&quot;ID: $id, Title: $title, Date: $date&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // `use` 语法确保 Cursor 关闭</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li>查询时使用 <code>LIKE</code> 支持模糊匹配，<code>?</code> 代表参数占位符</li><li>使用 <code>Cursor</code> 需要调用 <code>.moveToNext()</code> 逐行读取</li><li>关闭 <code>Cursor</code> 以释放资源</li></ul><hr><h2 id="📝-3-插入数据（insert）"><a href="#📝-3-插入数据（insert）" class="headerlink" title="📝 3. 插入数据（insert）"></a><strong>📝 3. 插入数据（insert）</strong></h2><p>用于新增数据，返回新数据的 <code>Uri</code>。</p><h3 id="示例：新增日记"><a href="#示例：新增日记" class="headerlink" title="示例：新增日记"></a><strong>示例：新增日记</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line"></span><br><span class="line">// 1. 创建 ContentValues，存储字段和值</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(&quot;title&quot;, &quot;今日心情&quot;)</span><br><span class="line">    put(&quot;content&quot;, &quot;今天是个好天气&quot;)</span><br><span class="line">    put(&quot;date&quot;, System.currentTimeMillis())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 调用 insert 方法</span><br><span class="line">val newUri = contentResolver.insert(uri, values)</span><br><span class="line"></span><br><span class="line">// 3. 判断插入结果</span><br><span class="line">if (newUri != null) &#123;</span><br><span class="line">    println(&quot;插入成功，URI: $newUri&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;插入失败&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li><code>ContentValues</code> 类似 <code>Map</code>，用于存储字段和值</li><li><code>insert()</code> 返回新数据的 <code>Uri</code>，失败时返回 <code>null</code></li><li>newUri:表示新插入的数据的 <strong>URI</strong>，用于后续操作。如果插入失败，返回 <code>null</code>。</li></ul><hr><h2 id="✏-4-更新数据（update）"><a href="#✏-4-更新数据（update）" class="headerlink" title="✏ 4. 更新数据（update）"></a><strong>✏ 4. 更新数据（update）</strong></h2><p>用于修改已有数据，返回影响的行数。</p><h3 id="示例：更新日记内容"><a href="#示例：更新日记内容" class="headerlink" title="示例：更新日记内容"></a><strong>示例：更新日记内容</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line"></span><br><span class="line">// 1. 创建 ContentValues，存储更新的字段和值</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(&quot;content&quot;, &quot;更新后的日记内容&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 更新条件</span><br><span class="line">val selection = &quot;id = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;) // 只更新 ID 为 1 的日记</span><br><span class="line"></span><br><span class="line">// 3. 执行 update</span><br><span class="line">val rowsUpdated = contentResolver.update(uri, values, selection, selectionArgs)</span><br><span class="line"></span><br><span class="line">println(&quot;更新了 $rowsUpdated 条数据&quot;)</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li><code>selection</code> 是 SQL 语法的 <code>WHERE</code> 子句</li><li><code>update()</code> 返回更新的行数，可能为 <code>0</code>（表示数据未找到）</li></ul><hr><h2 id="🗑-5-删除数据（delete）"><a href="#🗑-5-删除数据（delete）" class="headerlink" title="🗑 5. 删除数据（delete）"></a><strong>🗑 5. 删除数据（delete）</strong></h2><p>用于删除数据，返回删除的行数。</p><h3 id="示例：删除指定日记"><a href="#示例：删除指定日记" class="headerlink" title="示例：删除指定日记"></a><strong>示例：删除指定日记</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line"></span><br><span class="line">// 1. 删除条件</span><br><span class="line">val selection = &quot;id = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;) // 只删除 ID 为 1 的日记</span><br><span class="line"></span><br><span class="line">// 2. 执行删除</span><br><span class="line">val rowsDeleted = contentResolver.delete(uri, selection, selectionArgs)</span><br><span class="line"></span><br><span class="line">println(&quot;删除了 $rowsDeleted 条数据&quot;)</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li><code>delete()</code> 返回删除的行数</li><li>不提供 <code>selection</code> 则删除所有数据（谨慎）</li></ul><hr><h2 id="📖-6-访问系统-ContentProvider-示例"><a href="#📖-6-访问系统-ContentProvider-示例" class="headerlink" title="📖 6. 访问系统 ContentProvider 示例"></a><strong>📖 6. 访问系统 <code>ContentProvider</code> 示例</strong></h2><h3 id="📌-读取联系人"><a href="#📌-读取联系人" class="headerlink" title="📌 读取联系人"></a><strong>📌 读取联系人</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI</span><br><span class="line">val cursor = contentResolver.query(uri, null, null, null, null)</span><br><span class="line"></span><br><span class="line">cursor?.use &#123;</span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val name = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME))</span><br><span class="line">        val phone = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.NUMBER))</span><br><span class="line">        println(&quot;联系人: $name, 电话: $phone&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="📌-读取相册"><a href="#📌-读取相册" class="headerlink" title="📌 读取相册"></a><strong>📌 读取相册</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI</span><br><span class="line">val projection = arrayOf(MediaStore.Images.Media.DATA)</span><br><span class="line">val cursor = contentResolver.query(uri, projection, null, null, null)</span><br><span class="line"></span><br><span class="line">cursor?.use &#123;</span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val imagePath = it.getString(it.getColumnIndexOrThrow(MediaStore.Images.Media.DATA))</span><br><span class="line">        println(&quot;图片路径: $imagePath&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔒-7-处理权限"><a href="#🔒-7-处理权限" class="headerlink" title="🔒 7. 处理权限"></a><strong>🔒 7. 处理权限</strong></h2><p><strong>如果访问系统 <code>ContentProvider</code>（如通讯录、相册等），需申请权限</strong>：</p><h3 id="在-AndroidManifest-xml-申请权限"><a href="#在-AndroidManifest-xml-申请权限" class="headerlink" title="在 AndroidManifest.xml 申请权限"></a><strong>在 <code>AndroidManifest.xml</code> 申请权限</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="动态请求权限（Android-6-0-）"><a href="#动态请求权限（Android-6-0-）" class="headerlink" title="动态请求权限（Android 6.0+）"></a><strong>动态请求权限（Android 6.0+）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.READ_CONTACTS), 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a><strong>📌 总结</strong></h2><table><thead><tr><th>操作</th><th>方法名</th><th>主要参数</th></tr></thead><tbody><tr><td><strong>查询</strong></td><td><code>query(uri, projection, selection, selectionArgs, sortOrder)</code></td><td><code>Uri</code>，字段数组，查询条件，排序</td></tr><tr><td><strong>插入</strong></td><td><code>insert(uri, values)</code></td><td><code>Uri</code>，<code>ContentValues</code></td></tr><tr><td><strong>更新</strong></td><td><code>update(uri, values, selection, selectionArgs)</code></td><td><code>Uri</code>，<code>ContentValues</code>，条件</td></tr><tr><td><strong>删除</strong></td><td><code>delete(uri, selection, selectionArgs)</code></td><td><code>Uri</code>，条件</td></tr></tbody></table><p><strong>💡 你是要操作自己的 <code>ContentProvider</code> 还是访问系统数据？如果是日记本的 <code>ContentProvider</code>，可以一起设计 URI 和数据库结构。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite用法</title>
      <link href="/2025/03/15/SQLite%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/SQLite%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>SQLite 是一种轻量级的嵌入式数据库，在 Android 中用于存储结构化数据。你可以通过 <code>SQLiteOpenHelper</code> 来管理数据库的创建、升级、和版本管理。以下是使用 SQLite 的基本步骤：</p><h2 id="1-创建数据库和表"><a href="#1-创建数据库和表" class="headerlink" title="1. 创建数据库和表"></a><strong>1. 创建数据库和表</strong></h2><p>使用 <code>SQLiteOpenHelper</code> 创建数据库以及表结构。这个类会帮助你创建数据库、执行表的升级、降级等操作。</p><h3 id="创建-SQLiteOpenHelper-类"><a href="#创建-SQLiteOpenHelper-类" class="headerlink" title="创建 SQLiteOpenHelper 类"></a><strong>创建 SQLiteOpenHelper 类</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import android.database.sqlite.SQLiteDatabase</span><br><span class="line">import android.database.sqlite.SQLiteOpenHelper</span><br><span class="line"></span><br><span class="line">class MyDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private const val DATABASE_NAME = &quot;my_database.db&quot; // 数据库名称</span><br><span class="line">        private const val DATABASE_VERSION = 1 // 数据库版本号</span><br><span class="line">        private const val TABLE_NAME = &quot;users&quot; // 表名称</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase) &#123;</span><br><span class="line">        // 创建数据库表</span><br><span class="line">        val createTableQuery = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE $TABLE_NAME (</span><br><span class="line">                id INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                name TEXT NOT NULL,</span><br><span class="line">                age INTEGER</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;.trimIndent()</span><br><span class="line">        db.execSQL(createTableQuery)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        // 如果数据库版本变化时，删除旧表并创建新表</span><br><span class="line">        db.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NAME&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>onCreate</code></strong>：当数据库首次创建时执行。通常在这里创建表和初始化数据。</li><li><strong><code>onUpgrade</code></strong>：当数据库版本发生变化时执行。你可以在这里进行表的迁移或删除。</li></ul><h2 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2. 插入数据"></a><strong>2. 插入数据</strong></h2><p>插入数据需要通过 <code>SQLiteDatabase.insert()</code> 方法来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import android.content.ContentValues</span><br><span class="line"></span><br><span class="line">fun insertUser(context: Context, name: String, age: Int) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val values = ContentValues().apply &#123;</span><br><span class="line">        put(&quot;name&quot;, name)</span><br><span class="line">        put(&quot;age&quot;, age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    db.insert(&quot;users&quot;, null, values)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>ContentValues</code></strong>：是用于存储要插入的数据的容器。通过 <code>put</code> 方法将列名和值添加到 <code>ContentValues</code> 中。</li><li><strong><code>insert</code></strong>：插入数据的方法，第一个参数是表名，第二个参数是列为空时插入的默认值，第三个参数是 <code>ContentValues</code>。</li></ul><h2 id="3-查询数据"><a href="#3-查询数据" class="headerlink" title="3. 查询数据"></a><strong>3. 查询数据</strong></h2><p>查询数据使用 <code>SQLiteDatabase.query()</code> 或 <code>SQLiteDatabase.rawQuery()</code> 方法。</p><h3 id="使用-query-方法"><a href="#使用-query-方法" class="headerlink" title="使用 query() 方法"></a>使用 <code>query()</code> 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import android.database.Cursor</span><br><span class="line"></span><br><span class="line">fun queryUsers(context: Context): List&lt;User&gt; &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.readableDatabase</span><br><span class="line"></span><br><span class="line">    val cursor: Cursor = db.query(</span><br><span class="line">        &quot;users&quot;, // 表名</span><br><span class="line">        arrayOf(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;), // 列名</span><br><span class="line">        null, // WHERE 子句</span><br><span class="line">        null, // WHERE 子句的参数</span><br><span class="line">        null, // GROUP BY 子句</span><br><span class="line">        null, // HAVING 子句</span><br><span class="line">        null // ORDER BY 子句</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val users = mutableListOf&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    while (cursor.moveToNext()) &#123;</span><br><span class="line">        val id = cursor.getLong(cursor.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val name = cursor.getString(cursor.getColumnIndexOrThrow(&quot;name&quot;))</span><br><span class="line">        val age = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;age&quot;))</span><br><span class="line"></span><br><span class="line">        users.add(User(id, name, age))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    return users</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data class User(val id: Long, val name: String, val age: Int)</span><br></pre></td></tr></table></figure><ul><li><strong><code>query</code></strong>：用于查询数据库，返回一个 <code>Cursor</code> 对象。你可以通过 <code>Cursor</code> 遍历结果集。</li><li><strong><code>getColumnIndexOrThrow()</code></strong>：根据列名获取列的索引，<code>getString()</code>, <code>getInt()</code> 等方法用于提取数据。</li></ul><h3 id="使用-rawQuery-方法"><a href="#使用-rawQuery-方法" class="headerlink" title="使用 rawQuery() 方法"></a>使用 <code>rawQuery()</code> 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun queryUsersRaw(context: Context): List&lt;User&gt; &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.readableDatabase</span><br><span class="line"></span><br><span class="line">    val cursor: Cursor = db.rawQuery(&quot;SELECT * FROM users&quot;, null)</span><br><span class="line"></span><br><span class="line">    val users = mutableListOf&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    while (cursor.moveToNext()) &#123;</span><br><span class="line">        val id = cursor.getLong(cursor.getColumnIndex(&quot;id&quot;))</span><br><span class="line">        val name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;))</span><br><span class="line">        val age = cursor.getInt(cursor.getColumnIndex(&quot;age&quot;))</span><br><span class="line"></span><br><span class="line">        users.add(User(id, name, age))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    return users</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>rawQuery()</code></strong>：执行原始的 SQL 查询语句，返回一个 <code>Cursor</code>。</li></ul><h2 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4. 更新数据"></a><strong>4. 更新数据</strong></h2><p>更新数据使用 <code>SQLiteDatabase.update()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import android.content.ContentValues</span><br><span class="line"></span><br><span class="line">fun updateUser(context: Context, id: Long, name: String, age: Int) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val values = ContentValues().apply &#123;</span><br><span class="line">        put(&quot;name&quot;, name)</span><br><span class="line">        put(&quot;age&quot;, age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val selection = &quot;id = ?&quot;</span><br><span class="line">    val selectionArgs = arrayOf(id.toString())</span><br><span class="line"></span><br><span class="line">    db.update(&quot;users&quot;, values, selection, selectionArgs)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>update()</code></strong>：更新数据的方法。第一个参数是表名，第二个参数是更新的值，第三个参数是 <code>WHERE</code> 子句，第四个参数是 <code>WHERE</code> 子句的参数。</li></ul><h2 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5. 删除数据"></a><strong>5. 删除数据</strong></h2><p>删除数据使用 <code>SQLiteDatabase.delete()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun deleteUser(context: Context, id: Long) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val selection = &quot;id = ?&quot;</span><br><span class="line">    val selectionArgs = arrayOf(id.toString())</span><br><span class="line"></span><br><span class="line">    db.delete(&quot;users&quot;, selection, selectionArgs)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>delete()</code></strong>：删除数据的方法，类似于 <code>update()</code> 方法，传入 <code>WHERE</code> 子句来指定删除条件。</li></ul><h2 id="6-关闭数据库连接"><a href="#6-关闭数据库连接" class="headerlink" title="6. 关闭数据库连接"></a><strong>6. 关闭数据库连接</strong></h2><p>每次操作完数据库后，记得关闭数据库连接，防止内存泄漏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.close()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><strong>创建数据库和表</strong>：通过继承 <code>SQLiteOpenHelper</code> 类来创建数据库及表。</li><li><strong>插入数据</strong>：使用 <code>ContentValues</code> 结合 <code>insert()</code> 方法插入数据。</li><li><strong>查询数据</strong>：通过 <code>query()</code> 或 <code>rawQuery()</code> 查询数据，返回 <code>Cursor</code> 对象进行遍历。</li><li><strong>更新数据</strong>：使用 <code>update()</code> 方法更新数据。</li><li><strong>删除数据</strong>：使用 <code>delete()</code> 方法删除数据。</li><li><strong>关闭数据库连接</strong>：操作完成后记得关闭数据库。</li></ol><p>SQLite 提供了强大的本地数据存储能力，适合用于需要存储结构化数据的应用。</p><p><strong>完整示例</strong></p><p>假设我们有一个应用需要保存用户信息，每个用户包含 <code>id</code>、<code>name</code> 和 <code>email</code>。我们可以在数据库中创建一个表并对数据进行增删改查操作。</p><h4 id="1-数据库助手类"><a href="#1-数据库助手类" class="headerlink" title="1. 数据库助手类"></a>1. 数据库助手类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MyDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val DATABASE_NAME = &quot;my_database.db&quot;</span><br><span class="line">        const val DATABASE_VERSION = 1</span><br><span class="line">        const val TABLE_NAME = &quot;users&quot;</span><br><span class="line">        const val COLUMN_ID = &quot;id&quot;</span><br><span class="line">        const val COLUMN_NAME = &quot;name&quot;</span><br><span class="line">        const val COLUMN_EMAIL = &quot;email&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase?) &#123;</span><br><span class="line">        val createTableQuery = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE $TABLE_NAME (</span><br><span class="line">                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                $COLUMN_NAME TEXT,</span><br><span class="line">                $COLUMN_EMAIL TEXT</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        db?.execSQL(createTableQuery)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NAME&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-插入数据-1"><a href="#2-插入数据-1" class="headerlink" title="2. 插入数据"></a>2. 插入数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_NAME, &quot;John Doe&quot;)</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_EMAIL, &quot;john.doe@example.com&quot;)</span><br><span class="line">&#125;</span><br><span class="line">db.insert(MyDatabaseHelper.TABLE_NAME, null, values)</span><br></pre></td></tr></table></figure><h4 id="3-查询数据-1"><a href="#3-查询数据-1" class="headerlink" title="3. 查询数据"></a>3. 查询数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val db = dbHelper.readableDatabase</span><br><span class="line">val cursor = db.query(</span><br><span class="line">    MyDatabaseHelper.TABLE_NAME,</span><br><span class="line">    arrayOf(MyDatabaseHelper.COLUMN_ID, MyDatabaseHelper.COLUMN_NAME, MyDatabaseHelper.COLUMN_EMAIL),</span><br><span class="line">    null, null, null, null, null</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">while (cursor.moveToNext()) &#123;</span><br><span class="line">    val id = cursor.getLong(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_ID))</span><br><span class="line">    val name = cursor.getString(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_NAME))</span><br><span class="line">    val email = cursor.getString(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_EMAIL))</span><br><span class="line">    println(&quot;User: $id, $name, $email&quot;)</span><br><span class="line">&#125;</span><br><span class="line">cursor.close()</span><br></pre></td></tr></table></figure><h4 id="4-更新数据-1"><a href="#4-更新数据-1" class="headerlink" title="4. 更新数据"></a>4. 更新数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_NAME, &quot;John Smith&quot;)</span><br><span class="line">&#125;</span><br><span class="line">val selection = &quot;$&#123;MyDatabaseHelper.COLUMN_ID&#125; = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">db.update(MyDatabaseHelper.TABLE_NAME, values, selection, selectionArgs)</span><br></pre></td></tr></table></figure><h4 id="5-删除数据-1"><a href="#5-删除数据-1" class="headerlink" title="5. 删除数据"></a>5. 删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val selection = &quot;$&#123;MyDatabaseHelper.COLUMN_ID&#125; = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">db.delete(MyDatabaseHelper.TABLE_NAME, selection, selectionArgs)</span><br></pre></td></tr></table></figure><h4 id="6-关闭数据库"><a href="#6-关闭数据库" class="headerlink" title="6. 关闭数据库"></a>6. 关闭数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.close()</span><br></pre></td></tr></table></figure><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>SQLiteOpenHelper</strong>：管理数据库的创建、升级等操作。</li><li><strong>SQLiteDatabase</strong>：用于执行数据库操作，如插入、查询、更新、删除。</li><li><strong>ContentValues</strong>：用于存储要插入或更新的数据。</li><li><strong>Cursor</strong>：用于访问查询结果。</li></ul><p>SQLite 是一种非常有效的方式来在 Android 上进行本地数据存储，尤其适用于存储小型结构化数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Room+ViewModel+LiveData一起使用的用法</title>
      <link href="/2025/03/15/Room-ViewModel-LiveData%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/Room-ViewModel-LiveData%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 <code>Android</code> 开发中，<code>Room</code>、<code>ViewModel</code> 和 <code>LiveData</code> 经常一起使用，以实现 <strong>MVVM 架构</strong>，并提供持久化数据存储、生命周期感知的数据管理和自动更新 UI 的能力。</p><hr><h1 id="📌-1-主要作用"><a href="#📌-1-主要作用" class="headerlink" title="📌 1. 主要作用"></a><strong>📌 1. 主要作用</strong></h1><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>Room（数据库）</strong></td><td>提供 SQLite 的抽象层，管理本地数据存储</td></tr><tr><td><strong>ViewModel</strong></td><td>管理 UI 相关的数据，确保数据在配置变更（如旋转屏幕）时不会丢失</td></tr><tr><td><strong>LiveData</strong></td><td>观察数据变化，并在 UI 组件生命周期内自动更新</td></tr></tbody></table><hr><h1 id="🚀-2-使用-Room-ViewModel-LiveData-的完整示例"><a href="#🚀-2-使用-Room-ViewModel-LiveData-的完整示例" class="headerlink" title="🚀 2. 使用 Room + ViewModel + LiveData 的完整示例"></a><strong>🚀 2. 使用 <code>Room + ViewModel + LiveData</code> 的完整示例</strong></h1><h3 id="📌-功能："><a href="#📌-功能：" class="headerlink" title="📌 功能："></a><strong>📌 功能</strong>：</h3><p>我们实现一个<strong>简单的待办事项（ToDo List）应用</strong>，可以：</p><ul><li><strong>增删查改任务</strong>，数据存储在 <code>Room</code> 数据库中。</li><li><strong>使用 <code>LiveData</code></strong> 让 UI <strong>自动更新</strong>，而不需要手动刷新。</li><li><strong><code>ViewModel</code> 负责管理数据</strong>，避免 <code>Activity</code> 直接操作数据库。</li></ul><hr><h2 id="📌-3-创建-Room-数据库"><a href="#📌-3-创建-Room-数据库" class="headerlink" title="📌 3. 创建 Room 数据库"></a><strong>📌 3. 创建 Room 数据库</strong></h2><h3 id="（1）定义-Entity（数据库表）"><a href="#（1）定义-Entity（数据库表）" class="headerlink" title="（1）定义 Entity（数据库表）"></a><strong>（1）定义 <code>Entity</code>（数据库表）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.Entity</span><br><span class="line">import androidx.room.PrimaryKey</span><br><span class="line"></span><br><span class="line">@Entity(tableName = &quot;todo_table&quot;)</span><br><span class="line">data class Todo(</span><br><span class="line">    @PrimaryKey(autoGenerate = true) val id: Int = 0,</span><br><span class="line">    val task: String,</span><br><span class="line">    val isCompleted: Boolean</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>@Entity</code>：表示这是一个数据库表，表名是 <code>todo_table</code>。</li><li><code>@PrimaryKey(autoGenerate = true)</code>：<code>id</code> 是主键，<code>Room</code> 会自动生成。</li></ul><hr><h3 id="（2）创建-DAO（数据访问对象）"><a href="#（2）创建-DAO（数据访问对象）" class="headerlink" title="（2）创建 DAO（数据访问对象）"></a><strong>（2）创建 DAO（数据访问对象）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line">import androidx.room.*</span><br><span class="line"></span><br><span class="line">@Dao</span><br><span class="line">interface TodoDao &#123;</span><br><span class="line">    @Insert(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    suspend fun insert(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    suspend fun update(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    suspend fun delete(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM todo_table ORDER BY id DESC&quot;)</span><br><span class="line">    fun getAllTodos(): LiveData&lt;List&lt;Todo&gt;&gt; // 使用 LiveData 让 UI 自动更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Dao</code>：数据访问对象，定义数据库操作。</li><li><code>@Insert</code> &#x2F; <code>@Update</code> &#x2F; <code>@Delete</code>：操作数据库的基本增、删、改。</li><li><code>getAllTodos()</code> 返回 <code>LiveData&lt;List&lt;Todo&gt;&gt;</code>，<strong>Room 会自动监听数据变化，并更新 UI</strong>。</li></ul><hr><h3 id="（3）创建-Room-数据库"><a href="#（3）创建-Room-数据库" class="headerlink" title="（3）创建 Room 数据库"></a><strong>（3）创建 Room 数据库</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import androidx.room.Database</span><br><span class="line">import androidx.room.Room</span><br><span class="line">import androidx.room.RoomDatabase</span><br><span class="line"></span><br><span class="line">@Database(entities = [Todo::class], version = 1, exportSchema = false)</span><br><span class="line">abstract class TodoDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun todoDao(): TodoDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile</span><br><span class="line">        private var INSTANCE: TodoDatabase? = null</span><br><span class="line"></span><br><span class="line">        fun getDatabase(context: Context): TodoDatabase &#123;</span><br><span class="line">            return INSTANCE ?: synchronized(this) &#123;</span><br><span class="line">                val instance = Room.databaseBuilder(</span><br><span class="line">                    context.applicationContext,</span><br><span class="line">                    TodoDatabase::class.java,</span><br><span class="line">                    &quot;todo_database&quot;</span><br><span class="line">                ).build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Database(entities = [Todo::class], version = 1)</code>：定义数据库，包含 <code>Todo</code> 表。</li><li><code>synchronized(this)</code>：保证数据库实例的线程安全。</li><li><code>Room.databaseBuilder()</code>：构建 <code>Room</code> 数据库实例。</li></ul><hr><h2 id="📌-4-创建-Repository"><a href="#📌-4-创建-Repository" class="headerlink" title="📌 4. 创建 Repository"></a><strong>📌 4. 创建 Repository</strong></h2><p><code>Repository</code> 负责处理 <code>DAO</code> 操作，避免 <code>ViewModel</code> 直接操作数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line"></span><br><span class="line">class TodoRepository(private val todoDao: TodoDao) &#123;</span><br><span class="line">    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt; = todoDao.getAllTodos()</span><br><span class="line"></span><br><span class="line">    suspend fun insert(todo: Todo) &#123;</span><br><span class="line">        todoDao.insert(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun update(todo: Todo) &#123;</span><br><span class="line">        todoDao.update(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun delete(todo: Todo) &#123;</span><br><span class="line">        todoDao.delete(todo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Repository</code> 封装 <code>DAO</code>，<strong>ViewModel 只需要调用 <code>Repository</code>，而不直接操作 <code>Room</code></strong>。</li></ul><hr><h2 id="📌-5-创建-ViewModel"><a href="#📌-5-创建-ViewModel" class="headerlink" title="📌 5. 创建 ViewModel"></a><strong>📌 5. 创建 ViewModel</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.*</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">class TodoViewModel(private val repository: TodoRepository) : ViewModel() &#123;</span><br><span class="line">    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt; = repository.allTodos</span><br><span class="line"></span><br><span class="line">    fun insert(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.insert(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun update(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.update(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun delete(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.delete(todo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>viewModelScope.launch &#123;&#125;</code> 让数据库操作在 <strong>后台线程执行</strong>（<code>suspend</code> 需要 <code>Coroutine</code>）。</li><li><code>LiveData&lt;List&lt;Todo&gt;&gt;</code> 确保 UI 自动更新。</li></ul><hr><h2 id="📌-6-创建-ViewModelFactory"><a href="#📌-6-创建-ViewModelFactory" class="headerlink" title="📌 6. 创建 ViewModelFactory"></a><strong>📌 6. 创建 ViewModelFactory</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import androidx.lifecycle.ViewModelProvider</span><br><span class="line"></span><br><span class="line">class TodoViewModelFactory(private val repository: TodoRepository) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(TodoViewModel::class.java)) &#123;</span><br><span class="line">            @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">            return TodoViewModel(repository) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ViewModelFactory</code> 用于 <strong>传递 <code>Repository</code></strong>，让 <code>ViewModel</code> 使用 <code>Room</code>。</li></ul><hr><h2 id="📌-7-在-Activity-里使用"><a href="#📌-7-在-Activity-里使用" class="headerlink" title="📌 7. 在 Activity 里使用"></a><strong>📌 7. 在 <code>Activity</code> 里使用</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var todoViewModel: TodoViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        // 获取数据库实例和 DAO</span><br><span class="line">        val database = TodoDatabase.getDatabase(this)</span><br><span class="line">        val repository = TodoRepository(database.todoDao())</span><br><span class="line"></span><br><span class="line">        // 创建 ViewModel</span><br><span class="line">        val factory = TodoViewModelFactory(repository)</span><br><span class="line">        todoViewModel = ViewModelProvider(this, factory).get(TodoViewModel::class.java)</span><br><span class="line"></span><br><span class="line">        // 监听 LiveData，更新 UI</span><br><span class="line">        todoViewModel.allTodos.observe(this) &#123; todos -&gt;</span><br><span class="line">            // 更新 RecyclerView 或 UI</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 添加任务</span><br><span class="line">        buttonAdd.setOnClickListener &#123;</span><br><span class="line">            val newTodo = Todo(task = &quot;New Task&quot;, isCompleted = false)</span><br><span class="line">            todoViewModel.insert(newTodo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getDatabase(this)</code> 获取数据库实例。</li><li><code>ViewModelProvider(this, factory)</code> 创建 <code>ViewModel</code>。</li><li><code>LiveData.observe()</code> 监听数据变化，<strong>UI 自动更新</strong>。</li></ul><hr><h1 id="📌-8-总结"><a href="#📌-8-总结" class="headerlink" title="📌 8. 总结"></a><strong>📌 8. 总结</strong></h1><p>✅ <strong>Room 负责存储数据</strong>，<code>DAO</code> 负责数据库操作。<br> ✅ <strong>ViewModel 负责持久化数据</strong>，避免因屏幕旋转导致数据丢失。<br> ✅ <strong>LiveData 让 UI 自动更新</strong>，不需要手动刷新数据。<br> ✅ <strong>Repository 作为数据中介</strong>，避免 <code>ViewModel</code> 直接操作 <code>Room</code>。</p><p>📌 <strong>最终效果</strong>：</p><ol><li><strong>数据库变更时，UI 自动更新</strong>（<code>LiveData</code>）。</li><li><strong>ViewModel 让数据在 Activity&#x2F;Fragment 生命周期内持久化</strong>。</li><li><strong>Repository 让数据管理更清晰</strong>，避免 <code>ViewModel</code> 直接访问数据库。</li></ol><p>💡 <strong>这样，我们的 <code>MVVM + Room</code> 架构更加清晰，可维护性更强！</strong> 🚀</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewModel用法</title>
      <link href="/2025/03/15/ViewModel%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/ViewModel%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>ViewModel</code> 是 Android 架构组件之一，<strong>用于管理 UI 相关的数据</strong>，并在 <strong>配置更改（如屏幕旋转）时保持数据不丢失</strong>。</p><hr><h2 id="🔹-1-添加-ViewModel-依赖"><a href="#🔹-1-添加-ViewModel-依赖" class="headerlink" title="🔹 1. 添加 ViewModel 依赖"></a><strong>🔹 1. 添加 ViewModel 依赖</strong></h2><p>在 <code>build.gradle.kts</code>（模块级）中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-2-创建-ViewModel"><a href="#🔹-2-创建-ViewModel" class="headerlink" title="🔹 2. 创建 ViewModel"></a><strong>🔹 2. 创建 ViewModel</strong></h2><h3 id="（1）基础-ViewModel"><a href="#（1）基础-ViewModel" class="headerlink" title="（1）基础 ViewModel"></a><strong>（1）基础 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line">class CounterViewModel : ViewModel() &#123;</span><br><span class="line">    var count = 0 // ViewModel 变量（Activity 重建后不会丢失）</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-3-在-Activity-Fragment-中使用"><a href="#🔹-3-在-Activity-Fragment-中使用" class="headerlink" title="🔹 3. 在 Activity&#x2F;Fragment 中使用"></a><strong>🔹 3. 在 Activity&#x2F;Fragment 中使用</strong></h2><h3 id="（1）Activity-获取-ViewModel"><a href="#（1）Activity-获取-ViewModel" class="headerlink" title="（1）Activity 获取 ViewModel"></a><strong>（1）Activity 获取 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import android.widget.TextView</span><br><span class="line">import androidx.activity.viewModels</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels() // 通过 viewModels() 获取 ViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        // 显示当前计数</span><br><span class="line">        textView.text = counterViewModel.count.toString()</span><br><span class="line"></span><br><span class="line">        // 点击按钮增加计数</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">            textView.text = counterViewModel.count.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>即使旋转屏幕，<code>count</code> 也不会重置</strong>。</p><hr><h2 id="🔹-4-ViewModel-LiveData-监听数据变化"><a href="#🔹-4-ViewModel-LiveData-监听数据变化" class="headerlink" title="🔹 4. ViewModel + LiveData 监听数据变化"></a><strong>🔹 4. ViewModel + LiveData 监听数据变化</strong></h2><p>使用 <code>LiveData</code>，<strong>UI 会自动更新</strong>：</p><h3 id="（1）ViewModel（使用-LiveData）"><a href="#（1）ViewModel（使用-LiveData）" class="headerlink" title="（1）ViewModel（使用 LiveData）"></a><strong>（1）ViewModel（使用 <code>LiveData</code>）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line">import androidx.lifecycle.MutableLiveData</span><br><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line">class CounterViewModel : ViewModel() &#123;</span><br><span class="line">    private val _count = MutableLiveData(0) // 可变 LiveData</span><br><span class="line">    val count: LiveData&lt;Int&gt; = _count // 只暴露不可变 LiveData</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        _count.value = (_count.value ?: 0) + 1 // 更新数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）Activity-观察-LiveData"><a href="#（2）Activity-观察-LiveData" class="headerlink" title="（2）Activity 观察 LiveData"></a><strong>（2）Activity 观察 LiveData</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels()</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        // 观察 LiveData，自动更新 UI</span><br><span class="line">        counterViewModel.count.observe(this) &#123; newCount -&gt;</span><br><span class="line">            textView.text = newCount.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong><code>LiveData</code> 确保数据变化时，UI 会自动更新</strong>。</p><hr><h2 id="🔹-5-处理-ViewModel-依赖（带参数的-ViewModel）"><a href="#🔹-5-处理-ViewModel-依赖（带参数的-ViewModel）" class="headerlink" title="🔹 5. 处理 ViewModel 依赖（带参数的 ViewModel）"></a><strong>🔹 5. 处理 ViewModel 依赖（带参数的 ViewModel）</strong></h2><h3 id="（1）ViewModel-需要参数"><a href="#（1）ViewModel-需要参数" class="headerlink" title="（1）ViewModel 需要参数"></a><strong>（1）ViewModel 需要参数</strong></h3><p>如果 <code>ViewModel</code> 需要参数（如 <code>Repository</code>），需要创建 <code>ViewModelProvider.Factory</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class CounterViewModel(private val startValue: Int) : ViewModel() &#123;</span><br><span class="line">    private val _count = MutableLiveData(startValue)</span><br><span class="line">    val count: LiveData&lt;Int&gt; = _count</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        _count.value = (_count.value ?: 0) + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义 ViewModelFactory</span><br><span class="line">class CounterViewModelFactory(private val startValue: Int) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(CounterViewModel::class.java)) &#123;</span><br><span class="line">            @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">            return CounterViewModel(startValue) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）Activity-获取带参数的-ViewModel"><a href="#（2）Activity-获取带参数的-ViewModel" class="headerlink" title="（2）Activity 获取带参数的 ViewModel"></a><strong>（2）Activity 获取带参数的 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels &#123;</span><br><span class="line">        CounterViewModelFactory(5) // 传入初始值 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        counterViewModel.count.observe(this) &#123; newCount -&gt;</span><br><span class="line">            textView.text = newCount.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>支持带参数的 ViewModel（如从数据库或网络获取初始数据）</strong>。</p><hr><h2 id="🔹-6-ViewModel-Room-持久化数据库数据"><a href="#🔹-6-ViewModel-Room-持久化数据库数据" class="headerlink" title="🔹 6. ViewModel + Room 持久化数据库数据"></a><strong>🔹 6. ViewModel + Room 持久化数据库数据</strong></h2><p>如果你使用 <code>Room</code> 存储数据，<code>ViewModel</code> 可以直接从 <code>Room</code> 获取 <code>LiveData</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface DiaryDao &#123;</span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">    fun getAllDiaries(): LiveData&lt;List&lt;DiaryEntry&gt;&gt; // LiveData 监听数据库</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val diaryList: LiveData&lt;List&lt;DiaryEntry&gt;&gt; = diaryDao.getAllDiaries()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Fragment</code> 观察数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diaryViewModel.diaryList.observe(viewLifecycleOwner) &#123; diaryList -&gt;</span><br><span class="line">    diaryAdapter.submitList(diaryList) // 更新 UI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>Room + ViewModel + LiveData 确保数据持久化，并自动更新 UI</strong>。</p><hr><h2 id="🔹-7-ViewModel-Kotlin-Flow（协程）"><a href="#🔹-7-ViewModel-Kotlin-Flow（协程）" class="headerlink" title="🔹 7. ViewModel + Kotlin Flow（协程）"></a><strong>🔹 7. ViewModel + Kotlin Flow（协程）</strong></h2><p>如果你用 <code>Flow</code>，可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val diaryListFlow = diaryDao.getAllDiariesFlow()</span><br><span class="line">        .stateIn(viewModelScope, SharingStarted.Lazily, emptyList()) // 转为 StateFlow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Fragment</code> 中 <code>collect</code> 数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    viewModel.diaryListFlow.collect &#123; diaryList -&gt;</span><br><span class="line">        diaryAdapter.submitList(diaryList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong><code>Flow</code> 更适合复杂数据流（如数据库、网络请求）</strong>。</p><hr><h2 id="🔹-8-ViewModel-生命周期"><a href="#🔹-8-ViewModel-生命周期" class="headerlink" title="🔹 8. ViewModel 生命周期"></a><strong>🔹 8. ViewModel 生命周期</strong></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>ViewModel 作用</strong></th></tr></thead><tbody><tr><td>旋转屏幕</td><td>保持数据不丢失</td></tr><tr><td>App 进后台</td><td>ViewModel 可能被销毁（可用 <code>SavedStateHandle</code> 处理）</td></tr><tr><td>Fragment 切换</td><td>共享 <code>ViewModel</code> 以保留数据</td></tr></tbody></table><hr><h2 id="🔹-总结"><a href="#🔹-总结" class="headerlink" title="🔹 总结"></a><strong>🔹 总结</strong></h2><p>✅ <code>ViewModel</code> <strong>用于管理 UI 相关数据，避免因屏幕旋转导致数据丢失</strong>。<br> ✅ 搭配 <code>LiveData</code> <strong>自动通知 UI 变化</strong>。<br> ✅ <code>ViewModel</code> + <code>Room</code> <strong>可以自动监听数据库变化</strong>。<br> ✅ <code>ViewModel</code> + <code>Flow</code> <strong>适合复杂数据流处理</strong>。<br> ✅ <code>ViewModelFactory</code> <strong>用于创建带参数的 ViewModel</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Room用法</title>
      <link href="/2025/03/15/Room%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/Room%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Room 是 Android 官方推荐的数据库框架，它是 SQLite 的抽象封装，提供了更便捷的数据库操作方式，支持 Kotlin 协程和 LiveData。以下是 Room 的基本使用方法：</p><hr><h2 id="1-添加-Room-依赖"><a href="#1-添加-Room-依赖" class="headerlink" title="1. 添加 Room 依赖"></a><strong>1. 添加 Room 依赖</strong></h2><p>在 <code>build.gradle.kts</code>（模块级）中添加 Room 相关依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    val room_version = &quot;2.6.1&quot; // 确保使用最新版本</span><br><span class="line"></span><br><span class="line">    implementation(&quot;androidx.room:room-runtime:$room_version&quot;)</span><br><span class="line">    kapt(&quot;androidx.room:room-compiler:$room_version&quot;) // 用于注解处理器</span><br><span class="line"></span><br><span class="line">    implementation(&quot;androidx.room:room-ktx:$room_version&quot;) // 支持 Kotlin 协程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果项目使用 Kotlin Symbol Processing (KSP) 代替 kapt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ksp(&quot;androidx.room:room-compiler:$room_version&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="2-创建数据库实体（Entity）"><a href="#2-创建数据库实体（Entity）" class="headerlink" title="2. 创建数据库实体（Entity）"></a><strong>2. 创建数据库实体（Entity）</strong></h2><p>使用 <code>@Entity</code> 注解定义数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.Entity</span><br><span class="line">import androidx.room.PrimaryKey</span><br><span class="line"></span><br><span class="line">@Entity(tableName = &quot;diary_entries&quot;) // 指定表名</span><br><span class="line">data class DiaryEntry(</span><br><span class="line">    @PrimaryKey(autoGenerate = true) val id: Int = 0, // 主键，自动生成</span><br><span class="line">    val title: String,</span><br><span class="line">    val content: String,</span><br><span class="line">    val date: Long, // 以时间戳形式存储日期</span><br><span class="line">    val weather: String? = null</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="3-创建-DAO（数据访问对象）"><a href="#3-创建-DAO（数据访问对象）" class="headerlink" title="3. 创建 DAO（数据访问对象）"></a><strong>3. 创建 DAO（数据访问对象）</strong></h2><p>DAO 负责数据库的 CRUD 操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.*</span><br><span class="line"></span><br><span class="line">@Dao</span><br><span class="line">interface DiaryDao &#123;</span><br><span class="line">    @Insert(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    suspend fun insertDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    suspend fun updateDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    suspend fun deleteDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">    fun getAllDiaries(): List&lt;DiaryEntry&gt; // 直接返回列表（不推荐，建议使用 Flow）</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries WHERE id = :id&quot;)</span><br><span class="line">    suspend fun getDiaryById(id: Int): DiaryEntry?</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries WHERE title LIKE &#x27;%&#x27; || :query || &#x27;%&#x27;&quot;)</span><br><span class="line">    fun searchDiaries(query: String): List&lt;DiaryEntry&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要监听数据变化，可以用 <code>Flow</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">fun getAllDiariesFlow(): Flow&lt;List&lt;DiaryEntry&gt;&gt; // 使用 Flow 以支持实时监听</span><br></pre></td></tr></table></figure><hr><h2 id="4-创建数据库（Database）"><a href="#4-创建数据库（Database）" class="headerlink" title="4. 创建数据库（Database）"></a><strong>4. 创建数据库（Database）</strong></h2><p>使用 <code>@Database</code> 注解创建 Room 数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import androidx.room.Database</span><br><span class="line">import androidx.room.Room</span><br><span class="line">import androidx.room.RoomDatabase</span><br><span class="line"></span><br><span class="line">@Database(entities = [DiaryEntry::class], version = 1, exportSchema = false)</span><br><span class="line">abstract class DiaryDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun diaryDao(): DiaryDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile</span><br><span class="line">        private var INSTANCE: DiaryDatabase? = null</span><br><span class="line"></span><br><span class="line">        fun getDatabase(context: Context): DiaryDatabase &#123;</span><br><span class="line">            return INSTANCE ?: synchronized(this) &#123;</span><br><span class="line">                val instance = Room.databaseBuilder(</span><br><span class="line">                    context.applicationContext,</span><br><span class="line">                    DiaryDatabase::class.java,</span><br><span class="line">                    &quot;diary_database&quot;</span><br><span class="line">                ).build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：</p><ul><li><code>@Volatile</code> 确保多个线程能正确访问 <code>INSTANCE</code>。</li><li><code>synchronized(this)</code> 确保数据库实例的单例模式。</li></ul></blockquote><hr><h2 id="5-在-ViewModel-中使用"><a href="#5-在-ViewModel-中使用" class="headerlink" title="5. 在 ViewModel 中使用"></a><strong>5. 在 ViewModel 中使用</strong></h2><p>在 <code>ViewModel</code> 里封装数据库操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import kotlinx.coroutines.flow.Flow</span><br><span class="line"></span><br><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val allDiaries: Flow&lt;List&lt;DiaryEntry&gt;&gt; = diaryDao.getAllDiariesFlow()</span><br><span class="line"></span><br><span class="line">    suspend fun addDiary(entry: DiaryEntry) &#123;</span><br><span class="line">        diaryDao.insertDiary(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun deleteDiary(entry: DiaryEntry) &#123;</span><br><span class="line">        diaryDao.deleteDiary(entry)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>viewmodel</code> 目录下新建 <code>DiaryViewModelFactory.kt</code> 文件，并写入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import androidx.lifecycle.ViewModelProvider</span><br><span class="line">import com.example.uibestpractice.data.DiaryDao // 替换为你的包名</span><br><span class="line"></span><br><span class="line">class DiaryViewModelFactory(private val diaryDao: DiaryDao) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(DiaryViewModel::class.java)) &#123;</span><br><span class="line">            return DiaryViewModel(diaryDao) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-在-Activity-Fragment-中使用"><a href="#6-在-Activity-Fragment-中使用" class="headerlink" title="6. 在 Activity&#x2F;Fragment 中使用"></a><strong>6. 在 Activity&#x2F;Fragment 中使用</strong></h2><p>在 <code>Activity</code> 或 <code>Fragment</code> 里使用 ViewModel：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.activity.viewModels</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val diaryViewModel: DiaryViewModel by viewModels &#123;</span><br><span class="line">        DiaryViewModelFactory(DiaryDatabase.getDatabase(this).diaryDao())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        // 监听数据库变化</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            diaryViewModel.allDiaries.collect &#123; diaryList -&gt;</span><br><span class="line">                // 更新 UI</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun addDiaryEntry() &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            val newEntry = DiaryEntry(title = &quot;新日记&quot;, content = &quot;今天很开心！&quot;, date = System.currentTimeMillis())</span><br><span class="line">            diaryViewModel.addDiary(newEntry)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="7-线程调度（协程）"><a href="#7-线程调度（协程）" class="headerlink" title="7. 线程调度（协程）"></a><strong>7. 线程调度（协程）</strong></h2><p>Room 允许在 <code>suspend</code> 函数中调用数据库操作，Kotlin 协程会自动切换到 IO 线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun insertDiary(entry: DiaryEntry) &#123;</span><br><span class="line">    diaryDao.insertDiary(entry) // Room 在 IO 线程执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <strong>不支持协程的函数</strong>（如 <code>getAllDiaries()</code>），应使用 <code>withContext(Dispatchers.IO)</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun getAllDiariesBlocking(): List&lt;DiaryEntry&gt; &#123;</span><br><span class="line">    return runBlocking &#123; withContext(Dispatchers.IO) &#123; diaryDao.getAllDiaries() &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Room 提供了 <strong>简单、安全、高效</strong> 的数据库管理：</p><ol><li><strong>Entity</strong>（表） → <code>@Entity</code></li><li><strong>DAO</strong>（数据操作） → <code>@Dao</code></li><li><strong>Database</strong>（数据库实例） → <code>@Database</code></li><li><strong>ViewModel</strong>（封装业务逻辑）</li><li><strong>Activity&#x2F;Fragment</strong>（UI 层使用数据库）</li></ol><p>你可以结合 <code>Flow</code> 进行 <strong>实时监听</strong>，结合 <strong>Kotlin 协程</strong> 进行 <strong>异步处理</strong>，使数据库操作更加流畅高效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>startActivity和registerForActivityResult的用法</title>
      <link href="/2025/03/14/startActivity%E5%92%8CregisterForActivityResult%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/14/startActivity%E5%92%8CregisterForActivityResult%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 Android Kotlin 开发中，<code>startActivity</code> 和 <code>registerForActivityResult</code> 是启动新 Activity 并处理返回结果的两种方式。</p><hr><h2 id="1-使用-startActivity"><a href="#1-使用-startActivity" class="headerlink" title="1. 使用 startActivity"></a>1. 使用 <code>startActivity</code></h2><p><code>startActivity</code> 适用于 <strong>不需要获取返回值</strong> 的情况，例如从 <code>MainActivity</code> 跳转到 <code>SecondActivity</code>：</p><h3 id="示例：启动新-Activity"><a href="#示例：启动新-Activity" class="headerlink" title="示例：启动新 Activity"></a><strong>示例：启动新 Activity</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>如果你需要传递数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java).apply &#123;</span><br><span class="line">    putExtra(&quot;key&quot;, &quot;Hello, SecondActivity!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>在 <code>SecondActivity</code> 中获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val data = intent.getStringExtra(&quot;key&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="2-使用-registerForActivityResult"><a href="#2-使用-registerForActivityResult" class="headerlink" title="2. 使用 registerForActivityResult"></a>2. 使用 <code>registerForActivityResult</code></h2><p><code>registerForActivityResult</code> 适用于 <strong>需要从子 Activity 返回数据</strong> 的情况，比如用户选择了一个文件或拍照后返回图片。</p><h3 id="示例：启动-Activity-并获取返回值"><a href="#示例：启动-Activity-并获取返回值" class="headerlink" title="示例：启动 Activity 并获取返回值"></a><strong>示例：启动 Activity 并获取返回值</strong></h3><p>先在主 Activity 中注册一个 <code>ActivityResultLauncher</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private val launcher=registerForActivityResult(ActivityResultContracts.StartActivityForResult())&#123; result -&gt;</span><br><span class="line">    if (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        val data = result.data?.getStringExtra(&quot;result_key&quot;)</span><br><span class="line">        Toast.makeText(this, &quot;收到返回值: $data&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 <code>launcher.launch(intent)</code> 启动新 Activity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java)</span><br><span class="line">launcher.launch(intent)</span><br></pre></td></tr></table></figure><h3 id="在-SecondActivity-处理返回数据"><a href="#在-SecondActivity-处理返回数据" class="headerlink" title="在 SecondActivity 处理返回数据"></a><strong>在 SecondActivity 处理返回数据</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val resultIntent = Intent().apply &#123;</span><br><span class="line">    putExtra(&quot;result_key&quot;, &quot;返回的数据&quot;)</span><br><span class="line">&#125;</span><br><span class="line">setResult(Activity.RESULT_OK, resultIntent)</span><br><span class="line">finish()</span><br></pre></td></tr></table></figure><hr><h2 id="3-startActivityForResult-已废弃"><a href="#3-startActivityForResult-已废弃" class="headerlink" title="3. startActivityForResult 已废弃"></a>3. <code>startActivityForResult</code> 已废弃</h2><p><code>startActivityForResult</code> 在 API 30（Android 11）开始被 <strong>弃用</strong>，官方推荐使用 <code>registerForActivityResult</code> 代替。</p><p>如果你的代码仍然使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">startActivityForResult(intent, REQUEST_CODE)</span><br></pre></td></tr></table></figure><p>则应改用 <code>registerForActivityResult</code>。</p><hr><h2 id="4-其他-ActivityResultContracts"><a href="#4-其他-ActivityResultContracts" class="headerlink" title="4. 其他 ActivityResultContracts"></a>4. 其他 <code>ActivityResultContracts</code></h2><p><code>registerForActivityResult</code> 还支持多种 <code>ActivityResultContracts</code>，如：</p><ul><li><code>ActivityResultContracts.RequestPermission()</code>（请求单个权限）</li><li><code>ActivityResultContracts.GetContent()</code>（选择文件）</li><li><code>ActivityResultContracts.TakePicture()</code>（拍照）</li></ul><h3 id="示例：获取图片"><a href="#示例：获取图片" class="headerlink" title="示例：获取图片"></a><strong>示例：获取图片</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private val getImage = registerForActivityResult(ActivityResultContracts.GetContent()) &#123; uri: Uri? -&gt;</span><br><span class="line">    uri?.let &#123;</span><br><span class="line">        imageView.setImageURI(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    getImage.launch(&quot;image/*&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>总结：</strong></p><ul><li><code>startActivity()</code> 适用于无返回值的跳转。</li><li><code>registerForActivityResult()</code> 适用于需要获取返回值的情况，并且比 <code>startActivityForResult()</code> 更推荐。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit用法示例</title>
      <link href="/2025/03/14/Retrofit%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/14/Retrofit%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<ol start="5"><li><ul><li><h1 id="Retrofit-使用指南"><a href="#Retrofit-使用指南" class="headerlink" title="Retrofit 使用指南"></a><strong>Retrofit 使用指南</strong></h1><p><code>Retrofit</code> 是 Android 上最常用的网络请求库之一，它简化了 HTTP 请求的处理，支持 <strong>GET、POST、PUT、DELETE</strong> 等请求方式，并且可以配合 <code>Gson</code>、<code>Moshi</code> 等解析 JSON 数据。</p><hr><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a><strong>1. 添加依赖</strong></h2><p>在 <code>build.gradle</code>（Module 级）中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span><br><span class="line">    implementation &#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27; // Gson 解析 JSON</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-创建-API-接口"><a href="#2-创建-API-接口" class="headerlink" title="2. 创建 API 接口"></a><strong>2. 创建 API 接口</strong></h2><p>定义 API 接口，例如获取用户信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import retrofit2.Call</span><br><span class="line">import retrofit2.http.GET</span><br><span class="line">import retrofit2.http.Path</span><br><span class="line"></span><br><span class="line">interface ApiService &#123;</span><br><span class="line">    @GET(&quot;users/&#123;id&#125;&quot;)  // 定义 GET 请求，&#123;id&#125; 是动态路径参数</span><br><span class="line">    fun getUser(@Path(&quot;id&quot;) userId: Int): Call&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-定义数据模型"><a href="#3-定义数据模型" class="headerlink" title="3. 定义数据模型"></a><strong>3. 定义数据模型</strong></h2><p>Retrofit 需要解析服务器返回的 JSON 数据，因此要创建一个 <code>data class</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class User(</span><br><span class="line">    val id: Int,</span><br><span class="line">    val name: String,</span><br><span class="line">    val email: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="4-创建-Retrofit-实例"><a href="#4-创建-Retrofit-实例" class="headerlink" title="4. 创建 Retrofit 实例"></a><strong>4. 创建 Retrofit 实例</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import retrofit2.Retrofit</span><br><span class="line">import retrofit2.converter.gson.GsonConverterFactory</span><br><span class="line"></span><br><span class="line">object RetrofitClient &#123;</span><br><span class="line">    private const val BASE_URL = &quot;https://api.example.com/&quot;</span><br><span class="line"></span><br><span class="line">    val instance: ApiService by lazy &#123;</span><br><span class="line">        Retrofit.Builder()</span><br><span class="line">            .baseUrl(BASE_URL)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create()) // 自动解析 JSON</span><br><span class="line">            .build()</span><br><span class="line">            .create(ApiService::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-发起网络请求"><a href="#5-发起网络请求" class="headerlink" title="5. 发起网络请求"></a><strong>5. 发起网络请求</strong></h2><h3 id="方式-1：传统的同步请求"><a href="#方式-1：传统的同步请求" class="headerlink" title="方式 1：传统的同步请求"></a><strong>方式 1：传统的同步请求</strong></h3><p>在传统的同步请求中，我们会创建一个 <code>Call</code> 对象并使用 <code>execute()</code> 或 <code>enqueue()</code> 方法发起请求。</p><h4 id="同步请求代码-不推荐-："><a href="#同步请求代码-不推荐-：" class="headerlink" title="同步请求代码(不推荐)："></a>同步请求代码(不推荐)：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取 ApiService 实例</span><br><span class="line">val call = RetrofitClient.instance.getUser(1)  // 创建 Call 对象</span><br><span class="line"></span><br><span class="line">// 发起同步请求</span><br><span class="line">val response = call.execute()  // 使用 execute() 进行同步请求</span><br><span class="line"></span><br><span class="line">if (response.isSuccessful) &#123;</span><br><span class="line">    val user = response.body()</span><br><span class="line">    println(&quot;用户信息：$&#123;user?.name&#125;, $&#123;user?.email&#125;&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;请求失败: $&#123;response.code()&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execute()</code> 方法会同步阻塞线程，直到请求完成。通常情况下，<em><strong>不建议</strong></em>在主线程中使用这种方式，因为它可能导致应用的卡顿。</p><h4 id="异步请求代码："><a href="#异步请求代码：" class="headerlink" title="异步请求代码："></a>异步请求代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 获取 ApiService 实例</span><br><span class="line">val call = RetrofitClient.instance.getUser(1)  // 创建 Call 对象</span><br><span class="line"></span><br><span class="line">// 使用 enqueue() 发起异步请求</span><br><span class="line">call.enqueue(object : retrofit2.Callback&lt;User&gt; &#123;</span><br><span class="line">    override fun onResponse(call: Call&lt;User&gt;, response: retrofit2.Response&lt;User&gt;) &#123;</span><br><span class="line">        if (response.isSuccessful) &#123;</span><br><span class="line">            val user = response.body()</span><br><span class="line">            println(&quot;用户信息：$&#123;user?.name&#125;, $&#123;user?.email&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onFailure(call: Call&lt;User&gt;, t: Throwable) &#123;</span><br><span class="line">        println(&quot;请求失败: $&#123;t.message&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <code>enqueue()</code> 中使用回调来处理响应，它不会阻塞主线程，适合在 UI 线程中使用。</p><hr><h3 id="方式-2：使用协程-suspend（推荐方式）"><a href="#方式-2：使用协程-suspend（推荐方式）" class="headerlink" title="方式 2：使用协程 + suspend（推荐方式）"></a><strong>方式 2：使用协程 + <code>suspend</code>（推荐方式）</strong></h3><p>Retrofit 也支持 Kotlin <strong>协程</strong>，这样可以避免 <code>enqueue()</code> 回调写法：</p><h4 id="修改-API-接口："><a href="#修改-API-接口：" class="headerlink" title="修改 API 接口："></a>修改 API 接口：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ApiService &#123;</span><br><span class="line">    @GET(&quot;users/&#123;id&#125;&quot;)</span><br><span class="line">    suspend fun getUser(@Path(&quot;id&quot;) userId: Int): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在-ViewModel-里使用-suspend-请求："><a href="#在-ViewModel-里使用-suspend-请求：" class="headerlink" title="在 ViewModel 里使用 suspend 请求："></a>在 ViewModel 里使用 <code>suspend</code> 请求：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.CoroutineScope</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">fun fetchUserData() &#123;</span><br><span class="line">    CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            val user = RetrofitClient.instance.getUser(1)</span><br><span class="line">            println(&quot;用户信息: $&#123;user.name&#125;, $&#123;user.email&#125;&quot;)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            println(&quot;请求失败: $&#123;e.message&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>无回调地狱</strong>，代码更简洁。</li><li><strong>自动处理异步任务</strong>，适用于现代 Android 开发。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><p><strong>添加依赖</strong> (<code>Retrofit + Gson</code>)。</p></li><li><p><strong>创建 API 接口</strong> (<code>interface ApiService</code>)。</p></li><li><p><strong>定义数据模型</strong> (<code>data class User</code>)。</p></li><li><p><strong>创建 Retrofit 实例</strong> (<code>RetrofitClient</code>)。</p></li><li><p>发起请求</p><p>：</p><ul><li><strong>方式 1</strong>：使用 <code>Call</code> 对象 + <code>execute()</code> 或 <code>enqueue()</code>（传统方式）。</li><li><strong>方式 2</strong>：使用 <code>suspend</code> 函数 + 协程（推荐现代写法）。</li></ul></li></ol></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD命令大全</title>
      <link href="/2025/03/13/CMD%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2025/03/13/CMD%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CMD-命令大全：从入门到精通"><a href="#CMD-命令大全：从入门到精通" class="headerlink" title="CMD 命令大全：从入门到精通"></a>CMD 命令大全：从入门到精通</h1><p>命令提示符（CMD）是 Windows 操作系统中的命令行界面，允许用户通过输入命令来执行各种任务。它是一个强大的工具，适用于系统管理、网络配置、文件操作等多种场景。本文详细介绍了常用的 CMD 命令，帮助你从入门到精通 CMD。<strong>不过也可以直接打help寻找命令的。</strong></p><p>[参考来源](<a href="https://blog.csdn.net/m0_70474954/article/details/143496800">CMD 命令大全：从入门到精通_cmd命令-CSDN博客</a>)</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#cmd-%E5%9F%BA%E7%A1%80">CMD 基础</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">文件和目录操作命令</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4">系统信息获取命令</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4">网络配置命令</a></li><li><a href="#%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">磁盘和文件系统操作命令</a></li><li><a href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6">批处理文件</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li><li><a href="#cmd-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7">CMD 高级技巧</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">常见问题与解决方案</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ol><hr><h2 id="CMD-基础"><a href="#CMD-基础" class="headerlink" title="CMD 基础"></a>CMD 基础</h2><h3 id="1-1-打开-CMD"><a href="#1-1-打开-CMD" class="headerlink" title="1.1 打开 CMD"></a>1.1 打开 CMD</h3><p>在 Windows 中，可通过以下方式打开命令提示符：</p><ul><li>按 <code>Win + R</code>，输入 <code>cmd</code>，然后按 <code>Enter</code>。</li><li>在开始菜单中搜索 “cmd” 或 “命令提示符”。</li></ul><h3 id="1-2-常用命令格式"><a href="#1-2-常用命令格式" class="headerlink" title="1.2 常用命令格式"></a>1.2 常用命令格式</h3><p>CMD 命令通常遵循以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 [参数]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /w</span><br></pre></td></tr></table></figure><p>其中 <code>dir</code> 是命令，<code>/w</code> 是参数。</p><hr><h2 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h2><h3 id="2-1-查看当前目录"><a href="#2-1-查看当前目录" class="headerlink" title="2.1 查看当前目录"></a>2.1 查看当前目录</h3><p>使用 <code>cd</code> 命令显示当前工作目录的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure><h3 id="2-2-列出目录中的文件"><a href="#2-2-列出目录中的文件" class="headerlink" title="2.2 列出目录中的文件"></a>2.2 列出目录中的文件</h3><p>使用 <code>dir</code> 命令列出当前目录中的所有文件和子目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><h3 id="2-3-进入目录"><a href="#2-3-进入目录" class="headerlink" title="2.3 进入目录"></a>2.3 进入目录</h3><p>使用 <code>cd [目录路径]</code> 进入指定目录。例如，进入 <code>D:\Documents</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd D:\Documents</span><br></pre></td></tr></table></figure><h3 id="2-4-返回上一级目录"><a href="#2-4-返回上一级目录" class="headerlink" title="2.4 返回上一级目录"></a>2.4 返回上一级目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><h3 id="2-5-创建新目录"><a href="#2-5-创建新目录" class="headerlink" title="2.5 创建新目录"></a>2.5 创建新目录</h3><p>使用 <code>mkdir [目录名]</code> 创建新目录。例如，创建一个名为 <code>NewFolder</code> 的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir NewFolder</span><br></pre></td></tr></table></figure><h3 id="2-6-删除目录"><a href="#2-6-删除目录" class="headerlink" title="2.6 删除目录"></a>2.6 删除目录</h3><p>使用 <code>rmdir [目录名]</code> 删除空目录。如果要删除非空目录，请使用 <code>/s</code> 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /s [目录名]</span><br></pre></td></tr></table></figure><h3 id="2-7-复制文件"><a href="#2-7-复制文件" class="headerlink" title="2.7 复制文件"></a>2.7 复制文件</h3><p>使用 <code>copy [源文件路径] [目标路径]</code> 复制文件。例如，将 <code>file.txt</code> 复制到 <code>D:\Backup</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy file.txt D:\Backup</span><br></pre></td></tr></table></figure><h3 id="2-8-移动文件"><a href="#2-8-移动文件" class="headerlink" title="2.8 移动文件"></a>2.8 移动文件</h3><p>使用 <code>move [源文件路径] [目标路径]</code> 移动文件。例如，将 <code>file.txt</code> 移动到 <code>D:\Documents</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move file.txt D:\Documents</span><br></pre></td></tr></table></figure><h3 id="2-9-删除文件"><a href="#2-9-删除文件" class="headerlink" title="2.9 删除文件"></a>2.9 删除文件</h3><p>使用 <code>del [文件名]</code> 删除文件。例如，删除 <code>file.txt</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del file.txt</span><br></pre></td></tr></table></figure><h3 id="2-10-重命名文件"><a href="#2-10-重命名文件" class="headerlink" title="2.10 重命名文件"></a>2.10 重命名文件</h3><p>使用 <code>ren [旧文件名] [新文件名]</code> 重命名文件。例如，将 <code>oldfile.txt</code> 重命名为 <code>newfile.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren oldfile.txt newfile.txt</span><br></pre></td></tr></table></figure><hr><h2 id="系统信息获取命令"><a href="#系统信息获取命令" class="headerlink" title="系统信息获取命令"></a>系统信息获取命令</h2><h3 id="3-1-查看系统信息"><a href="#3-1-查看系统信息" class="headerlink" title="3.1 查看系统信息"></a>3.1 查看系统信息</h3><p>使用 <code>systeminfo</code> 显示计算机的详细信息（操作系统版本、内存、网络适配器等）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><h3 id="3-2-查看当前用户"><a href="#3-2-查看当前用户" class="headerlink" title="3.2 查看当前用户"></a>3.2 查看当前用户</h3><p>使用 <code>whoami</code> 显示当前登录的用户名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><h3 id="3-3-查看计算机名"><a href="#3-3-查看计算机名" class="headerlink" title="3.3 查看计算机名"></a>3.3 查看计算机名</h3><p>使用 <code>hostname</code> 显示计算机的主机名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure><h3 id="3-4-查看进程列表"><a href="#3-4-查看进程列表" class="headerlink" title="3.4 查看进程列表"></a>3.4 查看进程列表</h3><p>使用 <code>tasklist</code> 列出当前运行的所有进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><h3 id="3-5-结束进程"><a href="#3-5-结束进程" class="headerlink" title="3.5 结束进程"></a>3.5 结束进程</h3><p>使用 <code>taskkill /IM [进程名] /F</code> 强制结束指定进程。例如，结束 <code>notepad.exe</code> 进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /IM notepad.exe /F</span><br></pre></td></tr></table></figure><hr><h2 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h2><h3 id="4-1-查看-IP-配置"><a href="#4-1-查看-IP-配置" class="headerlink" title="4.1 查看 IP 配置"></a>4.1 查看 IP 配置</h3><p>使用 <code>ipconfig</code> 显示计算机的 IP 地址、子网掩码和默认网关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><h3 id="4-2-刷新-IP-地址"><a href="#4-2-刷新-IP-地址" class="headerlink" title="4.2 刷新 IP 地址"></a>4.2 刷新 IP 地址</h3><p>使用以下命令释放并更新 DHCP 分配的 IP 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /release</span><br><span class="line">ipconfig /renew</span><br></pre></td></tr></table></figure><h3 id="4-3-查看网络连接"><a href="#4-3-查看网络连接" class="headerlink" title="4.3 查看网络连接"></a>4.3 查看网络连接</h3><p>使用 <code>netstat</code> 显示当前所有网络连接和监听端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br></pre></td></tr></table></figure><h3 id="4-4-测试网络连接"><a href="#4-4-测试网络连接" class="headerlink" title="4.4 测试网络连接"></a>4.4 测试网络连接</h3><p>使用 <code>ping [IP 地址或域名]</code> 测试网络连接。例如，测试与 Google 的连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.google.com</span><br></pre></td></tr></table></figure><h3 id="4-5-追踪路由"><a href="#4-5-追踪路由" class="headerlink" title="4.5 追踪路由"></a>4.5 追踪路由</h3><p>使用 <code>tracert [IP 地址或域名]</code> 追踪网络路由。例如，追踪到 Google 的路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert www.google.com</span><br></pre></td></tr></table></figure><hr><h2 id="磁盘和文件系统操作命令"><a href="#磁盘和文件系统操作命令" class="headerlink" title="磁盘和文件系统操作命令"></a>磁盘和文件系统操作命令</h2><h3 id="5-1-查看磁盘使用情况"><a href="#5-1-查看磁盘使用情况" class="headerlink" title="5.1 查看磁盘使用情况"></a>5.1 查看磁盘使用情况</h3><p>使用以下命令显示每个逻辑磁盘的总大小和可用空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic logicaldisk get size,freespace,caption</span><br></pre></td></tr></table></figure><h3 id="5-2-格式化磁盘"><a href="#5-2-格式化磁盘" class="headerlink" title="5.2 格式化磁盘"></a>5.2 格式化磁盘</h3><p>使用 <code>format [驱动器:] /FS:[文件系统]</code> 格式化磁盘。例如，将 D 盘格式化为 NTFS 文件系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format D: /FS:NTFS</span><br></pre></td></tr></table></figure><h3 id="5-3-检查磁盘错误"><a href="#5-3-检查磁盘错误" class="headerlink" title="5.3 检查磁盘错误"></a>5.3 检查磁盘错误</h3><p>使用 <code>chkdsk [驱动器:]</code> 检查磁盘错误。例如，检查 C 盘错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkdsk C:</span><br></pre></td></tr></table></figure><h3 id="5-4-显示磁盘分区信息"><a href="#5-4-显示磁盘分区信息" class="headerlink" title="5.4 显示磁盘分区信息"></a>5.4 显示磁盘分区信息</h3><p>使用 <code>diskpart</code> 进入 DiskPart 工具，然后在提示符下输入 <code>list disk</code> 查看所有磁盘信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskpart</span><br></pre></td></tr></table></figure><hr><h2 id="批处理文件"><a href="#批处理文件" class="headerlink" title="批处理文件"></a>批处理文件</h2><p>批处理文件是包含多个 CMD 命令的文本文件，便于一次性执行一系列命令。</p><h3 id="6-1-创建批处理文件"><a href="#6-1-创建批处理文件" class="headerlink" title="6.1 创建批处理文件"></a>6.1 创建批处理文件</h3><p>使用文本编辑器（如 Notepad）创建一个 <code>.bat</code> 文件，并输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo Hello, World!</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="6-2-运行批处理文件"><a href="#6-2-运行批处理文件" class="headerlink" title="6.2 运行批处理文件"></a>6.2 运行批处理文件</h3><p>双击 <code>.bat</code> 文件，或在 CMD 中输入文件路径来运行该文件。</p><hr><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="7-1-查看环境变量"><a href="#7-1-查看环境变量" class="headerlink" title="7.1 查看环境变量"></a>7.1 查看环境变量</h3><p>使用 <code>set</code> 命令显示所有环境变量及其值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure><h3 id="7-2-设置环境变量"><a href="#7-2-设置环境变量" class="headerlink" title="7.2 设置环境变量"></a>7.2 设置环境变量</h3><p>使用 <code>set [变量名]=[值]</code> 设置环境变量。例如，设置名为 <code>MY_VAR</code> 的环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MY_VAR=Hello</span><br></pre></td></tr></table></figure><h3 id="7-3-删除环境变量"><a href="#7-3-删除环境变量" class="headerlink" title="7.3 删除环境变量"></a>7.3 删除环境变量</h3><p>将环境变量值设为空即可删除。例如，删除 <code>MY_VAR</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MY_VAR=</span><br></pre></td></tr></table></figure><hr><h2 id="CMD-高级技巧"><a href="#CMD-高级技巧" class="headerlink" title="CMD 高级技巧"></a>CMD 高级技巧</h2><h3 id="8-1-使用管道"><a href="#8-1-使用管道" class="headerlink" title="8.1 使用管道"></a>8.1 使用管道</h3><p>管道符号 <code>|</code> 可将一个命令的输出传递给另一个命令。例如，查找进程列表中包含 “chrome” 的进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | find &quot;chrome&quot;</span><br></pre></td></tr></table></figure><h3 id="8-2-使用重定向"><a href="#8-2-使用重定向" class="headerlink" title="8.2 使用重定向"></a>8.2 使用重定向</h3><p>重定向符 <code>&gt;</code> 可将命令的输出保存到文件中。例如，将 <code>dir</code> 命令的输出保存到 <code>output.txt</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir &gt; output.txt</span><br></pre></td></tr></table></figure><h3 id="8-3-批量重命名文件"><a href="#8-3-批量重命名文件" class="headerlink" title="8.3 批量重命名文件"></a>8.3 批量重命名文件</h3><p>使用 <code>for</code> 循环批量重命名文件。例如，将当前目录下的所有 <code>.txt</code> 文件重命名为 <code>.bak</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for %f in (*.txt) do ren &quot;%f&quot; &quot;*.bak&quot;</span><br></pre></td></tr></table></figure><p><em>注：在批处理文件中使用 for 循环时，需将 <code>%f</code> 替换为 <code>%%f</code>。</em></p><hr><h2 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h2><h3 id="9-1-CMD-无法识别命令"><a href="#9-1-CMD-无法识别命令" class="headerlink" title="9.1 CMD 无法识别命令"></a>9.1 CMD 无法识别命令</h3><ul><li>如果 CMD 提示 “不是内部或外部命令”，可能是因为命令输入错误或相应程序未安装。</li></ul><h3 id="9-2-权限不足"><a href="#9-2-权限不足" class="headerlink" title="9.2 权限不足"></a>9.2 权限不足</h3><ul><li>某些命令需要管理员权限。请右键点击 CMD 图标，选择“以管理员身份运行”。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了 CMD 的基本命令、文件和目录操作、系统信息获取、网络配置等内容。通过具体示例和操作说明，帮助你更好地理解和掌握 CMD 的使用。希望这份 CMD 命令大全能帮助你提高工作效率，成为 CMD 使用的高手！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task3 Android Diary</title>
      <link href="/2025/03/05/Task3-Diary/"/>
      <url>/2025/03/05/Task3-Diary/</url>
      
        <content type="html"><![CDATA[<h1 id="MY-API-KEY-和风"><a href="#MY-API-KEY-和风" class="headerlink" title="MY API KEY(和风)"></a>MY API KEY(和风)</h1><p>670ca929136a456992608cd2e794df24</p><h1 id="Mainactivity"><a href="#Mainactivity" class="headerlink" title="Mainactivity"></a>Mainactivity</h1><h2 id="超级好的Mainactivity"><a href="#超级好的Mainactivity" class="headerlink" title="超级好的Mainactivity"></a>超级好的Mainactivity</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line"></span><br><span class="line">import androidx.core.widget.addTextChangedListener</span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.BroadcastReceiver</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.IntentFilter</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line">import androidx.appcompat.app.AlertDialog</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.Observer</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import com.example.diary_3.adapter.DiaryAdapter</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityMainBinding</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var binding: ActivityMainBinding</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line">    private val addDiaryLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">        when (result.resultCode) &#123;</span><br><span class="line">            Activity.RESULT_OK -&gt; loadAllDiaries()</span><br><span class="line">            Activity.RESULT_CANCELED -&gt; &#123;&#125;</span><br><span class="line">            else -&gt; Log.d(&quot;MainActivity&quot;, &quot;未知的返回结果: $&#123;result.resultCode&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private val diarySavedReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            if (intent?.action == &quot;SAVED&quot;) &#123;</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        binding.recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line">        diaryAdapter = DiaryAdapter(this, emptyList())</span><br><span class="line">        binding.recyclerView.adapter = diaryAdapter</span><br><span class="line"></span><br><span class="line">        val filter = IntentFilter(&quot;SAVED&quot;)</span><br><span class="line">        registerReceiver(diarySavedReceiver, filter)</span><br><span class="line"></span><br><span class="line">        loadAllDiaries()</span><br><span class="line"></span><br><span class="line">        // 监听搜索框</span><br><span class="line">        binding.searchBox.addTextChangedListener &#123; text -&gt;</span><br><span class="line">            searchDiaries(text.toString())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 启动添加日记页面</span><br><span class="line">        binding.addDiaryButton.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this, AddDiaryActivity::class.java)</span><br><span class="line">            addDiaryLauncher.launch(intent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 绑定删除按钮</span><br><span class="line">        binding.deleteDiaryButton.setOnClickListener &#123;</span><br><span class="line">            deleteDiary()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除日记的方法</span><br><span class="line">    private fun deleteDiary() &#123;</span><br><span class="line">        val diaries = diaryAdapter.getCurrentDiaries()</span><br><span class="line">        if (diaries.isEmpty()) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;当前没有日记可删除&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val diaryTitles = diaries.map &#123; it.title &#125;.toTypedArray()</span><br><span class="line">        var selectedIndex = 0</span><br><span class="line"></span><br><span class="line">        AlertDialog.Builder(this)</span><br><span class="line">            .setTitle(&quot;选择要删除的日记&quot;)</span><br><span class="line">            .setSingleChoiceItems(diaryTitles, 0) &#123; _, which -&gt;</span><br><span class="line">                selectedIndex = which</span><br><span class="line">            &#125;</span><br><span class="line">            .setPositiveButton(&quot;删除&quot;) &#123; _, _ -&gt;</span><br><span class="line">                val diaryToDelete = diaries[selectedIndex]</span><br><span class="line">                lifecycleScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">                    diaryDatabase.diaryDao().deleteDiary(diaryToDelete)</span><br><span class="line">                    withContext(Dispatchers.Main) &#123;</span><br><span class="line">                        loadAllDiaries()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .setNegativeButton(&quot;取消&quot;, null)</span><br><span class="line">            .show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加载所有日记</span><br><span class="line">    private fun loadAllDiaries() &#123;</span><br><span class="line">        diaryDatabase.diaryDao().getDiaries().observe(this, Observer &#123; diaries -&gt;</span><br><span class="line">            diaryAdapter.updateData(diaries) // 更新数据</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 搜索日记</span><br><span class="line">    private fun searchDiaries(query: String) &#123;</span><br><span class="line">        diaryDatabase.diaryDao().searchDiaries(&quot;%$query%&quot;)</span><br><span class="line">            .observe(this, Observer &#123; diaries -&gt;</span><br><span class="line">                diaryAdapter.updateData(diaries)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        unregisterReceiver(diarySavedReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line">import androidx.core.widget.addTextChangedListener</span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.BroadcastReceiver</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.IntentFilter</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.text.Editable</span><br><span class="line">import android.text.TextWatcher</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line">import androidx.annotation.RequiresApi</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import androidx.room.InvalidationTracker</span><br><span class="line">import com.example.diary_3.adapter.DiaryAdapter</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityMainBinding</span><br><span class="line">import java.util.concurrent.Executors</span><br><span class="line">import kotlinx.coroutines.CoroutineScope</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line">import androidx.lifecycle.Observer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var binding: ActivityMainBinding</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private val addDiaryLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">        when (result.resultCode) &#123;</span><br><span class="line">            Activity.RESULT_OK -&gt; &#123;</span><br><span class="line">                // 如果有返回结果，刷新数据</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">            Activity.RESULT_CANCELED -&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; &#123;</span><br><span class="line">                // 处理其他可能的返回情况</span><br><span class="line">                Log.d(&quot;MainActivity&quot;, &quot;未知的返回结果: $&#123;result.resultCode&#125;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private val diarySavedReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            if (intent?.action == &quot;SAVED&quot;) &#123;</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//gl gd</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        binding.recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line">        diaryAdapter = DiaryAdapter(this, emptyList())</span><br><span class="line">        binding.recyclerView.adapter = diaryAdapter</span><br><span class="line">        val filter = IntentFilter(&quot;SAVED&quot;)</span><br><span class="line">        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) &#123;</span><br><span class="line">            registerReceiver(diarySavedReceiver, filter, Context.RECEIVER_NOT_EXPORTED)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            registerReceiver(diarySavedReceiver, filter, RECEIVER_NOT_EXPORTED)</span><br><span class="line">        &#125;//ys5 gd</span><br><span class="line">        loadAllDiaries()</span><br><span class="line">        binding.searchBox.addTextChangedListener &#123; text -&gt;</span><br><span class="line">            searchDiaries(text.toString())</span><br><span class="line">        &#125;//ys3 gd</span><br><span class="line">        // 使用 ActivityResultLauncher 启动 AddDiaryActivity</span><br><span class="line">        binding.addDiaryButton.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this, AddDiaryActivity::class.java)</span><br><span class="line">            addDiaryLauncher.launch(intent)</span><br><span class="line">        &#125;//ys4 gd</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun loadAllDiaries() &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            val diaries = withContext(Dispatchers.IO) &#123;</span><br><span class="line">                diaryDatabase.diaryDao().getAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">            diaryAdapter.updateData(diaries) // 更新数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//ys8 gd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun searchDiaries(query: String) &#123;</span><br><span class="line">        diaryDatabase.diaryDao().searchDiaries(&quot;%$query%&quot;)</span><br><span class="line">            .observe(this, object : Observer&lt;List&lt;Diary&gt;&gt; &#123;</span><br><span class="line">                override fun onChanged(diaries: List&lt;Diary&gt;) &#123;</span><br><span class="line">                    diaryAdapter = DiaryAdapter(this@MainActivity, diaries)</span><br><span class="line">                    binding.recyclerView.adapter = diaryAdapter</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;//ys9 gd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        unregisterReceiver(diarySavedReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="AddDiaryActivity"><a href="#AddDiaryActivity" class="headerlink" title="AddDiaryActivity"></a>AddDiaryActivity</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line">import androidx.appcompat.app.AlertDialog</span><br><span class="line">import android.view.View</span><br><span class="line">import android.widget.EditText</span><br><span class="line">import com.example.diary_3.utils.DateUtils</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.pm.PackageManager</span><br><span class="line">import android.net.Uri</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.os.Looper</span><br><span class="line">import android.provider.MediaStore</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.core.app.ActivityCompat</span><br><span class="line">import androidx.core.content.ContextCompat</span><br><span class="line">import com.bumptech.glide.Glide</span><br><span class="line">import com.bumptech.glide.request.RequestOptions</span><br><span class="line">import com.example.diary_3.R</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityAddDiaryBinding</span><br><span class="line">import com.example.diary_3.model.CityResponse</span><br><span class="line">import com.example.diary_3.model.WeatherResponse</span><br><span class="line">import com.example.diary_3.network.RetrofitClient</span><br><span class="line">import com.example.diary_3.network.WeatherApi</span><br><span class="line">import com.example.diary_3.utils.LocationUtils</span><br><span class="line">import retrofit2.Call</span><br><span class="line">import retrofit2.Callback</span><br><span class="line">import retrofit2.Response</span><br><span class="line">import java.util.Calendar</span><br><span class="line">import java.util.concurrent.Executors</span><br><span class="line"></span><br><span class="line">class AddDiaryActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val selectedLocalImageUris = mutableListOf&lt;Uri&gt;()</span><br><span class="line">    private val networkImageUrls = mutableListOf&lt;String&gt;()</span><br><span class="line">    private val API_KEY = &quot;670ca929136a456992608cd2e794df24&quot;</span><br><span class="line">    private lateinit var binding: ActivityAddDiaryBinding</span><br><span class="line">    private var selectedDate: Calendar = Calendar.getInstance()</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var locationUtils: LocationUtils</span><br><span class="line">    private val PERMISSION_REQUEST_CODE = 1</span><br><span class="line">    private var selectedLocalImageUri: Uri? = null</span><br><span class="line">    private var networkImageUrl: String? = null</span><br><span class="line"></span><br><span class="line">    private fun hasPermission(permission: String): Boolean &#123;</span><br><span class="line">        return ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityAddDiaryBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        locationUtils = LocationUtils(this)</span><br><span class="line"></span><br><span class="line">        binding.selectImageButton.setOnClickListener &#123;</span><br><span class="line">            pickLocalImage()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binding.addNetworkImageButton.setOnClickListener &#123;</span><br><span class="line">            // 创建一个输入框</span><br><span class="line">            val input = EditText(this)</span><br><span class="line">            input.hint = &quot;请输入有效的图片链接&quot;</span><br><span class="line"></span><br><span class="line">            // 构建对话框</span><br><span class="line">            AlertDialog.Builder(this)</span><br><span class="line">                .setTitle(&quot;输入图片URL&quot;)</span><br><span class="line">                .setView(input)</span><br><span class="line">                .setPositiveButton(&quot;确定&quot;) &#123; dialog, which -&gt;</span><br><span class="line">                    val url = input.text.toString().trim()</span><br><span class="line">                    if (url.isNotBlank()) &#123;</span><br><span class="line">                        networkImageUrl = url</span><br><span class="line">                        Glide.with(this)</span><br><span class="line">                            .load(url)</span><br><span class="line">                            .placeholder(R.drawable.loading_placeholder) // 加载过程中的占位符图片</span><br><span class="line">                            .apply(RequestOptions.circleCropTransform())</span><br><span class="line">                            .error(R.drawable.no) // 加载失败时显示的图片</span><br><span class="line">                            .into(binding.selectedImageView)</span><br><span class="line">                        binding.selectedImageView.visibility = View.VISIBLE</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Toast.makeText(this, &quot;请输入有效的图片链接&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                        binding.selectedImageView.visibility = View.GONE</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .setNegativeButton(&quot;取消&quot;) &#123; dialog, which -&gt;</span><br><span class="line">                    dialog.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">                .show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binding.saveDiaryButton.setOnClickListener &#123;</span><br><span class="line">            saveDiary()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 新增按钮：点击刷新地点和天气</span><br><span class="line">        binding.refreshWeatherLocationButton.setOnClickListener &#123;</span><br><span class="line">            getLocation()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val permissionsToRequest = mutableListOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        if (!hasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION)) &#123;</span><br><span class="line">            permissionsToRequest.add(android.Manifest.permission.ACCESS_FINE_LOCATION)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!hasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">            permissionsToRequest.add(android.Manifest.permission.READ_EXTERNAL_STORAGE)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (permissionsToRequest.isNotEmpty()) &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(</span><br><span class="line">                this,</span><br><span class="line">                permissionsToRequest.toTypedArray(),</span><br><span class="line">                PERMISSION_REQUEST_CODE</span><br><span class="line">            )</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            getLocation()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun pickLocalImage() &#123;</span><br><span class="line">        val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)</span><br><span class="line">        startActivityForResult(intent, 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123;</span><br><span class="line">        super.onActivityResult(requestCode, resultCode, data)</span><br><span class="line"></span><br><span class="line">        if (requestCode == 1 &amp;&amp; resultCode == RESULT_OK &amp;&amp; data != null) &#123;</span><br><span class="line">            selectedLocalImageUri = data.data</span><br><span class="line">            Glide.with(this)</span><br><span class="line">                .load(selectedLocalImageUri)</span><br><span class="line">                .into(binding.selectedImageView)</span><br><span class="line">            binding.selectedImageView.visibility = android.view.View.VISIBLE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getLocation() &#123;</span><br><span class="line">        locationUtils.getLocation &#123; location -&gt;</span><br><span class="line">            if (location != null) &#123;</span><br><span class="line">                val latitude = location.latitude</span><br><span class="line">                val longitude = location.longitude</span><br><span class="line">                Log.d(&quot;AddDiaryActivity&quot;, &quot;获取到的经纬度: 纬度 $latitude, 经度 $longitude&quot;)</span><br><span class="line">                // 格式化经纬度字符串，注意这里 longitude 和 latitude 的顺序可以根据接口要求调整</span><br><span class="line">                val loc = String.format(&quot;%.2f,%.2f&quot;, location.longitude, location.latitude)</span><br><span class="line">                Executors.newSingleThreadExecutor().execute &#123;</span><br><span class="line">                    runOnUiThread &#123;</span><br><span class="line">                        binding.locationTextView.text = loc</span><br><span class="line">                        getCityId(loc)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                runOnUiThread &#123;</span><br><span class="line">                    Toast.makeText(this, &quot;无法获取当前位置&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun showToastOnUiThread(message: String) &#123;</span><br><span class="line">        if (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                Toast.makeText(this, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getCityId(cityName: String) &#123;</span><br><span class="line">        val weatherApi = RetrofitClient.geoInstance.create(WeatherApi::class.java)</span><br><span class="line">        weatherApi.getCityInfo(API_KEY, cityName).enqueue(object : Callback&lt;CityResponse&gt; &#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;CityResponse&gt;, response: Response&lt;CityResponse&gt;) &#123;</span><br><span class="line">                if (response.isSuccessful &amp;&amp; response.body()?.code == &quot;200&quot;) &#123;</span><br><span class="line">                    val cityLocation = response.body()?.location?.firstOrNull()</span><br><span class="line">                    if (cityLocation != null) &#123;</span><br><span class="line">                        binding.locationTextView.text = cityLocation.name</span><br><span class="line">                        getWeatherInfo(cityLocation.id)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.e(&quot;AddDiaryActivity&quot;, &quot;获取城市 ID 失败: $&#123;response.message()&#125;, 响应代码: $&#123;response.code()&#125;, 响应体: $&#123;response.errorBody()?.string()&#125;&quot;)</span><br><span class="line">                    showToastOnUiThread(&quot;获取城市 ID 失败&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;CityResponse&gt;, t: Throwable) &#123;</span><br><span class="line">                Log.e(&quot;AddDiaryActivity&quot;, &quot;获取城市 ID 网络请求失败: $&#123;t.message&#125;&quot;, t)</span><br><span class="line">                showToastOnUiThread(&quot;获取城市 ID 网络请求失败&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getWeatherInfo(cityId: String) &#123;</span><br><span class="line">        val weatherApi = RetrofitClient.weatherInstance.create(WeatherApi::class.java)</span><br><span class="line">        weatherApi.getWeatherInfo(API_KEY, cityId).enqueue(object : Callback&lt;WeatherResponse&gt; &#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;WeatherResponse&gt;, response: Response&lt;WeatherResponse&gt;) &#123;</span><br><span class="line">                if (response.isSuccessful &amp;&amp; response.body()?.code == &quot;200&quot;) &#123;</span><br><span class="line">                    val today = DateUtils.formatDate(Calendar.getInstance().time)</span><br><span class="line">                    val todayWeather = response.body()?.daily?.firstOrNull &#123; it.fxDate == today &#125;</span><br><span class="line">                    if (todayWeather != null) &#123;</span><br><span class="line">                        val weatherText = todayWeather.textDay</span><br><span class="line">                        binding.weatherTextView.text = weatherText</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.e(&quot;AddDiaryActivity&quot;, &quot;获取天气信息失败: $&#123;response.message()&#125;, 响应代码: $&#123;response.code()&#125;, 响应体: $&#123;response.errorBody()?.string()&#125;&quot;)</span><br><span class="line">                    showToastOnUiThread(&quot;获取天气信息失败&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;WeatherResponse&gt;, t: Throwable) &#123;</span><br><span class="line">                Log.e(&quot;AddDiaryActivity&quot;, &quot;获取天气信息网络请求失败: $&#123;t.message&#125;&quot;, t)</span><br><span class="line">                showToastOnUiThread(&quot;获取天气信息网络请求失败&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun saveDiary() &#123;</span><br><span class="line">        Executors.newSingleThreadExecutor().execute &#123;</span><br><span class="line">            val title = binding.titleEditText.text.toString()</span><br><span class="line">            val content = binding.contentEditText.text.toString()</span><br><span class="line">            val localImagePath = selectedLocalImageUri?.toString()</span><br><span class="line">            val date = DateUtils.formatDate(Calendar.getInstance().time)</span><br><span class="line">            val weather = binding.weatherTextView.text.toString()</span><br><span class="line">            val location = binding.locationTextView.text.toString()</span><br><span class="line"></span><br><span class="line">            val diary = Diary(</span><br><span class="line">                title = title,</span><br><span class="line">                content = content,</span><br><span class="line">                localImagePath = localImagePath,</span><br><span class="line">                networkImageUrl = networkImageUrl,</span><br><span class="line">                date = date,</span><br><span class="line">                weather = weather,</span><br><span class="line">                location = location</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            diaryDatabase.diaryDao().insertDiary(diary)</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                Toast.makeText(this, &quot;日记保存成功&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                val intent = Intent(&quot;SAVED&quot;) // 或者 &quot;com.example.app.DIARY_SAVED&quot;</span><br><span class="line">                sendBroadcast(intent)</span><br><span class="line">                finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="DetailUtils"><a href="#DetailUtils" class="headerlink" title="DetailUtils"></a>DetailUtils</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final.utils</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Date</span><br><span class="line">import java.util.Locale</span><br><span class="line"></span><br><span class="line">object DateUtils &#123;</span><br><span class="line">    private const val DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;</span><br><span class="line"></span><br><span class="line">    // 线程安全的 SimpleDateFormat 生成</span><br><span class="line">    private fun getDateFormat(pattern: String): SimpleDateFormat &#123;</span><br><span class="line">        return SimpleDateFormat(pattern, Locale.getDefault())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 格式化日期（默认格式 &quot;yyyy-MM-dd&quot;）</span><br><span class="line">    fun formatDate(date: Date, pattern: String = DEFAULT_DATE_FORMAT): String &#123;</span><br><span class="line">        return getDateFormat(pattern).format(date)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取当前日期的格式化字符串</span><br><span class="line">    fun getCurrentDate(pattern: String = DEFAULT_DATE_FORMAT): String &#123;</span><br><span class="line">        return formatDate(Date(), pattern)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LocationUtils"><a href="#LocationUtils" class="headerlink" title="LocationUtils"></a>LocationUtils</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final.utils</span><br><span class="line"></span><br><span class="line">import android.Manifest</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.pm.PackageManager</span><br><span class="line">import android.location.Location</span><br><span class="line">import android.location.LocationListener</span><br><span class="line">import android.location.LocationManager</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.core.app.ActivityCompat</span><br><span class="line"></span><br><span class="line">class LocationUtils(private val context: Context) &#123;</span><br><span class="line"></span><br><span class="line">    private val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager</span><br><span class="line">    private var locationListener: LocationListener? = null</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前位置</span><br><span class="line">     */</span><br><span class="line">    fun getLocation(onLocationReceived: (Location) -&gt; Unit) &#123;</span><br><span class="line">        // 权限检查</span><br><span class="line">        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;</span><br><span class="line">            ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">        ) &#123;</span><br><span class="line">            return // 没有权限，直接返回</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取上次已知位置（可能会加快首次获取速度）</span><br><span class="line">        val lastKnownLocation: Location? = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER)</span><br><span class="line">            ?: locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)</span><br><span class="line">        if (lastKnownLocation != null) &#123;</span><br><span class="line">            onLocationReceived(lastKnownLocation)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 监听实时位置更新</span><br><span class="line">        locationListener = object : LocationListener &#123;</span><br><span class="line">            override fun onLocationChanged(location: Location) &#123;</span><br><span class="line">                onLocationReceived(location)</span><br><span class="line">                removeLocationUpdates() // 获取到位置后移除监听</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) &#123;&#125;</span><br><span class="line">            override fun onProviderEnabled(provider: String) &#123;&#125;</span><br><span class="line">            override fun onProviderDisabled(provider: String) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 请求位置更新（优先使用 GPS，网络作为备用）</span><br><span class="line">        try &#123;</span><br><span class="line">            locationManager.requestLocationUpdates(</span><br><span class="line">                LocationManager.GPS_PROVIDER,</span><br><span class="line">                5000L, // 5秒更新一次</span><br><span class="line">                10f,   // 10米变化更新</span><br><span class="line">                locationListener!!</span><br><span class="line">            )</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            locationManager.requestLocationUpdates(</span><br><span class="line">                LocationManager.NETWORK_PROVIDER,</span><br><span class="line">                5000L,</span><br><span class="line">                10f,</span><br><span class="line">                locationListener!!</span><br><span class="line">            )</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除位置更新监听，防止内存泄漏</span><br><span class="line">     */</span><br><span class="line">    fun removeLocationUpdates() &#123;</span><br><span class="line">        locationListener?.let &#123;</span><br><span class="line">            locationManager.removeUpdates(it)</span><br><span class="line">            locationListener = null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin语法</title>
      <link href="/2025/03/03/Kotlin%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/03/Kotlin%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一-apply、let、run、also、with"><a href="#一-apply、let、run、also、with" class="headerlink" title="一.apply、let、run、also、with"></a>一.apply、let、run、also、with</h1><p>Kotlin 提供了一些 <strong>作用域函数（Scope Functions）</strong>，比如 <code>apply</code>、<code>let</code>、<code>run</code>、<code>also</code> 和 <code>with</code>，它们可以让代码更加简洁，提高可读性。这些函数的主要作用是<strong>在对象的特定作用域内执行代码</strong>，避免重复引用对象（如 <code>this</code> 或 <code>it</code>）。</p><h2 id="1-apply：在对象自身作用域内修改对象"><a href="#1-apply：在对象自身作用域内修改对象" class="headerlink" title="1. apply：在对象自身作用域内修改对象"></a>1. apply：在对象自身作用域内修改对象</h2><p><code>apply</code> <strong>返回调用者本身（this）</strong>，适用于对对象执行一系列 <strong>修改操作</strong> 后返回自身。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li><strong>用于初始化对象</strong>，避免多次调用对象的 <code>set</code> 方法。</li><li><strong>链式调用</strong>，让代码更流畅。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val person = Person().apply &#123;</span><br><span class="line">    name = &quot;Alice&quot;</span><br><span class="line">    age = 20</span><br><span class="line">&#125;</span><br><span class="line">println(person.name) // Alice</span><br><span class="line">println(person.age)  // 20</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li><code>apply</code> 作用在 <code>Person</code> 对象上，<code>this</code> 代表 <code>Person</code> 本身。</li><li><strong>直接在 <code>apply</code> 的代码块内修改对象的属性</strong>，最终 <code>apply</code> <strong>返回该对象本身</strong>，所以 <code>person</code> 仍然是 <code>Person</code> 类型。</li></ul><h2 id="2-let：适用于非空值的操作"><a href="#2-let：适用于非空值的操作" class="headerlink" title="2. let：适用于非空值的操作"></a>2. let：适用于非空值的操作</h2><p><code>let</code> <strong>返回最后一行的值</strong>，<strong>适用于可空对象</strong>，可以避免 <code>NullPointerException</code>。</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li><strong>避免 <code>null</code> 检查</strong>，简化 <code>?.</code> 操作符的逻辑。</li><li><strong>链式调用</strong>，对值进行转换。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val name: String? = &quot;Kotlin&quot;</span><br><span class="line">name?.let &#123;</span><br><span class="line">    println(it.uppercase())  // KOTLIN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li><code>name?.let &#123;&#125;</code> 只有在 <code>name</code> <strong>不为空</strong> 时才会执行 <code>let</code> 代码块，<strong>如果 <code>name</code> 为空，则不会执行</strong>。</li><li><code>it</code> 代表 <code>name</code> 这个变量的值，因此 <code>it.uppercase()</code> 把 <code>name</code> 转换为大写。</li></ul><p><strong>另一种使用场景：变量作用域控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val number = 5</span><br><span class="line">val square = number.let &#123;</span><br><span class="line">    val result = it * it</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line">println(square) // 25</span><br></pre></td></tr></table></figure><ul><li><code>let</code> 代码块中的 <code>it</code> 代表 <code>number</code>，计算 <code>5 * 5</code> 并返回 <code>25</code>。</li></ul><h2 id="3-run：在对象作用域内执行代码并返回结果"><a href="#3-run：在对象作用域内执行代码并返回结果" class="headerlink" title="3. run：在对象作用域内执行代码并返回结果"></a>3. run：在对象作用域内执行代码并返回结果</h2><p><code>run</code> 结合了 <code>let</code> 和 <code>apply</code> 的特性，它在 <strong>对象作用域</strong> 内执行代码，并 <strong>返回最后一行的值</strong>。</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li>需要在对象上执行多个 <strong>计算操作</strong> 并返回值。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val person = Person().run &#123;</span><br><span class="line">    name = &quot;Bob&quot;</span><br><span class="line">    age = 25</span><br><span class="line">    &quot;名字是 $name, 年龄是 $age&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(person)  // 名字是 Bob, 年龄是 25</span><br></pre></td></tr></table></figure><ul><li><code>run</code> 作用在 <code>Person</code> 对象上，<code>this</code> 代表 <code>Person</code>，代码块内可以直接修改 <code>name</code> 和 <code>age</code>。</li><li>最后一行 <code>&quot;名字是 $name, 年龄是 $age&quot;</code> 作为返回值赋给 <code>person</code>。</li></ul><h2 id="4-also：适用于对象的额外操作"><a href="#4-also：适用于对象的额外操作" class="headerlink" title="4.also：适用于对象的额外操作"></a>4.also：适用于对象的额外操作</h2><p><code>also</code> <strong>返回调用者本身（this）</strong>，但和 <code>apply</code> 不同的是，<code>also</code> <strong>更适用于执行额外的副作用操作</strong>（比如 <strong>日志、打印、调试</strong>）。</p><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li><strong>记录日志</strong> 或 <strong>调试</strong>。</li><li><strong>不会修改对象本身</strong>，只是执行额外操作。</li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = mutableListOf(1, 2, 3).also &#123;</span><br><span class="line">    println(&quot;原始列表: $it&quot;) // 原始列表: [1, 2, 3]</span><br><span class="line">&#125;.apply &#123;</span><br><span class="line">    add(4)</span><br><span class="line">&#125;</span><br><span class="line">println(numbers) // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li><code>also</code> 代码块中的 <code>it</code> 是 <code>numbers</code>，<strong>不会改变 <code>numbers</code> 本身</strong>，只是用于打印日志。</li><li><code>apply</code> 修改了 <code>numbers</code>，最终 <code>numbers</code> 变为 <code>[1, 2, 3, 4]</code>。</li></ul><h2 id="5-with：用于非扩展对象的作用域调用"><a href="#5-with：用于非扩展对象的作用域调用" class="headerlink" title="5. with：用于非扩展对象的作用域调用"></a>5. with：用于非扩展对象的作用域调用</h2><p><code>with</code> <strong>不能直接调用</strong>，而是以普通函数的形式传递一个对象，然后在其作用域内执行代码，<strong>并返回最后一行的值</strong>。</p><h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li>适用于<strong>不需要返回对象本身</strong>的情况，而是要返回计算结果。</li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val person = Person()</span><br><span class="line">val result = with(person) &#123;</span><br><span class="line">    name = &quot;Charlie&quot;</span><br><span class="line">    age = 30</span><br><span class="line">    &quot;名字: $name, 年龄: $age&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(result)  // 名字: Charlie, 年龄: 30</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li><code>with(person) &#123;&#125;</code> 让 <code>person</code> 进入作用域，<code>this</code> 代表 <code>person</code>。</li><li>最后一行返回 <code>&quot;名字: Charlie, 年龄: 30&quot;</code>。</li></ul><h2 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h2><table><thead><tr><th>函数</th><th>适用场景</th><th>作用域内的 <code>this</code> 或 <code>it</code></th><th>返回值</th></tr></thead><tbody><tr><td><code>apply</code></td><td><strong>修改对象本身</strong></td><td><code>this</code></td><td><strong>对象本身</strong></td></tr><tr><td><code>let</code></td><td><strong>可空对象、临时变量作用域</strong></td><td><code>it</code></td><td><strong>Lambda 最后一行</strong></td></tr><tr><td><code>run</code></td><td><strong>需要返回计算结果</strong></td><td><code>this</code></td><td><strong>Lambda 最后一行</strong></td></tr><tr><td><code>also</code></td><td><strong>执行额外操作（日志&#x2F;调试）</strong></td><td><code>it</code></td><td><strong>对象本身</strong></td></tr><tr><td><code>with</code></td><td><strong>更传统的作用域调用</strong></td><td><code>this</code></td><td><strong>Lambda 最后一行</strong></td></tr></tbody></table><hr><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h2><ol><li><strong>如果要修改对象并返回它本身</strong> 👉 <code>apply</code></li><li><strong>如果是可空对象，避免 <code>null</code> 检查</strong> 👉 <code>let</code></li><li><strong>如果只想执行代码块后返回结果</strong> 👉 <code>run</code></li><li><strong>如果不修改对象，只是执行副作用（日志等）</strong> 👉 <code>also</code></li><li><strong>如果要在对象作用域执行代码，并返回结果</strong> 👉 <code>with</code></li></ol><p>你可以根据自己的代码需求选择合适的作用域函数，这样可以提高代码的可读性和简洁性 🚀。</p><h1 id="二-时间输出"><a href="#二-时间输出" class="headerlink" title="二.时间输出"></a>二.时间输出</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final</span><br><span class="line">import java.time.LocalTime</span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.time.LocalDateTime</span><br><span class="line">import java.util.Calendar</span><br><span class="line">import java.util.Date</span><br><span class="line">import java.util.Locale</span><br><span class="line">fun main()&#123;</span><br><span class="line">    val date = Date() // 获取当前时间</span><br><span class="line">    val sdf = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())</span><br><span class="line">   //将 Date 转换为格式化字符串（例如 2025-03-15 14:08:23）。</span><br><span class="line">    //format() 方法会按照 SimpleDateFormat 设定的规则解析 Date，并生成符合格式的字符串。</span><br><span class="line">    val formattedDate = sdf.format(date)</span><br><span class="line">    println(formattedDate)</span><br><span class="line">    println(sdf.format(date))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //以上是得到本机时间，以下是解析日期，即将字符串解析回Date类型</span><br><span class="line"></span><br><span class="line">    val dateString = &quot;2025-03-09 14:45:30&quot;</span><br><span class="line">    val sdfp = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())//Locale.getDefault()：获取当前设备的默认地区设置，确保格式符合本地习惯</span><br><span class="line"></span><br><span class="line">    val datep = sdfp.parse(dateString)</span><br><span class="line">    println(datep)  // 输出: Sun Mar 09 14:45:30 GMT 2025</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val calendar = Calendar.getInstance()</span><br><span class="line">    val hour = calendar.get(Calendar.HOUR_OF_DAY)</span><br><span class="line">    val minute = calendar.get(Calendar.MINUTE)</span><br><span class="line">    val second = calendar.get(Calendar.SECOND)</span><br><span class="line">    println(&quot;当前时间: $hour:$minute:$second&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val calendar2 = Calendar.getInstance()</span><br><span class="line">    val hour2 = calendar.get(Calendar.HOUR_OF_DAY) // 24 小时制</span><br><span class="line">    val minute2 = calendar.get(Calendar.MINUTE)</span><br><span class="line">    val second2 = calendar.get(Calendar.SECOND)</span><br><span class="line"></span><br><span class="line">    val formattedTime = String.format(&quot;%02d:%02d:%02d&quot;, hour2, minute2, second2)</span><br><span class="line">    println(&quot;当前时间: $formattedTime&quot;)</span><br><span class="line">    println(&quot;当前时间:  $&#123;String.format(&quot;%02d:%02d:%02d&quot;, hour2, minute2, second2)&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-回调"><a href="#三-回调" class="headerlink" title="三.回调"></a>三.回调</h1><h3 id="什么是回调（Callback）？"><a href="#什么是回调（Callback）？" class="headerlink" title="什么是回调（Callback）？"></a><strong>什么是回调（Callback）？</strong></h3><p>回调就是**“让我知道”**的意思。<br> 当你让别人去做一件事情，比如让朋友去买咖啡，你可能会说：</p><blockquote><p><strong>“买完后给我打个电话告诉我。”</strong></p></blockquote><p>这里的**“打电话”**就是回调。也就是说，任务完成后，<strong>通知你</strong> 结果。</p><p>在编程中，<strong>回调就是一个函数，它会在某个任务完成后被调用</strong>。</p><h3 id="举个简单的-Kotlin-例子"><a href="#举个简单的-Kotlin-例子" class="headerlink" title="举个简单的 Kotlin 例子"></a><strong>举个简单的 Kotlin 例子</strong></h3><p>假设你让你的朋友帮你去超市买东西，并且你告诉他：<strong>“买完记得告诉我。”</strong></p><p>我们用 Kotlin 代码来模拟这个场景：</p><h3 id="1-不使用回调（你只能等待）"><a href="#1-不使用回调（你只能等待）" class="headerlink" title="1. 不使用回调（你只能等待）"></a><strong>1. 不使用回调（你只能等待）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun buyGroceries() &#123;</span><br><span class="line">    Thread.sleep(2000) // 模拟买东西的时间（2秒）</span><br><span class="line">    println(&quot;买完了！&quot;) // 买完了才通知</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;请帮我去买东西...&quot;)</span><br><span class="line">    buyGroceries()</span><br><span class="line">    println(&quot;我收到通知了&quot;) // 只有等买完了，才继续执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>问题</strong>：<code>buyGroceries()</code> 运行时，<code>main()</code> 只能等着，不能干别的事情。</p><hr><h3 id="2-使用回调（买完后通知你，不用等）"><a href="#2-使用回调（买完后通知你，不用等）" class="headerlink" title="2. 使用回调（买完后通知你，不用等）"></a><strong>2. 使用回调（买完后通知你，不用等）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun buyGroceries(callback: () -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        Thread.sleep(2000) // 模拟买东西的时间</span><br><span class="line">        println(&quot;买完了！&quot;)</span><br><span class="line">        callback() // 买完后，通知你</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;请帮我去买东西...&quot;)</span><br><span class="line">    </span><br><span class="line">    buyGroceries &#123;</span><br><span class="line">        println(&quot;我收到通知了！&quot;) // 只有买完才执行</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(&quot;我可以做别的事情，不用等&quot;) // 这个可以立即执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>优势</strong>：你不需要干等，买东西的过程在后台进行，你可以继续做别的事情！等买完后，它会**回调（通知）**你。</p><hr><h3 id="回调在-Android-开发中的应用"><a href="#回调在-Android-开发中的应用" class="headerlink" title="回调在 Android 开发中的应用"></a><strong>回调在 Android 开发中的应用</strong></h3><h4 id="（1）按钮点击事件"><a href="#（1）按钮点击事件" class="headerlink" title="（1）按钮点击事件"></a><strong>（1）按钮点击事件</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    println(&quot;按钮被点击了！&quot;) // 这个就是回调，按钮被点击后执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>回调作用</strong>：当用户点击按钮时，系统<strong>回调</strong>你的代码。</p><h4 id="（2）网络请求"><a href="#（2）网络请求" class="headerlink" title="（2）网络请求"></a><strong>（2）网络请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun fetchData(callback: (String) -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        Thread.sleep(2000) // 模拟网络请求</span><br><span class="line">        callback(&quot;数据加载成功了哈哈哈！&quot;)</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;开始请求数据...&quot;)</span><br><span class="line">    //这里的result是数据加载成功了哈哈哈！</span><br><span class="line">    fetchData &#123; result -&gt;</span><br><span class="line">        println(result) // 2 秒后执行</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;请求已经发送，我先做别的事情&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>回调作用</strong>：数据还没回来时，程序不会等着，而是继续执行，数据回来后才回调你的代码。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>回调 &#x3D; 任务完成后通知你</strong></li><li><strong>没有回调</strong>：你只能干等着</li><li><strong>有回调</strong>：你可以继续干别的事情，等它完成后再通知你</li><li><strong>Android 里大量用回调</strong>：比如点击事件、网络请求、数据库查询等</li></ul><p>这样解释是不是更容易理解了？😃</p><h1 id="四-Lambda表达式"><a href="#四-Lambda表达式" class="headerlink" title="四.Lambda表达式"></a>四.Lambda表达式</h1><h3 id="什么是-Lambda-表达式？"><a href="#什么是-Lambda-表达式？" class="headerlink" title="什么是 Lambda 表达式？"></a>什么是 Lambda 表达式？</h3><p><strong>Lambda 表达式</strong>就是<strong>匿名函数</strong>，你可以把它看作没有名字的函数，通常用来做一些简单的操作。它的基本写法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; 参数 -&gt; 表达式 &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="举个简单的例子"><a href="#举个简单的例子" class="headerlink" title="举个简单的例子"></a>举个简单的例子</h3><p>假设我们想定义一个函数，用来将两个数字相加，我们可以这样写一个 lambda 表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 lambda 表达式，接收两个 Int 参数，返回它们的和</span><br><span class="line">val add: (Int, Int) -&gt; Int = &#123; a, b -&gt; a + b &#125;</span><br><span class="line"></span><br><span class="line">// 调用 lambda 表达式</span><br><span class="line">println(add(2, 3))  // 输出：5</span><br></pre></td></tr></table></figure><p>这里：</p><ul><li><code>val add: (Int, Int) -&gt; Int</code> 表示 <code>add</code> 是一个函数，它接受两个 <code>Int</code> 类型的参数，返回一个 <code>Int</code>。</li><li><code>&#123; a, b -&gt; a + b &#125;</code> 是 lambda 表达式，意思是“给定 a 和 b，就返回 a + b”。</li></ul><hr><h3 id="Lambda-表达式的实际应用"><a href="#Lambda-表达式的实际应用" class="headerlink" title="Lambda 表达式的实际应用"></a>Lambda 表达式的实际应用</h3><p>Lambda 表达式常常用在<strong>高阶函数</strong>中，也就是将函数作为参数传递给另一个函数。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个函数，接受一个操作函数作为参数</span><br><span class="line">fun calculate(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;</span><br><span class="line">    return operation(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    /* 等于val result = calculate(10, 5, &#123; x, y -&gt; x + y &#125;)，只是在 Kotlin 中，如果函数的最后一个参数是 lambda 表达式，可以使用尾随 lambda语法，把这个 lambda 写在圆括号外面。这种写法让代码更加简洁和易读。*/</span><br><span class="line">    val result = calculate(10, 5) &#123; x, y -&gt; x + y &#125;</span><br><span class="line">    println(result)  // 输出：15</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>calculate</code> 函数接受三个参数，其中第三个参数是一个函数（也就是 lambda 表达式）。</li><li>我们在调用 <code>calculate</code> 时，直接用 <code>&#123; x, y -&gt; x + y &#125;</code> 表示将 10 和 5 相加。</li></ul><hr><h3 id="如果只有一个参数怎么办？"><a href="#如果只有一个参数怎么办？" class="headerlink" title="如果只有一个参数怎么办？"></a>如果只有一个参数怎么办？</h3><p>当 lambda 表达式只有一个参数时，Kotlin 提供了一个默认的变量 <code>it</code> 来代表这个参数。例如，下面是对列表中的每个数字乘以 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">/*map 是集合的扩展函数，它会遍历集合中的每个元素，并将每个元素传递给 lambda 表达式进行转换，最后返回一个新的集合，包含所有转换后的结果。*/</span><br><span class="line">val doubled = numbers.map &#123; it * 2 &#125;</span><br><span class="line">println(doubled)  // 输出：[2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>这里：</p><ul><li><code>numbers.map &#123; it * 2 &#125;</code> 中，<code>it</code> 表示列表中的每个数字。</li></ul><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>Lambda 表达式</strong>是一种匿名函数的写法，用 <code>&#123; 参数 -&gt; 表达式 &#125;</code> 表示。</li><li>可以将 lambda 当做参数传递给其他函数，简化代码。</li><li>当只有一个参数时，可以用 <code>it</code> 代替。</li></ol><h1 id="五-泛型与委托"><a href="#五-泛型与委托" class="headerlink" title="五.泛型与委托"></a>五.泛型与委托</h1><hr><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>泛型</strong>使得类、接口和函数可以针对任意类型进行编程，从而提高代码的复用性和类型安全性。泛型允许在类或函数中使用类型参数，而不必在写代码时就确定具体类型。</p><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个泛型类 Box，它可以存放任意类型的数据</span><br><span class="line">class Box&lt;T&gt;(var value: T)</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val intBox = Box(123)     // T 被推断为 Int</span><br><span class="line">    val strBox = Box(&quot;Hello&quot;) // T 被推断为 String</span><br><span class="line"></span><br><span class="line">    println(intBox.value) // 输出：123</span><br><span class="line">    println(strBox.value) // 输出：Hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个泛型函数，返回一个只包含一个元素的列表</span><br><span class="line">fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123;</span><br><span class="line">    return listOf(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val numbers = singletonList(42)       // T 被推断为 Int</span><br><span class="line">    val words = singletonList(&quot;Kotlin&quot;)     // T 被推断为 String</span><br><span class="line"></span><br><span class="line">    println(numbers) // 输出：[42]</span><br><span class="line">    println(words)   // 输出：[Kotlin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型参数的限定"><a href="#类型参数的限定" class="headerlink" title="类型参数的限定"></a>类型参数的限定</h3><p>可以通过指定类型上界来限制类型参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 泛型 T 只接受 Number 或 Number 的子类</span><br><span class="line">fun &lt;T : Number&gt; add(a: T, b: T): Double &#123;</span><br><span class="line">    return a.toDouble() + b.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(add(10, 20))      // 输出：30.0</span><br><span class="line">    // println(add(&quot;a&quot;, &quot;b&quot;)) // 编译错误，String 不是 Number 的子类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协变与逆变"><a href="#协变与逆变" class="headerlink" title="协变与逆变"></a>协变与逆变</h3><ul><li><strong>协变（covariance）</strong>：用 <code>out</code> 关键字标注的泛型参数只能作为输出，表示这个类型参数只能从类中取出，不能写入。</li><li><strong>逆变（contravariance）</strong>：用 <code>in</code> 关键字标注的泛型参数只能作为输入，表示这个类型参数只能传入，不能取出。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Producer&lt;out T&gt; &#123;</span><br><span class="line">    fun produce(): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Consumer&lt;in T&gt; &#123;</span><br><span class="line">    fun consume(item: T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>委托是另一种让代码更简洁、更灵活的设计模式。它的核心思想是“把工作交给其他对象来做”。</p><h3 id="1-属性委托"><a href="#1-属性委托" class="headerlink" title="1. 属性委托"></a>1. 属性委托</h3><p>属性委托可以让你把属性的 get（取值）和 set（赋值）操作交给另一个对象来处理。</p><h4 id="1-1-lazy-委托"><a href="#1-1-lazy-委托" class="headerlink" title="1.1 lazy 委托"></a>1.1 lazy 委托</h4><p>假设你有一个属性，这个属性的计算过程比较耗时，但你希望它只有在第一次使用时才进行计算。可以使用 <code>lazy</code> 委托：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 lazy 委托属性，只有在第一次使用时才计算值</span><br><span class="line">val lazyValue: String by lazy &#123;</span><br><span class="line">    println(&quot;开始计算&quot;)</span><br><span class="line">    &quot;Hello, Kotlin&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;程序开始&quot;)</span><br><span class="line">    println(lazyValue) // 第一次调用，执行 lambda，输出：开始计算 和 Hello, Kotlin</span><br><span class="line">    println(lazyValue) // 第二次调用，不会再计算，直接输出 Hello, Kotlin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>详细解释：</strong></p><ul><li><code>val lazyValue: String by lazy &#123; ... &#125;</code><br> 表示 lazyValue 的值由 <code>lazy</code> 委托管理，当你第一次访问 lazyValue 时，执行 <code>&#123; ... &#125;</code> 内的代码，计算出结果保存起来，后续直接返回这个结果。</li></ul><h4 id="1-2-observable-委托"><a href="#1-2-observable-委托" class="headerlink" title="1.2 observable 委托"></a>1.2 observable 委托</h4><p>如果你想在属性变化时执行某些操作，比如记录日志，可以使用 <code>observable</code> 委托：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line">// 定义一个 observable 委托属性，每次属性改变时都会触发 lambda</span><br><span class="line">var name: String by Delegates.observable(&quot;初始值11&quot;) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">    println(&quot;属性 $&#123;property.name&#125; 从 $oldValue 变成了 $newValue&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    name = &quot;Kotlin22&quot;  // 修改属性时，会触发 lambda，输出：属性 name 从 初始值11 变成了 Kotlin22</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>详细解释：</strong></p><ul><li>当 <code>name</code> 的值改变时，<code>observable</code> 委托会自动调用后面的 lambda，将属性信息、旧值和新值传入，供你做相应的处理（例如打印日志）。</li></ul><h3 id="2-类委托"><a href="#2-类委托" class="headerlink" title="2. 类委托"></a>2. 类委托</h3><p>有时候你想实现一个接口，但不想自己写所有的方法实现，可以把这些工作交给另一个已经实现了这个接口的类。这就是类委托。</p><h4 id="类委托示例"><a href="#类委托示例" class="headerlink" title="类委托示例"></a>类委托示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个接口</span><br><span class="line">interface Printer &#123;</span><br><span class="line">    fun print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个接口的实现类</span><br><span class="line">class PrinterImpl(val message: String) : Printer &#123;</span><br><span class="line">    override fun print() &#123;</span><br><span class="line">        println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//DelegatingPrinter 类实现了 Printer 接口，但它没有自己实现 print() 方法。</span><br><span class="line">//关键部分在于 : Printer by printer，这表示 DelegatingPrinter 将接口的实现委托给传入的 printer 对象。</span><br><span class="line">//也就是说，当调用 DelegatingPrinter 的 print() 方法时，实际调用的是传入对象（例如 PrinterImpl）的 print() 方法。</span><br><span class="line">class DelegatingPrinter(printer: Printer) : Printer by printer</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val printerImpl = PrinterImpl(&quot;Hello from PrinterImpl&quot;)</span><br><span class="line">    val delegatingPrinter = DelegatingPrinter(printerImpl)</span><br><span class="line">    delegatingPrinter.print() // 实际调用的是 PrinterImpl 中的 print() 方法，输出：Hello from PrinterImpl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>详细解释：</strong></p><ul><li><code>class DelegatingPrinter(printer: Printer) : Printer by printer</code><br> 表示 DelegatingPrinter 实现了接口 Printer，但它并没有自己写 <code>print()</code> 方法，而是把所有对 <code>print()</code> 的调用都交给传入的 <code>printer</code> 对象来处理。</li></ul><hr><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>泛型</strong>：<ul><li>泛型让你在编写代码时不必限定具体的类型，而是在使用时再指定。</li><li>它使代码更加通用和灵活，同时在编译时能检查类型错误，增加安全性。</li></ul></li><li><strong>委托</strong>：<ul><li><strong>属性委托</strong>：你可以把属性的获取和设置工作交给其他对象处理，比如 <code>lazy</code>（延迟计算）或 <code>observable</code>（监听属性变化）。</li><li><strong>类委托</strong>：你可以将一个接口的实现任务交给另一个已经实现该接口的对象，让代码更加简洁，避免重复编写同样的方法。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2025/02/24/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/02/24/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h1><p>使用#</p><h1 id="二-字体"><a href="#二-字体" class="headerlink" title="二.字体"></a>二.字体</h1><h2 id="1-粗体"><a href="#1-粗体" class="headerlink" title="1.粗体"></a>1.粗体</h2><p>两个*</p><p><strong>M</strong></p><p><strong>M</strong></p><h2 id="2-斜体"><a href="#2-斜体" class="headerlink" title="2.斜体"></a>2.斜体</h2><p>一个*</p><p><em>M</em></p><p><em>M</em></p><h2 id="3-粗体加斜体"><a href="#3-粗体加斜体" class="headerlink" title="3.粗体加斜体"></a>3.粗体加斜体</h2><p>三个*</p><p><em><strong>M</strong></em></p><p><em><strong>M</strong></em></p><h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h2><p>使用两个波浪线</p><p><del>M</del></p><p><del>M</del></p><h1 id="三-引用"><a href="#三-引用" class="headerlink" title="三.引用"></a>三.引用</h1><p>使用大于号</p><blockquote><p>M</p></blockquote><blockquote><p>M</p></blockquote><h1 id="四-分割线"><a href="#四-分割线" class="headerlink" title="四.分割线"></a>四.分割线</h1><p>三个*或者三个-</p><h1 id="五-图片"><a href="#五-图片" class="headerlink" title="五.图片"></a>五.图片</h1><p>!+[]+()，其中[]内填写名字，()内填写图片地址</p><p><img src="/"></p><h1 id="六-超链接"><a href="#六-超链接" class="headerlink" title="六.超链接"></a>六.超链接</h1><p>[]+()，其中[]内填写名字，()内填写网址</p><p><a href="www.baidu.com">hh</a></p><h1 id="七-列表"><a href="#七-列表" class="headerlink" title="七.列表"></a>七.列表</h1><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>数字加”.”,再加空格，即生成有序列表</p><ol><li>A</li><li>B</li></ol><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>-加空格</p><ul><li>1</li><li>2</li></ul><h1 id="八-表格"><a href="#八-表格" class="headerlink" title="八.表格"></a>八.表格</h1><p>1.右键，选择插入，选择表格</p><p>2.Ctrl+T</p><p>3.原始人模式</p><p>先写好格式如下</p><p>X|Y|Z</p><p>–|–|–</p><p>1|2|3</p><p>然后点击左下角图案&lt;&#x2F;&gt;，开启源代码模式，把各行之间的空行删除，即可生成表格。</p><h1 id="九-插入代码块"><a href="#九-插入代码块" class="headerlink" title="九.插入代码块"></a>九.插入代码块</h1><p>使用三个&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据库</title>
      <link href="/2025/02/24/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2025/02/24/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>进度1:32:06</p><h1 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一.数据类型"></a>一.数据类型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INT                    --整数</span><br><span class="line">DECIMAL(3,2)   --有小数点的数</span><br><span class="line">VARCHAR(10)            --字串</span><br><span class="line">BLOB                   --(Binary Large Object) 图片 影片 档案...</span><br><span class="line">DATA                   --&#x27;YYYY-MM-DD&#x27; 日期</span><br><span class="line">TIMESTAMP              --&#x27;YYYY-MM-DD HH:MM:SS&#x27; 记录时间</span><br></pre></td></tr></table></figure><h1 id="二-简单例子"><a href="#二-简单例子" class="headerlink" title="二.简单例子"></a>二.简单例子</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> dATABASE `sql_tutorial`;</span><br><span class="line"><span class="keyword">SHOW</span> DAtABaSES;</span><br><span class="line">USE `sql_tutorial`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `student`(</span><br><span class="line">`student_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> auto_increment,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> ,  <span class="comment">-- 这是一个注释，记得是减减加空格</span></span><br><span class="line">`major` <span class="type">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">default</span> <span class="string">&#x27;历史&#x27;</span>,</span><br><span class="line">`score` <span class="type">INT</span> <span class="keyword">default</span> <span class="number">100</span> <span class="comment">-- 最后一个属性不用加逗号</span></span><br><span class="line">);      <span class="comment">/*最后有;相当于一句话的结束？*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dESCriBe</span> `student`;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">TABLE</span> `student`;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">ADD</span> gpa <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.00</span>; <span class="comment">-- 新增属性</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> gpa; <span class="comment">-- 删除属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `student`;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;历史&#x27;</span>,<span class="number">100</span>); <span class="comment">-- 插入数据，注意是用单引号’而不是`</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;小绿&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`major`,`student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小蓝&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="number">4</span>); </span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`major`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="keyword">NULL</span>); <span class="comment">-- 不写id是因为auto_increment自动生成id</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `student` <span class="keyword">WHERE</span> `student_id` <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">-- 删除id为4的那一行</span></span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES<span class="operator">=</span><span class="number">0</span> ;<span class="comment">-- 用于关闭安全更新模式，允许你执行 UPDATE 或 DELETE 语句，即使没有 WHERE 条件或没有主键索引。</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` </span><br><span class="line"><span class="keyword">SET</span> `major` <span class="operator">=</span><span class="string">&#x27;英语文学&#x27;</span> <span class="comment">-- 不是行列名等，要使用&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> `major` <span class="operator">=</span><span class="string">&#x27;英语&#x27;</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;小1&#x27;</span> <span class="keyword">WHERE</span> `name`<span class="operator">=</span><span class="string">&#x27;小绿&#x27;</span> <span class="keyword">or</span> `name`<span class="operator">=</span> <span class="string">&#x27;小白&#x27;</span>;  <span class="comment">-- 更新表格</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;小灰&#x27;</span>,`major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span> <span class="keyword">WHERE</span> `student_id`<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `name`<span class="operator">=</span><span class="string">&#x27;小灰&#x27;</span> <span class="keyword">and</span> `major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span>; <span class="comment">-- where用and连接</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `score`<span class="operator">&lt;</span><span class="number">60</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` ;<span class="comment">-- 把student内数据全部删除</span></span><br><span class="line"><span class="comment">-- 取得资料</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student`;</span><br><span class="line"><span class="keyword">Select</span> `name` <span class="keyword">from</span> `student` ;</span><br><span class="line"><span class="keyword">select</span> `name` , `major` <span class="keyword">from</span> `student`; <span class="comment">-- 中间用,而不是and</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score` ; <span class="comment">-- 从低到高，或者在order by后面加上ASC</span></span><br><span class="line"><span class="keyword">selecT</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score` <span class="keyword">DESC</span>;<span class="comment">-- 从高到低</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score`<span class="keyword">DESC</span>,`student_id`  Limit <span class="number">3</span>; <span class="comment">-- 先根据score降序排序，若是score一样，则按student_id升序排序，只返回前三个</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `major`<span class="operator">=</span><span class="string">&#x27;英语&#x27;</span> <span class="keyword">and</span> `student_id`<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- where用and连接</span></span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>1.<em><strong>注释</strong></em>有– 和&#x2F;**&#x2F;两种–后面要跟空格</p><p>2.一个引号是一句，比如虽然CREATE TABLE <code>student</code> 有那么多行，其实只有一句，所以cursor指向容易一行就可以执行整个语句</p><p>3.闪电只会闪电一句话，比如你没有执行USE sql_tutorial 这一句话，去执行dESCriBe <code>student</code>;就会报错，记住<em><strong>一定要先执行USE sql_tutorial这句话</strong></em></p><p>4.关键字的大小写是无所谓的，但建议关键字全用大写，上面例子只是为了体现大小写任意的特征，实际上一个全部大写，自己定义的字建议使用&#96;&#96;包括起来，并使用小写</p><p>5.&gt;大于   &lt;小于   &gt;&#x3D;大于等于   &#x3D;等于    &lt;&gt;不等于</p><p>6.where用and，or连接？</p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用AS的准备</title>
      <link href="/2025/02/16/%E4%BD%BF%E7%94%A8AS%E7%9A%84%E5%87%86%E5%A4%87/"/>
      <url>/2025/02/16/%E4%BD%BF%E7%94%A8AS%E7%9A%84%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="1-viewbinding"><a href="#1-viewbinding" class="headerlink" title="1.viewbinding"></a>1.viewbinding</h1><p>build.gradle.kts中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">...</span><br><span class="line">buildFeatures &#123;</span><br><span class="line">    viewBinding = true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-compileSdk"><a href="#2-compileSdk" class="headerlink" title="2.compileSdk"></a>2.compileSdk</h1><p>build.gradle.kts中compileSdk&#x3D;34改成compileSdk&#x3D;35</p><h1 id="3-dependencies"><a href="#3-dependencies" class="headerlink" title="3.dependencies"></a>3.dependencies</h1><p>在dependencies中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">implementation(&quot;androidx.fragment:fragment:1.6.2&quot;)</span><br><span class="line">   implementation(&quot;com.squareup.okhttp3:okhttp:4.10.0&quot;)</span><br><span class="line">   implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)</span><br><span class="line">   implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)</span><br><span class="line">   implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)</span><br><span class="line">   implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1&quot;)</span><br><span class="line">   implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&quot;)</span><br><span class="line">   implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.4.0&quot;)</span><br><span class="line">   implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)</span><br><span class="line">   implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0&quot;)</span><br><span class="line">   implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)</span><br><span class="line">   kapt(&quot;androidx.room:room-compiler:2.6.1&quot;)</span><br><span class="line">   implementation(&quot;androidx.work:work-runtime:2.10.0&quot;)</span><br><span class="line">   implementation(&quot;com.github.bumptech.glide:glide:4.15.1&quot;)</span><br><span class="line">   implementation (&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.3.1&quot;)</span><br><span class="line">   implementation (&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1&quot;)</span><br><span class="line">   implementation (&quot;com.github.bumptech.glide:glide:4.13.0&quot;)</span><br><span class="line">   annotationProcessor (&quot;com.github.bumptech.glide:compiler:4.13.0&quot;)</span><br><span class="line">   implementation(&quot;androidx.room:room-runtime:2.5.2&quot;)</span><br><span class="line">   kapt(&quot;androidx.room:room-compiler:2.5.2&quot;)</span><br><span class="line">   implementation(&quot;androidx.room:room-ktx:2.5.2&quot;)</span><br></pre></td></tr></table></figure><p>解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">implementation(&quot;androidx.fragment:fragment-ktx:1.6.2&quot;)</span><br><span class="line">implementation(&quot;com.squareup.okhttp3:okhttp:4.10.0&quot;)//引用OkHttp库</span><br><span class="line">implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)//使用gson</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)//使用Retrofit,会自动将Retrofit、OkHttp、和Okio这几个库一起下载，不用再手动引入OkHttp库。</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)//使用Retrofit，这是一个Retrofit的转换库，它是借助GSON来解析JSON数据的，所以会自动将GSON库下载下来，所以不用手动引入GSON库了</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1&quot;)//协程</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&quot;)//协程</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.4.0&quot;)//使用ViewModel组件</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)//使用ViewModel、livedata组件</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0&quot;)//使用ViewModel组件</span><br><span class="line">implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)//room</span><br><span class="line">kapt(&quot;androidx.room:room-compiler:2.6.1&quot;)//room</span><br><span class="line">implementation(&quot;androidx.work:work-runtime:2.10.0&quot;)//WorkManager</span><br><span class="line">implementation(&quot;com.github.bumptech.glide:glide:4.15.1&quot;)/*Glide,另外，Glide中需要用到网络功能，因此你还得在AndroidManifest.xml中声明一下网络权限才行：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-plugins"><a href="#4-plugins" class="headerlink" title="4.plugins"></a>4.plugins</h1><p>添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(&quot;kotlin-kapt&quot;)</span><br></pre></td></tr></table></figure><p>解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(&quot;kotlin-kapt&quot;)//为了dependencies中能使用kapt(&quot;...&quot;)这样的语法</span><br></pre></td></tr></table></figure><h1 id="5-binding"><a href="#5-binding" class="headerlink" title="5.binding"></a>5.binding</h1><p>改用binding.root</p><h1 id="6-声明网络权限"><a href="#6-声明网络权限" class="headerlink" title="6.声明网络权限"></a>6.声明网络权限</h1><p>在AndroidManifest.xml开头添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如下面例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><h1 id="7-使用HTTP"><a href="#7-使用HTTP" class="headerlink" title="7.使用HTTP"></a>7.使用HTTP</h1><p>在res-&gt;xml文件夹下，新建network_config.xml文件，然后修改文件中内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">    &lt;base-config cleartextTrafficPermitted=&quot;true&quot;&gt;</span><br><span class="line">        &lt;trust-anchors&gt;</span><br><span class="line">            &lt;certificates src=&quot;system&quot;/&gt;</span><br><span class="line">        &lt;/trust-anchors&gt;</span><br><span class="line">    &lt;/base-config&gt;</span><br><span class="line">&lt;/network-security-config&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段配置文件的意思是允许我们以明文的方式在网络上传输数据，而HTTP使用的就是明文传输方式。</p><p>接下来修改AndroidManifest.xml中的代码来启用我们刚才创建的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        android:allowBackup=&quot;true&quot;</span><br><span class="line">        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;</span><br><span class="line">        android:fullBackupContent=&quot;@xml/backup_rules&quot;</span><br><span class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;</span><br><span class="line">        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:supportsRtl=&quot;true&quot;</span><br><span class="line">        android:theme=&quot;@style/Theme.NetworkTest&quot;</span><br><span class="line">        tools:targetApi=&quot;31&quot;</span><br><span class="line">        android:networkSecurityConfig=&quot;@xml/network_config&quot;//就是添加这一行哦</span><br><span class="line">        &gt;</span><br></pre></td></tr></table></figure><h1 id="AndroidManifest-xml的权限声明"><a href="#AndroidManifest-xml的权限声明" class="headerlink" title="AndroidManifest.xml的权限声明"></a>AndroidManifest.xml的权限声明</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; </span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task-4</title>
      <link href="/2025/02/10/Task-4/"/>
      <url>/2025/02/10/Task-4/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第四讲"><a href="#寒假第四讲" class="headerlink" title="寒假第四讲"></a>寒假第四讲</h1><h2 id="一-有理数取余"><a href="#一-有理数取余" class="headerlink" title="一.有理数取余"></a>一.有理数取余</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该问题要求计算有理数 c&#x3D;ab<em>c</em>&#x3D;<em>b**a</em> 对19260817取模的值。根据模运算的性质，这相当于求解方程 bx≡amod  19260817<em>b**x</em>≡<em>a</em>mod19260817。解的存在性取决于 b<em>b</em> 是否存在模19260817的逆元。具体步骤如下：</p><ol><li><strong>大数取模</strong>：由于输入的 a<em>a</em> 和 b<em>b</em> 可能非常大（最多10001位），需要将这两个数转换为模19260817后的值。这可以通过逐位处理字符串并取模来实现。</li><li><strong>判断逆元存在性</strong>：若 b<em>b</em> 模19260817的结果为0，则方程无解，直接输出“Angry!”。否则，利用费马小定理计算 b<em>b</em> 的逆元，因为19260817是质数。</li><li><strong>计算最终结果</strong>：将 a<em>a</em> 的模值与逆元相乘后再次取模，得到最终结果。</li></ol><h3 id="2-对应代码"><a href="#2-对应代码" class="headerlink" title="2.对应代码"></a>2.对应代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MOD = 19260817;</span><br><span class="line"></span><br><span class="line">int mod(const string&amp; s, int m) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (char c : s) &#123;</span><br><span class="line">        res = (res * 10LL + (c - &#x27;0&#x27;)) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long pow_mod(long long a, long long b, int mod) &#123;</span><br><span class="line">    long long res = 1;</span><br><span class="line">    a %= mod;</span><br><span class="line">    while (b &gt; 0) &#123;</span><br><span class="line">        if (b % 2 == 1) res = (res * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string a_str, b_str;</span><br><span class="line">    cin &gt;&gt; a_str &gt;&gt; b_str;</span><br><span class="line"></span><br><span class="line">    int a_mod = mod(a_str, MOD);</span><br><span class="line">    int b_mod = mod(b_str, MOD);</span><br><span class="line"></span><br><span class="line">    if (b_mod == 0) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Angry!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        long long inv_b = pow_mod(b_mod, MOD - 2, MOD);</span><br><span class="line">        long long ans = (a_mod * inv_b) % MOD;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li><strong>大数取模技巧</strong>：处理超大数时，可以通过逐位取模的方式避免数值溢出。例如，将字符串的每一位依次转换为当前结果的10倍加上该位数字，然后立即取模。</li><li><strong>逆元计算</strong>：当模数为质数时，可以利用费马小定理快速计算逆元（即 ap−2mod  p<em>a**p</em>−2mod<em>p</em>），时间复杂度为 O(log⁡p)<em>O</em>(log<em>p</em>)。</li><li><strong>输入处理</strong>：注意输入的数值范围，使用字符串处理大数，并确保处理过程中不会溢出。</li><li><strong>边界条件</strong>：题目保证输入的 a<em>a</em> 和 b<em>b</em> 不同时是模数的倍数，因此当 b<em>b</em> 的模为0时，直接判定无解。</li></ol><p>该问题结合了数论中的模运算和逆元知识，同时考察了处理大数的技巧，综合应用了多种算法和编程技术。</p><h2 id="二-Minimal-Coprime"><a href="#二-Minimal-Coprime" class="headerlink" title="二.Minimal Coprime"></a>二.Minimal Coprime</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>对于每一个测试用例，我们需要找出区间 [l, r] 内所有的最小互质区间。由于我们要判断区间是否是最小互质，实际操作时可以考虑以下几点：</p><ol><li>如果 l &#x3D;&#x3D; r，那么只有一个单一的数，需要检查该数是否与自身互质，显然，对于任意数 a，<code>gcd(a, a) ≠ 1</code>，因此这类区间无法构成互质区间。</li><li>如果 l !&#x3D; r，则要判断区间 [l, r] 内每一个单元素子区间是否互质，同时对于更大的区间是否是最小互质区间。</li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">const int N = 1e6 + 10,mod = 19260817,INT = 1e17,M = 5e6;</span><br><span class="line"> </span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"> </span><br><span class="line">int qmi(int a,int k)&#123;</span><br><span class="line">int res = 1;</span><br><span class="line">while(k)&#123;</span><br><span class="line">if(k&amp;1) res = res * a % mod;</span><br><span class="line">a = a * a % mod; </span><br><span class="line">k &gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void slove()&#123;</span><br><span class="line">string a,b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">int na = 0,nb = 0;</span><br><span class="line">for(auto c:a)&#123;</span><br><span class="line">na = (na * 10 + c - &#x27;0&#x27;) % mod;</span><br><span class="line">&#125;</span><br><span class="line">for(auto c:b) nb = (nb * 10 + c - &#x27;0&#x27;) % mod;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; na * qmi(nb,mod - 2) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);cin.tie(nullptr);</span><br><span class="line">int T = 1;</span><br><span class="line">while(T--) slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>最大公约数 (gcd)</strong>：在这道题中，我们频繁使用 <code>gcd</code> 来判断两个数是否互质。通过辗转相除法，可以有效地求出两个数的最大公约数，进而判断它们是否互质。</p><p><strong>区间内互质判断</strong>：对于每一个子区间，需要检查它们是否互质，并且判断是否包含更小的互质子区间。这要求我们在求解时要小心处理每个区间，避免遗漏。</p><p><strong>最小互质区间的判定</strong>：最小互质区间需要满足不包含任何其他互质区间，这一点是解题的关键。通过遍历区间的所有子区间，并确保它们不含更小的互质区间，可以确保找到所有最小互质区间。</p><p><strong>优化</strong>：虽然本解法直接暴力枚举所有区间，但考虑到题目中区间范围较大，应该在实际使用中进行一些优化，如剪枝等策略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task 3</title>
      <link href="/2025/02/06/Task-3/"/>
      <url>/2025/02/06/Task-3/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第三讲"><a href="#寒假第三讲" class="headerlink" title="寒假第三讲"></a>寒假第三讲</h1><h2 id="一-priority-queue"><a href="#一-priority-queue" class="headerlink" title="一.priority queue"></a>一.priority queue</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求实现一个优先队列，支持插入操作 <code>insert(k)</code> 和提取最大元素操作 <code>extractMax</code>。在 C++ 中，我们可以使用 <code>priority_queue</code> 来实现这一结构。<code>priority_queue</code> 默认是最大堆，插入操作将元素添加到堆中，而提取操作返回并删除堆顶的元素。</p><p>首先，输入包含多个操作，每个操作可能是 <code>insert k</code>（插入整数 k）、<code>extract</code>（提取最大元素）或 <code>end</code>（结束输入）。对于每个 <code>insert k</code> 操作，我们将元素插入到优先队列中。对于每个 <code>extract</code> 操作，我们从堆中提取并输出当前最大值。</p><p>C++ 的 <code>priority_queue</code> 数据结构默认按降序排列（即最大堆），因此无需额外处理即可满足题目要求。程序通过循环读取操作，针对 <code>insert</code> 进行堆插入，针对 <code>extract</code> 进行堆顶元素提取并输出，直到遇到 <code>end</code> 操作停止。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Compare &#123;</span><br><span class="line">    bool operator()(int a, int b) &#123;</span><br><span class="line">        return a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, Compare&gt; pq; </span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    while (getline(cin, line)) &#123;</span><br><span class="line">        if (line.empty()) continue;</span><br><span class="line"></span><br><span class="line">        stringstream ss(line);</span><br><span class="line">        string command;</span><br><span class="line">        ss &gt;&gt; command;</span><br><span class="line"></span><br><span class="line">        if (command == &quot;insert&quot;) &#123;</span><br><span class="line">            int k;</span><br><span class="line">            ss &gt;&gt; k;</span><br><span class="line">            pq.push(k);</span><br><span class="line">        &#125; else if (command == &quot;extract&quot;) &#123;</span><br><span class="line">            if (!pq.empty()) &#123;</span><br><span class="line">                cout &lt;&lt; pq.top() &lt;&lt; endl; </span><br><span class="line">                pq.pop(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (command == &quot;end&quot;) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>通过实现这个优先队列，了解了 C++ 中 <code>priority_queue</code> 的基本使用方法。<code>priority_queue</code> 使用最大堆结构，自动保证每次提取的都是当前最大元素，因此插入和提取操作的时间复杂度为 <code>O(log n)</code>，非常高效。此外，使用 <code>priority_queue</code> 还可以避免手动维护堆结构，从而减少了程序复杂度。通过输入和输出流的处理，我也更深入地理解了如何高效处理大规模数据输入。特别是对于题目中限制的 200 万次操作，我们需要确保程序的输入输出效率，因此应该尽量减少不必要的操作，使用合适的输入输出方法提高程序性能。</p><h2 id="ST表-RMQ问题"><a href="#ST表-RMQ问题" class="headerlink" title="ST表&amp;&amp;RMQ问题"></a>ST表&amp;&amp;RMQ问题</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该程序利用 ST 表进行静态区间最大值查询。首先，使用 <code>preprocess</code> 函数构建 ST 表，预处理时间复杂度为 O(N log N)。<br>对于每个查询，我们利用对数表 <code>log_table</code> 预计算查询范围的最优分块，使得查询复杂度降为 O(1)。<br>通过 <code>read()</code> 进行高效输入，减少 IO 时间，适用于大数据量场景。</p><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 100000;</span><br><span class="line">const int LOG = 17;</span><br><span class="line">int st[MAX_N][LOG];</span><br><span class="line">int log_table[MAX_N + 1];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;) f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preprocess(const vector&lt;int&gt;&amp; arr, int n) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        st[i][0] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">        for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i++) &#123;</span><br><span class="line">            st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log_table[1] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        log_table[i] = log_table[i / 2] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int l, int r) &#123;</span><br><span class="line">    int j = log_table[r - l + 1];</span><br><span class="line">    return max(st[l][j], st[r - (1 &lt;&lt; j) + 1][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = read(), m = read();</span><br><span class="line">    vector&lt;int&gt; arr(n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line">    preprocess(arr, n);</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int l = read() - 1, r = read() - 1;</span><br><span class="line">        printf(&quot;%d\n&quot;, query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>ST 表适用于静态查询，预处理代价较高，但查询极快。</li><li>利用 <code>log_table</code> 预计算对数值可以减少 <code>log</code> 函数调用，提高查询效率。</li><li>快速输入 <code>read()</code> 可有效减少时间开销，适用于高强度数据。</li><li>ST 表的核心思想是利用区间的重叠性，通过 <code>dp</code> 方式高效存储区间信息</li></ol><h2 id="合并果子"><a href="#合并果子" class="headerlink" title="合并果子"></a>合并果子</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题可以通过哈夫曼树（Huffman Tree）的思想来解决，使用最小堆（优先队列）进行贪心合并。<br>每次取出当前最小的两堆果子进行合并，合并的代价是两者之和，并将新堆重新加入优先队列。<br>这个过程持续 n-1 次，最终优先队列中只剩下一堆，累加所有合并的代价，即为最小的体力耗费。<br>由于使用了最小堆，每次插入与删除的复杂度是 O(log n)，整体复杂度为 O(n log n)。</p><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;) f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = read();</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        pq.push(read());</span><br><span class="line">    &#125;</span><br><span class="line">    int total_cost = 0;</span><br><span class="line">    while (pq.size() &gt; 1) &#123;</span><br><span class="line">        int a = pq.top(); pq.pop();</span><br><span class="line">        int b = pq.top(); pq.pop();</span><br><span class="line">        int cost = a + b;</span><br><span class="line">        total_cost += cost;</span><br><span class="line">        pq.push(cost);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, total_cost);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>本题是典型的贪心算法应用，通过局部最优（每次合并最小的两堆）达到全局最优。</li><li>最小堆（优先队列）是一种有效的数据结构，适用于处理动态集合中的最小值问题。</li><li>哈夫曼树的构造与本题类似，它用于最优前缀编码问题，具有广泛应用。</li><li>由于 n 最大为 10000，使用 O(n log n) 复杂度的方法是合理可行的，若用 O(n^2) 的方法会超时。</li><li>通过 <code>priority_queue</code> 的 <code>greater&lt;int&gt;</code> 实现最小堆，提高代码可读性和效率。</li></ol><h2 id="四-约瑟夫问题"><a href="#四-约瑟夫问题" class="headerlink" title="四.约瑟夫问题"></a>四.约瑟夫问题</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该题是经典的约瑟夫环问题。我们通过模拟报数过程来解决，使用双端队列（<code>deque</code>）来模拟每次出圈的操作。首先将所有人的编号依次加入队列，每次将前 mmm 个人报数，第 mmm 个人出列，再从下一个人开始继续报数。该过程重复直到所有人都出列。通过队列的 <code>push_back</code> 和 <code>pop_front</code> 操作来模拟循环报数，保证每个出圈人的编号按顺序输出。</p><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    deque&lt;int&gt; people;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        people.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    while (!people.empty()) &#123;</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            people.push_back(people.front());</span><br><span class="line">            people.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        cout &lt;&lt; people.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">        people.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h3><p><strong>约瑟夫环问题</strong>：是经典的动态结构问题，使用队列模拟能够有效解决。</p><p><strong>队列操作</strong>：队列的 <code>push_back</code> 和 <code>pop_front</code> 操作时间复杂度为 O(1)，适合进行循环模拟。</p><p><strong>循环过程理解</strong>：通过理解每次从队列中移除第 mmm 个人，并将下一个人重新从头开始报数，可以轻松解决问题。</p><p><strong>时间复杂度</strong>：对于 n 和 m 较小的情况，O(n * m) 的时间复杂度是可行的。</p><p><strong>应用范围</strong>：这种方法适用于类似的循环排列问题，理解其实现方式对于解决其他类似问题非常有帮助。</p><h2 id="五-Look-Up-S"><a href="#五-Look-Up-S" class="headerlink" title="五.Look Up S"></a>五.Look Up S</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题的核心在于查找每个奶牛的右侧第一个比她高的奶牛。通过使用栈（stack）数据结构，可以高效地维护一个递减的序列。每次遇到一个奶牛时，将其与栈顶的奶牛进行比较，如果栈顶奶牛的身高不大于当前奶牛，就将其弹出，直到栈顶奶牛的身高大于当前奶牛或栈为空。此时栈顶元素即为当前奶牛的仰望对象。</p><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1e5 + 5;</span><br><span class="line">int h[MAXN];</span><br><span class="line">int ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; stk;</span><br><span class="line">    for (int i = n; i &gt;= 1; --i) &#123;</span><br><span class="line">        while (!stk.empty() &amp;&amp; h[stk.back()] &lt;= h[i]) &#123;</span><br><span class="line">            stk.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = stk.empty() ? 0 : stk.back();</span><br><span class="line">        stk.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>栈的应用</strong>：本题运用了栈来解决查找“右侧第一个更大元素”的问题。栈非常适合解决递增&#x2F;递减问题，能够避免不必要的重复计算。</p><p><strong>时间复杂度优化</strong>：通过栈的方式，每个奶牛的身高最多入栈和出栈一次，整体时间复杂度为 O(N)，满足大规模数据的需求。</p><p><strong>贪心策略</strong>：栈的使用体现了贪心策略，通过逐步找出最优解。每次都保证栈中的奶牛按递减顺序排列，能快速找到每个奶牛的第一个仰望对象。</p><p><strong>解决类似问题</strong>：掌握栈的应用可以解决许多类似的“寻找下一个更大&#x2F;小元素”类型的问题。</p><h2 id="五-国旗计划"><a href="#五-国旗计划" class="headerlink" title="五.国旗计划"></a>五.国旗计划</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p><strong>区间转化</strong>：</p><ul><li>每个边防战士常驻两个边防站 <code>C_i</code> 和 <code>D_i</code>，其奔袭区间为从 <code>C_i</code> 到 <code>D_i</code>。如果 <code>C_i &gt; D_i</code>，说明该区间跨越了边境，需要加上边境的总长度 <code>M</code>，这样就能确保所有区间都是线性区间，方便后续处理。</li></ul><p><strong>排序</strong>：</p><ul><li>由于区间覆盖问题通常需要按顺序处理，所有边防战士的奔袭区间按照左端点 <code>l</code> 排序。排序后的数组使得我们可以方便地逐一处理每个边防战士，并计算出最少需要多少战士来覆盖边境。</li></ul><p><strong>动态规划和跳跃法</strong>：</p><ul><li>采用动态规划来解决每个边防战士覆盖的最远区间问题。通过二分查找，找到每个战士能覆盖的最远位置，记录在二维数组 <code>go</code> 中。<code>go[i][0]</code> 存储战士 <code>i</code> 覆盖区间的最远战士 <code>k</code> 的下标。为了更高效地查询最大覆盖，代码通过多级跳跃的方式，构建了 <code>go</code> 数组，并通过动态规划实现快速查询。</li></ul><p><strong>查询最小战士数量</strong>：</p><ul><li>在查询每个战士必须参与的前提下，我们从该战士的起始位置开始，依次找到能够覆盖区间的最远战士，通过二分查找的方式迭代跳跃，最后计算出最少需要的战士数量。</li></ul><p><strong>输出结果</strong>：</p><ul><li>对于每个战士，输出必须参与的前提下，最少需要多少个战士来覆盖整个边境线。</li></ul></li></ol><h3 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, res[200005];</span><br><span class="line">struct soldier &#123;</span><br><span class="line">int id, l, r;</span><br><span class="line">&#125; s[400005];</span><br><span class="line">int cmp(soldier a, soldier b)</span><br><span class="line">&#123;</span><br><span class="line">return a.l &lt; b.l; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int go[400005][20];</span><br><span class="line"></span><br><span class="line">void pre()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1, p = i; i &lt;= 2 * n; i++) &#123;</span><br><span class="line">while(p &lt;= 2 * n &amp;&amp; s[p].l &lt;= s[i].r)</span><br><span class="line">p++;</span><br><span class="line">int pos = p - 1;</span><br><span class="line">go[i][0] = pos;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">for(int j = 1; j &lt;= 2 * n; j++) &#123;</span><br><span class="line">go[j][i] = go[go[j][i - 1]][i - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void search(int k)</span><br><span class="line">&#123;</span><br><span class="line">int lmt = s[k].l + m, ans = 1, p = k;</span><br><span class="line">for(int i = 19; i &gt;= 0; i--) &#123;</span><br><span class="line">if(go[k][i] != 0 &amp;&amp; s[go[k][i]].r &lt; lmt) &#123;</span><br><span class="line">ans += (1 &lt;&lt; i);</span><br><span class="line">k = go[k][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res[s[p].id] = ans + 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s[i].l &gt;&gt; s[i].r;</span><br><span class="line">if(s[i].r &lt; s[i].l)</span><br><span class="line">s[i].r += m;</span><br><span class="line">s[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(s + 1, s + 1 + n, cmp);</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">s[i + n] = s[i];</span><br><span class="line">s[i + n].l = s[i].l + m;</span><br><span class="line">s[i + n].r = s[i].r + m;</span><br><span class="line">&#125;</span><br><span class="line">pre();</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">search(i);</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="学习总结-1"><a href="#学习总结-1" class="headerlink" title="学习总结"></a>学习总结</h3><p>这段代码实现了一个经典的区间覆盖问题，核心思想是通过排序和动态规划来高效地解决覆盖区间的最小边防战士数量。具体做法是将所有的区间转化成线性区间，使用排序保证覆盖的顺序性，再通过二分查找和动态规划的结合，优化查询效率。这个思路对于解决类似的区间覆盖问题非常有效，尤其是在大规模数据输入时，能够显著减少计算复杂度。通过合理使用跳跃表和二分查找，代码实现了较高的效率，是学习算法设计和优化的重要案例。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task 2</title>
      <link href="/2025/02/06/Task-2/"/>
      <url>/2025/02/06/Task-2/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第二讲-“二分”"><a href="#寒假第二讲-“二分”" class="headerlink" title="寒假第二讲:“二分”"></a>寒假第二讲:“二分”</h1><h2 id="一-二分查找"><a href="#一-二分查找" class="headerlink" title="一.二分查找"></a>一.二分查找</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这个问题的要求是通过二分查找，在一个已经按升序排列的整数序列中查找是否包含查询的整数。对于每次查询，若该整数在序列中出现，则输出 “Yes”，否则输出 “No”。</p><ol><li><strong>输入处理</strong>：<ul><li>输入一个整数 nnn，表示数组的大小。</li><li>接下来输入 nnn 个整数，这些整数已排序。</li><li>接着输入一个整数 qqq，表示查询次数。</li><li>对于每次查询，输入一个整数 mmm，需要判断 mmm 是否出现在排序数组中。</li></ul></li><li><strong>二分查找</strong>：<ul><li>二分查找是一种高效的查找方法，在一个已排序的数组中查找某个元素的时间复杂度为 O(log⁡n)O(\log n)O(logn)。</li><li>使用标准库的 <code>lower_bound</code> 函数来实现二分查找。它会返回一个指向数组中第一个大于或等于查询值的迭代器。如果迭代器指向的元素与查询值相同，则表示该元素存在。</li></ul></li><li><strong>输出</strong>：<ul><li>如果查询值在数组中存在，则输出 “Yes”；否则输出 “No”。</li></ul></li></ol><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;  // For lower_bound</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; arr(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class="line">        int m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">      </span><br><span class="line">        auto it = lower_bound(arr.begin(), arr.end(), m);</span><br><span class="line">  </span><br><span class="line">        if (it != arr.end() &amp;&amp; *it == m) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>该问题要求在已排序的数组中进行多个查找操作，最直观的做法是使用二分查找。二分查找能够将查找时间从 O(n)O(n)O(n) 降低到 O(log⁡n)O(\log n)O(logn)，因此对于大规模数据，能够显著提高效率。利用 C++ STL 提供的 <code>lower_bound</code> 函数，可以高效地实现二分查找，避免手动实现查找算法。通过这种方法，每次查询的时间复杂度为 O(log⁡n)O(\log n)O(logn)，因此总的时间复杂度为 O(qlog⁡n)O(q \log n)O(qlogn)，适合处理较大规模的输入数据。</p><p>这个解法对于最大值 n&#x3D;100000n &#x3D; 100000n&#x3D;100000 和 q&#x3D;100000q &#x3D; 100000q&#x3D;100000 的情况也是可行的，满足时间限制。</p><h2 id="二-A-B数对"><a href="#二-A-B数对" class="headerlink" title="二.A-B数对"></a>二.A-B数对</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>给定数列以及常数 CCC，要求计算满足条件 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C 的数对个数。这个问题要求判断在数列中，存在多少对 (A,B)(A, B)(A,B)，使得 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C，即 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C。</p><h4 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h4><ol><li><strong>数学转换</strong>：<ul><li>给定条件 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C，可转化为 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C。因此，对于每个 BBB，我们只需要判断 B+CB + CB+C 是否出现在数列中。</li></ul></li><li><strong>使用哈希表</strong>：<ul><li>使用哈希表（<code>unordered_map</code>）来记录数列中每个数字的出现次数。遍历数列，对于每个数 BBB，计算 B+CB + CB+C，然后检查哈希表中是否有这个数。如果有，则计数增加。</li></ul></li><li><strong>效率问题</strong>：<ul><li>用哈希表统计数列中各个数字的出现次数，查找某个数是否存在的操作是 O(1)O(1)O(1)，所以该算法的时间复杂度是 O(N)O(N)O(N)，适用于大规模数据。</li></ul></li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, C;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; C;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; arr(N);</span><br><span class="line">    unordered_map&lt;int, int&gt; freq;  </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        ++freq[arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    long long count = 0; </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        int B = arr[i];</span><br><span class="line">        int A = B + C;  // 计算A = B + C</span><br><span class="line">       </span><br><span class="line">        if (freq.find(A) != freq.end()) &#123;</span><br><span class="line">            count += freq[A];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>哈希表</strong>： 哈希表在处理需要快速查找的场景中非常有用。在本题中，哈希表帮助我们在 O(1)O(1)O(1) 的时间复杂度内查找某个元素是否存在，使得整体复杂度从 O(N2)O(N^2)O(N2) 降低到 O(N)O(N)O(N)。</p><p><strong>优化思维</strong>： 通过将问题转化为查找数列中是否存在某个数 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C，我们避免了枚举所有数对的低效方法。这是典型的通过数学转化优化问题的思路。</p><p><strong>时间与空间复杂度</strong>： 学习如何平衡时间和空间复杂度。通过使用哈希表，虽然增加了额外的空间开销，但极大地提高了算法效率，适应了问题的大数据规模。</p><p><strong>实际应用</strong>： 哈希表和集合操作在实际开发中有着广泛应用，例如数据库的索引、缓存系统等，了解并掌握这些基本数据结构对解决实际问题至关重要。</p><h2 id="三-分巧克力"><a href="#三-分巧克力" class="headerlink" title="三.分巧克力"></a>三.分巧克力</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求我们从 <code>N</code> 块巧克力中切出 <code>K</code> 块正方形巧克力，且每块正方形的边长尽可能大。我们需要通过切割巧克力的长方形，得到大小相同的正方形。</p><h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><ol><li><strong>正方形的大小</strong>：<ul><li>对于每一块巧克力 Hi×WiH_i \times W_iHi×Wi，我们能够从中切出多少个 S×SS \times SS×S 的正方形（其中 SSS 为正方形的边长）？</li><li>我们可以通过将 HiH_iHi 和 WiW_iWi 分别除以 SSS，计算每个长方形可以切出的正方形数量： 个数&#x3D;⌊HiS⌋×⌊WiS⌋\text{个数} &#x3D; \left\lfloor \frac{H_i}{S} \right\rfloor \times \left\lfloor \frac{W_i}{S} \right\rfloor个数&#x3D;⌊SHi⌋×⌊SWi⌋</li><li>我们需要找到一个 SSS，使得从所有 NNN 块巧克力中切出的正方形总数至少为 KKK。</li></ul></li><li><strong>二分查找</strong>：<ul><li>由于我们希望切出的正方形边长尽可能大，最直观的办法是使用二分查找来确定边长 SSS 的最大值。范围从 1 到每块巧克力的最大边长（即 min⁡(Hi,Wi)\min(H_i, W_i)min(Hi,Wi)）。</li></ul></li><li><strong>检查条件</strong>：<ul><li>对于每个 SSS，我们计算出所有巧克力切出的正方形数量，并判断是否能够满足至少有 KKK 块巧克力。如果能满足，说明 SSS 是一个可能的解，我们可以继续尝试更大的 SSS；否则，尝试更小的 SSS。</li></ul></li></ol><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 判断给定边长 S 能否从所有巧克力中切出至少 K 块正方形</span><br><span class="line">bool canCutSquares(const vector&lt;pair&lt;int, int&gt;&gt;&amp; chocolates, int S, int K) &#123;</span><br><span class="line">    long long totalCount = 0;  // 记录切出的正方形总数</span><br><span class="line">    for (const auto&amp; chocolate : chocolates) &#123;</span><br><span class="line">        int H = chocolate.first;</span><br><span class="line">        int W = chocolate.second;</span><br><span class="line">        totalCount += (H / S) * (W / S);  // 计算该巧克力能切出多少个 S * S 的正方形</span><br><span class="line">        if (totalCount &gt;= K) return true;  // 如果已达到要求的数量，提前返回</span><br><span class="line">    &#125;</span><br><span class="line">    return totalCount &gt;= K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, K;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; chocolates(N);</span><br><span class="line">    int maxSide = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; chocolates[i].first &gt;&gt; chocolates[i].second;</span><br><span class="line">        maxSide = max(maxSide, min(chocolates[i].first, chocolates[i].second));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int low = 1, high = maxSide, bestSide = 0;</span><br><span class="line"></span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (canCutSquares(chocolates, mid, K)) &#123;</span><br><span class="line">            bestSide = mid;  </span><br><span class="line">            low = mid + 1;  </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            high = mid - 1;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bestSide &lt;&lt; endl; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>二分查找的应用</strong>：通过二分查找可以高效地求解正方形的最大边长，尤其是在边长空间较大时，能够显著降低时间复杂度。</p><p><strong>空间利用</strong>：通过使用哈希表和二分查找，我们在时间和空间上达到了较优的平衡，能够处理最大规模的数据。</p><p><strong>问题的数学转化</strong>：通过将切割问题转化为数目判断问题，利用二分查找可以有效避免暴力破解的高时间复杂度。</p><h2 id="四-卡牌"><a href="#四-卡牌" class="headerlink" title="四.卡牌"></a>四.卡牌</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p><strong>减少重复计算</strong>：</p><ul><li>在 <code>canMakeKSets</code> 函数中，我们每次都需要计算空白卡牌的数量。考虑到 <code>a[i]</code> 和 <code>b[i]</code> 对于每个卡牌是固定的，我们可以提前计算每种卡牌的补充量，然后直接通过前缀和计算每个 <code>k</code> 的所需补充卡牌数。</li></ul><p><strong>通过前缀和优化卡牌需求计算</strong>：</p><ul><li>计算需要补充的空白卡牌数时，如果我们能提前计算出每种卡牌在每个 <code>k</code> 值下需要多少空白卡牌，可以加速查找。</li><li>我们可以使用 <strong>贪心策略</strong> 或者 <strong>扫描算法</strong>，避免每次都全量扫描 <code>n</code> 个卡牌。</li></ul><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n, m, a[N + 5], b[N + 5];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    bool f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    for (; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) f ^= (ch == &#x27;-&#x27;);</span><br><span class="line">    for (; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool check(int mid) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cnt += max(0LL, mid - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt &lt;= m;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Kafka() &#123;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line">    </span><br><span class="line">    int L = 1, R = n * 2;</span><br><span class="line"> </span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i] = read();</span><br><span class="line">        R = min(a[i] + b[i], R);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二分查找最大套牌数</span><br><span class="line">    while (L &lt; R) &#123;</span><br><span class="line">        int mid = (L + R + 1) &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) &#123;</span><br><span class="line">            L = mid;  </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            R = mid - 1; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; L &lt;&lt; &#x27;\n&#x27;;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>提前计算补充数量</strong>：通过一次遍历计算每个 <code>k</code> 需要的补充卡牌数量，可以减少时间复杂度，避免重复计算。</p><p><strong>二分查找的技巧</strong>：通过二分查找可以有效缩小搜索范围，每次判断可以集中判断某个 <code>k</code> 是否可行。</p><p><strong>空间优化</strong>：只使用简单的数组来存储卡牌数量和补充限制，空间复杂度为 <code>O(n)</code>，符合题目要求。</p><h2 id="五-书的复制"><a href="#五-书的复制" class="headerlink" title="五.书的复制"></a>五.书的复制</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题目要求将 <code>m</code> 本有顺序的书分给 <code>k</code> 个人复制，每个人抄写的书是连续的，并且需要尽可能最短的复制时间。复制时间指的是抄写页数最多的人所用的时间，目标是尽可能减少这个时间。</p><p>为了解决这个问题，采用了 <strong>二分查找</strong> 和 <strong>贪心算法</strong> 结合的策略：</p><ol><li><strong>二分查找</strong>：<ul><li>对于复制时间的最大值 <code>max_time</code>（即抄写页数最多的人的时间），我们可以进行二分查找。</li><li>初始时，设置 <code>L = 1</code>（最小值）和 <code>R = sum(a)</code>（最大值，所有书页加起来）。</li><li>对于每个中间值 <code>mid</code>，我们要判断是否能在 <code>mid</code> 的最大时间限制下，合理分配书籍给 <code>k</code> 个人。</li></ul></li><li><strong>贪心算法</strong>：<ul><li>每次尝试用当前的 <code>mid</code> 来分配书籍：从书籍列表中依次分配，如果当前人的已分配页数超过 <code>mid</code>，就开始分配给下一个人。</li><li>通过这种方式，我们可以确定在当前的 <code>mid</code> 时间下，能分配给 <code>k</code> 个人。</li></ul></li><li><strong>过程描述</strong>：<ul><li>对于每次二分查找的 <code>mid</code>，我们从第 1 个人开始，贪心地分配书籍。如果当前书籍无法分配给当前人（超出了 <code>mid</code> 时间），就换给下一个人，直到所有书籍分配完。</li><li>如果我们能够在 <code>k</code> 个人内完成分配，那么说明当前的 <code>mid</code> 值是可行的，我们尝试缩小 <code>mid</code>；否则，增大 <code>mid</code>。</li></ul></li><li><strong>结果输出</strong>：<ul><li>二分查找结束后，最终的最优时间就是 <code>L</code>，然后根据该时间输出每个人抄写的书籍区间。</li></ul></li></ol><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int K=500;</span><br><span class="line">int m,k,a[K+5];</span><br><span class="line">int st[K+5],ed[K+5];</span><br><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int x=0;bool f=1;char ch=getchar();</span><br><span class="line">    for(;ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;;ch=getchar())f^=(ch==&#x27;-&#x27;);</span><br><span class="line">    for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar())x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);</span><br><span class="line">    return f?x:-x;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int mid)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt=1,now=mid;</span><br><span class="line">    for(int i=1;i&lt;=m&amp;&amp;cnt&lt;=k;++i) </span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&gt;now) ++cnt,--i,now=mid;</span><br><span class="line">        else now-=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line">void Kafka()</span><br><span class="line">&#123;</span><br><span class="line">    m=read(),k=read();</span><br><span class="line">    int L=1,R=0;</span><br><span class="line">    for(int i=1;i&lt;=m;++i) a[i]=read(),R+=a[i];</span><br><span class="line">    for(int mid=L+R&gt;&gt;1;L&lt;R;check(mid)?R=mid:L=mid+1)mid=L+R&gt;&gt;1;</span><br><span class="line">    ed[k]=m,st[1]=1;</span><br><span class="line">    for(int i=k,j=m,now=L;i;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        for(;now&gt;=a[j]&amp;&amp;j;--j) now-=a[j];</span><br><span class="line">        st[i]=j+1,ed[i-1]=j,now=L;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=k;++i) cout&lt;&lt;st[i]&lt;&lt;&#x27; &#x27;&lt;&lt;ed[i]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-4"><a href="#3-学习总结-4" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>本题考察了 <strong>二分查找</strong> 和 <strong>贪心算法</strong> 的结合使用。通过二分查找高效地探索最优解空间，再结合贪心算法快速判断是否能在指定时间内完成分配，使得问题得以高效解决。这种类型的问题不仅能够加深对算法思维的理解，还能帮助解决实际中遇到的类似最优化问题。</p><h2 id="六-青蛙过河"><a href="#六-青蛙过河" class="headerlink" title="六.青蛙过河"></a>六.青蛙过河</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求小青蛙在河对岸和学校之间来回跳跃，以最小化跳跃的能力（即最小的跳跃距离）。每次小青蛙必须从一块石头起跳，并且跳跃的距离不能超过某个值。为了确保小青蛙能够完成指定的跳跃次数（2x次），我们需要找到一个合适的跳跃距离，使得它能够在有限的跳跃次数内成功完成任务。</p><ul><li><p>首先我们需要确定最小跳跃能力的范围。最小值为 <code>1</code>，最大值为 <code>n-1</code>（即河宽度），即从河的起点到终点的最大跳跃距离。</p></li><li><p>我们可以使用二分查找来缩小跳跃能力的范围。通过不断尝试不同的跳跃能力 <code>mid</code>，并判断是否能够完成 <code>2x</code> 次跳跃。</p></li><li><p>为了判断某个跳跃能力是否合适，模拟小青蛙的跳跃过程：从起点开始，每次尝试跳跃尽可能远的石头（跳跃的距离不超过当前的 <code>mid</code>），并尽量减少跳跃的次数。</p></li><li><p>如果跳跃次数小于或等于 <code>2x</code>，则当前跳跃能力 <code>mid</code> 是可行的。</p></li><li><p>否则，当前跳跃能力 <code>mid</code> 太小，不能完成任务。</p></li><li><p>通过二分查找不断调整跳跃能力的范围，直到找到最小的可行跳跃能力。</p></li></ul><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n, x, H[N + 5], sum[N + 5];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0; bool f = 1; char ch = getchar();</span><br><span class="line">    for (; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) f ^= (ch == &#x27;-&#x27;);</span><br><span class="line">    for (; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check(int mid) &#123;</span><br><span class="line">    int cnt = 0, last = 0;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        if (i - last &gt; mid) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            last = i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n - last &gt; mid) cnt++;</span><br><span class="line">    return cnt &lt;= 2 * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Kafka() &#123;</span><br><span class="line">    n = read(), x = read();</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        H[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int L = 1, R = n, ans = n;</span><br><span class="line">    while (L &lt;= R) &#123;</span><br><span class="line">        int mid = (L + R) &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            R = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            L = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-5"><a href="#3-学习总结-5" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>二分查找的应用</strong><br>二分查找通常用来在有序区间中查找某个满足条件的值。在本题中，我们通过二分查找来找到最小的跳跃能力，这种问题通常被称为“最小最大化问题”。</p><p><strong>模拟问题的实现</strong><br>本题中模拟了小青蛙的跳跃过程，模拟的关键是如何判断是否能在有限的跳跃次数内完成任务。通过检查每个 <code>mid</code> 跳跃能力是否能够完成 <code>2x</code> 次跳跃，判断当前跳跃能力的可行性。</p><p><strong>问题求解中的二分查找优化</strong><br>由于本题的跳跃能力是一个整数范围，且通过验证跳跃能力的可行性可以在常数时间内完成，所以二分查找在这个问题中是一种高效的求解方法。</p><p><strong>复杂度分析</strong></p><ul><li>二分查找的时间复杂度是 <code>O(log n)</code>。</li><li>对每个 <code>mid</code> 值，我们需要遍历石头进行一次跳跃模拟，最坏情况下是 <code>O(n)</code>。</li><li>因此，总的时间复杂度是 <code>O(n log n)</code>，对于 <code>n</code> 最大为 <code>10^5</code> 的数据，能够有效地在时间限制内完成计算。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task 1</title>
      <link href="/2025/02/06/Task-1/"/>
      <url>/2025/02/06/Task-1/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第一讲：C-基础"><a href="#寒假第一讲：C-基础" class="headerlink" title="寒假第一讲：C++ 基础"></a>寒假第一讲：C++ 基础</h1><h2 id="一-Long-Loong"><a href="#一-Long-Loong" class="headerlink" title="一.Long Loong"></a>一.Long Loong</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>思路较为简单，就是先固定输出L，再根据输入的N得到应该输出多少o，最后再固定输出ng。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; &#x27;L&#x27;;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">cout &lt;&lt; &#x27;o&#x27;;</span><br><span class="line">cout &lt;&lt; &quot;ng&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>学到了for循环的基本用法，对我帮助极大，受益良多。</p><h2 id="二-YES-or-YES"><a href="#二-YES-or-YES" class="headerlink" title="二.YES or YES?"></a>二.YES or YES?</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>思路就是将输入的字符串全部大写，然后判断是否等于YES，如果等于就输出YES，不等于就输出NO。</p><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t; </span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        transform(s.begin(), s.end(), s.begin(), ::toupper);</span><br><span class="line">        if (s == &quot;YES&quot;) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>字符串处理：通过 <code>transform</code> 配合 <code>tolower</code> 或 <code>toupper</code>，可以快速将字符串统一为小写或大写，便于比较。</li><li>循环与分支：利用 <code>while (t--)</code> 循环高效处理多组输入，结合 <code>if-else</code> 判断分类处理逻辑。</li><li>时间复杂度：转换大小写或比较字符串的复杂度为 O(字符串长度)O(\text{字符串长度})O(字符串长度)。整体复杂度为 O(t)O(t)O(t)，适用于测试用例较多的情况。</li><li>STL 使用：标准库函数如 <code>transform</code> 和字符串直接比较提升了代码简洁性和可靠性。</li></ol><h2 id="三-Even-Odd-G"><a href="#三-Even-Odd-G" class="headerlink" title="三.Even? Odd? G"></a>三.Even? Odd? G</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这个程序的主要任务是根据输入的一组超大整数，判断每个整数的奇偶性（即最后一位数字是偶数还是奇数）。由于数的范围可能非常大（高达 106010^{60}1060），无法直接使用普通整数类型（如 <code>int</code> 或 <code>long long</code>），所以采用字符串处理的方式。</p><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    int N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; results;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        string number;</span><br><span class="line">        cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">        char lastDigit = number[number.length() - 1];</span><br><span class="line">        if ((lastDigit - &#x27;0&#x27;) % 2 == 0) &#123;</span><br><span class="line">            results.push_back(&quot;even&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            results.push_back(&quot;odd&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (const string&amp; result : results) &#123;</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>字符串处理大数</strong>：</p><ul><li>当数字的范围超过内置类型的支持时，可以用字符串表示并处理。</li><li>判断奇偶性只需关注数字的最后一位，简化了大数的操作。</li></ul><p><strong>模运算的应用</strong>：</p><ul><li>奇偶性的本质是看数字能否被 222 整除，通过 mod  2\mod 2mod2 运算即可实现。</li></ul><h2 id="四-Problem-Generator"><a href="#四-Problem-Generator" class="headerlink" title="四.Problem Generator"></a>四.Problem Generator</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li>输入处理</li></ol><ul><li>读取测试用例数量 <code>t</code>。</li><li>对于每个测试用例，读取两个整数 <code>n</code>（题库题目数量）和 <code>m</code>（比赛轮次），以及一个字符串 <code>a</code> 表示题库中的题目难度。</li></ul><ol start="2"><li>统计题目数量</li></ol><ul><li>使用7个变量 <code>n1</code> 到 <code>n7</code> 分别记录每种难度（A到G）的题目数量。</li><li>遍历字符串 <code>a</code>，通过比较字符 <code>c</code> 是否为 ‘A’ 到 ‘G’ 来对每种难度的题目计数。</li></ul><ol start="3"><li>每种难度的最大需求</li></ol><ul><li>每轮比赛需要一个完整的难度级别（A到G），即每种难度最多需要 mmm 道题。</li></ul><ol start="4"><li>计算需要补充的题目数量</li></ol><ul><li><p>每轮比赛需要7种难度的题目，因此总需求为 7×m7 \times m7×m。</p></li><li><p>当前已有的题目总量为 n1+n2+⋯+n7n1 + n2 + \dots + n7n1+n2+⋯+n7。</p></li><li><p>需要补充的题目数量为： 需要补充&#x3D;max⁡(0,7×m−当前已有的题目总量)\text{需要补充} &#x3D; \max(0, 7 \times m - \text{当前已有的题目总量})需要补充&#x3D;max(0,7×m−当前已有的题目总量)</p></li><li><p>如果已有题目足够，则补充为0；否则补充缺少的题目数量。</p></li></ul><ol start="5"><li>输出结果</li></ol><ul><li>将每个测试用例的结果输出在单独的一行。</li></ul><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;   </span><br><span class="line"> </span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        string a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        int n1 = 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0, n6 = 0, n7 = 0;</span><br><span class="line">        for (char c : a)</span><br><span class="line">        &#123;</span><br><span class="line">            if (c == &#x27;A&#x27;)</span><br><span class="line">                n1++;</span><br><span class="line">            if (c == &#x27;B&#x27;)</span><br><span class="line">                n2++;</span><br><span class="line">            if (c == &#x27;C&#x27;)</span><br><span class="line">                n3++;</span><br><span class="line">            if (c == &#x27;D&#x27;)</span><br><span class="line">                n4++;</span><br><span class="line">            if (c == &#x27;E&#x27;)</span><br><span class="line">                n5++;</span><br><span class="line">            if (c == &#x27;F&#x27;)</span><br><span class="line">                n6++;</span><br><span class="line">            if (c == &#x27;G&#x27;)</span><br><span class="line">                n7++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n1 &gt; m)</span><br><span class="line">            n1 = m;</span><br><span class="line">        if (n2 &gt; m)</span><br><span class="line">            n2 = m;</span><br><span class="line">        if (n3 &gt; m)</span><br><span class="line">            n3 = m;</span><br><span class="line">        if (n4 &gt; m)</span><br><span class="line">            n4 = m;</span><br><span class="line">        if (n5 &gt; m)</span><br><span class="line">            n5 = m;</span><br><span class="line">        if (n6 &gt; m)</span><br><span class="line">            n6 = m;</span><br><span class="line">        if (n7 &gt; m)</span><br><span class="line">            n7 = m;</span><br><span class="line">        cout &lt;&lt; max(0, 7 * m - n1 - n2 - n3 - n4 - n5 - n6 - n7) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ul><li><p>本题通过统计每种难度题目的数量解决问题。这是字符频率统计的典型应用。</p></li><li><p>通过遍历字符串并比较字符，可以有效统计各类别出现次数。</p></li></ul><h2 id="五-rules"><a href="#五-rules" class="headerlink" title="五.rules"></a>五.rules</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这段代码解决的问题是考察规则是否符合民意，主要步骤如下：</p><ol><li><p>输入数据：首先读取居民总数 <code>n</code>、记录天数 <code>m</code> 以及规则代号 <code>k</code>。</p></li><li><p>统计符合民意的天数：</p><p>循环 <code>m</code> 次，表示逐天处理记录。</p><p>对每一天，统计有多少居民遵守了规则 <code>k</code>（计数器 <code>c2</code>）。</p><p>如果遵守规则 <code>k</code> 的人数大于等于一半 (<code>c2 * 2 &gt;= n</code>)，则该天规则符合民意，符合民意的天数计数器 <code>c1</code> 加一。</p></li><li><p>判断规则正确性</p><p>：如果符合民意的天数大于等于记录天数的一半 (<code>c1 * 2 &gt;= m</code>)，输出 “YES” 表示规则正确，否则输出 “NO”。</p></li></ol><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m, n, k;</span><br><span class="line">int c1 = 0, c2 = 0;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">for (int i = 0; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">c2 = 0;</span><br><span class="line">for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">if (t == k)</span><br><span class="line">&#123;</span><br><span class="line">c2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if ( c2*2 &gt;=  n)</span><br><span class="line">&#123;</span><br><span class="line">c1++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;if ( c1*2 &gt;=  m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;YES&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-4"><a href="#3-学习总结-4" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>这道题目涉及多重循环的处理，是学习数组与条件判断的重要练习。通过这段代码可以总结如下：</p><ol><li><p>理解核心逻辑</p><p>问题的核心在于两层判断：一是某天规则是否符合民意，二是统计符合民意的天数是否达到要求。这种多层嵌套条件是常见的编程模式。</p></li><li><p>优化循环效率</p><p>本代码通过双重循环按天和按人处理问题，时间复杂度为 O(m×n)O(m \times n)O(m×n)。这种结构在处理范围较大时可能需要优化。</p></li><li><p>掌握计数逻辑</p><p>使用计数器 <code>c2</code> 和 <code>c1</code> 逐步累积数据，并通过条件判断更新状态。这种逻辑清晰、简洁，适合复杂问题分步解决。</p></li></ol><h2 id="六-Many-Replacement"><a href="#六-Many-Replacement" class="headerlink" title="六.Many Replacement"></a>六.Many Replacement</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p>初始化映射表：</p><p>创建一个 <code>mapping</code> 数组，长度为 26（表示字母表），初始化为 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 的对应字母。这个表将用于记录字母替换关系。</p></li><li><p>处理替换操作：</p><p>对每个替换指令 <code>(c, d)</code>，遍历 <code>mapping</code> 数组，将所有值等于 <code>c</code> 的项替换为 <code>d</code>。</p><p>这种方式确保了间接替换链条也能正确生效。例如，如果先将 <code>a</code> 替换为 <code>b</code>，再将 <code>b</code> 替换为 <code>c</code>，最终 <code>a</code> 也会被替换为 <code>c</code>。</p></li><li><p>修改字符串：</p><p>遍历字符串 <code>S</code> 的每个字符，根据 <code>mapping</code> 数组中的映射关系，将字符替换为最终映射的目标字符。</p></li><li><p>输出结果：</p><p>输出修改后的字符串 <code>S</code>。</p></li></ol><p>通过使用 <code>mapping</code> 数组记录全局映射关系，避免直接修改字符串多次，提高了处理效率。</p><h3 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, Q;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    string S;</span><br><span class="line">    cin &gt;&gt; S;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    vector&lt;char&gt; mapping(26);</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">        mapping[i] = &#x27;a&#x27; + i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; Q; i++) &#123;</span><br><span class="line">        char c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        for (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">            if (mapping[j] == c) &#123;</span><br><span class="line">                mapping[j] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (char &amp;ch : S) &#123;</span><br><span class="line">        ch = mapping[ch - &#x27;a&#x27;]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-5"><a href="#3-学习总结-5" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>1.高效处理替换链：</p><p>  使用一个映射表 (<code>mapping</code> 数组) 将字符替换逻辑统一管理，避免了直接在字符串中进行多次替换操作，降低了时间复杂度。</p><p>2.间接替换链的处理：</p><p>  通过在处理替换指令时遍历整个映射表，确保链式替换得到正确结果。这种方法适用于有依赖关系的替换问题。</p><p>3.复杂度优化：</p><p>  替换操作遍历 <code>mapping</code> 的复杂度为 O(Q×26)O(Q \times 26)O(Q×26)，字符串替换为 O(N)O(N)O(N)，整体复杂度约为 O(Q+N)O(Q + N)O(Q+N)，足以处理较大输入规模。</p><p>4.边界条件考虑：</p><p>  替换字符可以是相同的（<code>c = d</code>），这种情况不会影响映射表。</p><p>  某些字符可能不存在于字符串中，但替换逻辑依然可以正常处理。</p><h2 id="更好的交换"><a href="#更好的交换" class="headerlink" title="更好的交换"></a>更好的交换</h2><h3 id="1-对应思路-6"><a href="#1-对应思路-6" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p>输入与初始化：</p><p>读取矩阵大小 <code>n</code> 和操作次数 <code>m</code>。</p><p>读取矩阵内容并存储在 <code>matrix</code> 中。</p><p>初始化两个数组 <code>row_map</code> 和 <code>col_map</code>，分别记录行和列的映射关系，初始值为 <code>[0, 1, 2, ..., n-1]</code>。</p></li><li><p>操作处理：</p><p>遍历每个操作，根据操作类型：</p><p>  若 <code>op == 1</code>（交换行），则交换 <code>row_map[x]</code> 和 <code>row_map[y]</code>。</p><p>  若 <code>op == 0</code>（交换列），则交换 <code>col_map[x]</code> 和 <code>col_map[y]</code>。</p><p>通过修改 <code>row_map</code> 和 <code>col_map</code> 的映射关系，而非直接修改矩阵，节省了时间复杂度。</p></li><li><p>输出矩阵：</p><p>根据最终的 <code>row_map</code> 和 <code>col_map</code>，重新按映射顺序输出矩阵。<code>matrix[row_map[i]][col_map[j]]</code> 得到正确的映射值。</p></li></ol><p>通过这种间接映射法，避免了每次交换直接操作矩阵，提高了效率，适合大规模输入。</p><h3 id="2-代码-6"><a href="#2-代码-6" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n));</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; row_map(n), col_map(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        row_map[i] = i; </span><br><span class="line">        col_map[i] = i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        --x; </span><br><span class="line">        --y;</span><br><span class="line">        if (op == 1) &#123;</span><br><span class="line">            swap(row_map[x], row_map[y]); </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            swap(col_map[x], col_map[y]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; matrix[row_map[i]][col_map[j]] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-6"><a href="#3-学习总结-6" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>间接映射优化：</p><p>​    直接交换矩阵行列会带来高昂的时间复杂度，间接通过映射数组调整顺序是一种高效的解决方式。</p><p>空间与时间的平衡：</p><p>​    增加两个映射数组 <code>row_map</code> 和 <code>col_map</code>，用空间换取了时间的优化。</p><p>​    在 mmm 次操作和 n2n^2n2 次矩阵访问中，复杂度降低为 O(n2+m)O(n^2 + m)O(n2+m)，适合处理大规模 n,mn, mn,m。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog用法</title>
      <link href="/2025/02/06/blog%E7%94%A8%E6%B3%95/"/>
      <url>/2025/02/06/blog%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h1 id="本地网站"><a href="#本地网站" class="headerlink" title="本地网站"></a>本地网站</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/06/hello-world/"/>
      <url>/2025/02/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
