<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>全局获取context的技巧</title>
      <link href="/2025/04/06/%E5%85%A8%E5%B1%80%E8%8E%B7%E5%8F%96context%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
      <url>/2025/04/06/%E5%85%A8%E5%B1%80%E8%8E%B7%E5%8F%96context%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="全局获取-Context-的技巧（Android）"><a href="#全局获取-Context-的技巧（Android）" class="headerlink" title="全局获取 Context 的技巧（Android）"></a>全局获取 Context 的技巧（Android）</h1><p>在 Android 开发中，我们经常需要获取 <code>Context</code>，例如启动 Activity、创建 View、访问资源、使用系统服务等。但不恰当地获取或保留 <code>Context</code> 会导致内存泄漏等问题。</p><p>本篇文章介绍几种<strong>安全、规范地全局获取 Context 的技巧</strong>，并说明哪些方式应当避免。</p><hr><h2 id="为什么需要全局-Context？"><a href="#为什么需要全局-Context？" class="headerlink" title="为什么需要全局 Context？"></a>为什么需要全局 Context？</h2><p>一些典型的使用场景：</p><ul><li>初始化第三方 SDK</li><li>弹 Toast 消息</li><li>获取系统服务（如 <code>ClipboardManager</code>）</li><li>访问资源文件（<code>getString()</code>、<code>getDrawable()</code> 等）</li></ul><hr><h2 id="正确方式：使用-Application-Context"><a href="#正确方式：使用-Application-Context" class="headerlink" title="正确方式：使用 Application Context"></a>正确方式：使用 Application Context</h2><h3 id="方法-1：自定义-Application-类"><a href="#方法-1：自定义-Application-类" class="headerlink" title="方法 1：自定义 Application 类"></a>方法 1：自定义 Application 类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyApp : Application() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        appContext = applicationContext</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        lateinit var appContext: Context</span><br><span class="line">            private set</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 <code>AndroidManifest.xml</code> 中注册：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:name=&quot;.MyApp&quot;</span><br><span class="line">    ...&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure><p><strong>使用方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ctx = MyApp.appContext</span><br></pre></td></tr></table></figure><p>✅ <strong>优点：</strong></p><ul><li>生命周期和 App 一致，不会泄漏</li><li>适用于 Toast、资源访问、初始化等场景</li></ul><p>❌ <strong>注意：</strong></p><ul><li>不可用于 UI 创建（如 <code>Dialog(this)</code>），需要传入 Activity Context</li></ul><hr><h2 id="方法-2：使用-Singleton-Application-Context"><a href="#方法-2：使用-Singleton-Application-Context" class="headerlink" title="方法 2：使用 Singleton + Application Context"></a>方法 2：使用 Singleton + Application Context</h2><p>适用于工具类或管理类中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object ToastUtil &#123;</span><br><span class="line"></span><br><span class="line">    fun show(msg: String) &#123;</span><br><span class="line">        Toast.makeText(MyApp.appContext, msg, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="错误示范（⚠️避免）："><a href="#错误示范（⚠️避免）：" class="headerlink" title="错误示范（⚠️避免）："></a>错误示范（⚠️避免）：</h2><h3 id="❌-静态保存-Activity-Context"><a href="#❌-静态保存-Activity-Context" class="headerlink" title="❌ 静态保存 Activity Context"></a>❌ 静态保存 Activity Context</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object MyManager &#123;</span><br><span class="line">    var context: Context? = null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这会导致 Activity 无法被回收，严重时引发内存泄漏。</p></blockquote><h3 id="❌-使用-View-getContext-做非-UI-操作"><a href="#❌-使用-View-getContext-做非-UI-操作" class="headerlink" title="❌ 使用 View.getContext() 做非 UI 操作"></a>❌ 使用 <code>View.getContext()</code> 做非 UI 操作</h3><p>View 的 <code>Context</code> 实际上是 Activity，一旦页面销毁仍保留引用，也可能泄漏。</p><hr><h2 id="Jetpack-推荐方式（进阶）"><a href="#Jetpack-推荐方式（进阶）" class="headerlink" title="Jetpack 推荐方式（进阶）"></a>Jetpack 推荐方式（进阶）</h2><p>在使用 <strong>ViewModel、Hilt、Jetpack Compose</strong> 时，建议使用依赖注入（DI）或 <code>SavedStateHandle</code> 等方式获取 <code>Context</code>，更加灵活和可测试。</p><p>例如使用 Hilt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@HiltViewModel</span><br><span class="line">class MyViewModel @Inject constructor(</span><br><span class="line">    @ApplicationContext val context: Context</span><br><span class="line">) : ViewModel()</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>获取方式</th><th>是否推荐</th><th>说明</th></tr></thead><tbody><tr><td><code>applicationContext</code></td><td>✅ 推荐</td><td>生命周期长，不易泄漏</td></tr><tr><td>自定义 <code>Application</code> 保存 context</td><td>✅ 推荐</td><td>全局工具类中使用</td></tr><tr><td>Activity &#x2F; View context 静态持有</td><td>❌ 避免</td><td>易泄漏内存</td></tr><tr><td>依赖注入框架注入 context</td><td>✅ 推荐</td><td>可测试性好，架构现代</td></tr></tbody></table><hr><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>避免传递 Context 给单例或静态类</li><li>只在需要 UI 的地方使用 Activity Context</li><li>工具类中尽可能使用 Application Context</li><li>引入 Hilt &#x2F; Koin 等依赖注入框架管理依赖</li></ul><hr><p>希望这篇文章能帮助你在项目中更好地管理 Context，避免常见陷阱。如果你有其他技巧或问题，欢迎留言交流！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin DSL</title>
      <link href="/2025/04/05/Kotlin-DSL/"/>
      <url>/2025/04/05/Kotlin-DSL/</url>
      
        <content type="html"><![CDATA[<h2 id="💬-什么是-Kotlin-DSL？"><a href="#💬-什么是-Kotlin-DSL？" class="headerlink" title="💬 什么是 Kotlin DSL？"></a>💬 什么是 Kotlin DSL？</h2><p>DSL 就像你用 Kotlin 写的“<strong>小语言</strong>”或“<strong>专属语法</strong>”。</p><p>比如你写一个配置文件或者描述页面内容时，希望这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page &#123;</span><br><span class="line">    title = &quot;欢迎来到我的网站&quot;</span><br><span class="line">    header &#123;</span><br><span class="line">        text = &quot;Hello!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    paragraph &#123;</span><br><span class="line">        text = &quot;这里是正文内容&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来像“自己发明的语言”，对吧？这个就是 Kotlin DSL 的目标：<strong>写出接近自然语言的代码</strong>，让代码更“会说话”。</p><hr><h2 id="🧱-怎么做？用-Kotlin-的-3-个小技巧就可以了："><a href="#🧱-怎么做？用-Kotlin-的-3-个小技巧就可以了：" class="headerlink" title="🧱 怎么做？用 Kotlin 的 3 个小技巧就可以了："></a>🧱 怎么做？用 Kotlin 的 3 个小技巧就可以了：</h2><h3 id="1️⃣-高阶函数（函数里面传函数）"><a href="#1️⃣-高阶函数（函数里面传函数）" class="headerlink" title="1️⃣ 高阶函数（函数里面传函数）"></a>1️⃣ 高阶函数（函数里面传函数）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun doSomething(block: () -&gt; Unit) &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以这样用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething &#123;</span><br><span class="line">    println(&quot;Hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2️⃣-Lambda-with-Receiver（这个超重要，是-DSL-的核心）"><a href="#2️⃣-Lambda-with-Receiver（这个超重要，是-DSL-的核心）" class="headerlink" title="2️⃣ Lambda with Receiver（这个超重要，是 DSL 的核心）"></a>2️⃣ Lambda with Receiver（这个超重要，是 DSL 的核心）</h3><p>看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name = &quot;&quot;</span><br><span class="line">    fun sayHello() &#123;</span><br><span class="line">        println(&quot;Hello, my name is $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun createPerson(block: Person.() -&gt; Unit): Person &#123;</span><br><span class="line">    val person = Person()</span><br><span class="line">    person.block() // 注意是 person.block()</span><br><span class="line">    return person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val p = createPerson &#123;</span><br><span class="line">    name = &quot;Tom&quot;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很像自己在写一门“人类建造语言”？这就是 DSL 的味道！</p><hr><h3 id="3️⃣-apply-是帮你省代码的神器"><a href="#3️⃣-apply-是帮你省代码的神器" class="headerlink" title="3️⃣ apply 是帮你省代码的神器"></a>3️⃣ <code>apply</code> 是帮你省代码的神器</h3><p>等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val person = Person()</span><br><span class="line">person.name = &quot;Tom&quot;</span><br><span class="line">person.sayHello()</span><br></pre></td></tr></table></figure><p>写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val person = Person().apply &#123;</span><br><span class="line">    name = &quot;Tom&quot;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🛠-我们做个最简单的-DSL-示例：构建菜单"><a href="#🛠-我们做个最简单的-DSL-示例：构建菜单" class="headerlink" title="🛠 我们做个最简单的 DSL 示例：构建菜单"></a>🛠 我们做个最简单的 DSL 示例：构建菜单</h2><p>我们希望能这样写代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu &#123;</span><br><span class="line">    item(&quot;打开&quot;)</span><br><span class="line">    item(&quot;保存&quot;)</span><br><span class="line">    item(&quot;退出&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="👉-DSL-实现代码："><a href="#👉-DSL-实现代码：" class="headerlink" title="👉 DSL 实现代码："></a>👉 DSL 实现代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Menu &#123;</span><br><span class="line">    private val items = mutableListOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    fun item(name: String) &#123;</span><br><span class="line">        items.add(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun show() &#123;</span><br><span class="line">        println(&quot;菜单内容：&quot;)</span><br><span class="line">        items.forEach &#123;</span><br><span class="line">            println(&quot; - $it&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun menu(block: Menu.() -&gt; Unit): Menu &#123;</span><br><span class="line">    val m = Menu()</span><br><span class="line">    m.block()</span><br><span class="line">    return m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="✅-使用："><a href="#✅-使用：" class="headerlink" title="✅ 使用："></a>✅ 使用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val myMenu = menu &#123;</span><br><span class="line">    item(&quot;打开&quot;)</span><br><span class="line">    item(&quot;保存&quot;)</span><br><span class="line">    item(&quot;退出&quot;)</span><br><span class="line">&#125;</span><br><span class="line">myMenu.show()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">菜单内容：</span><br><span class="line"> - 打开</span><br><span class="line"> - 保存</span><br><span class="line"> - 退出</span><br></pre></td></tr></table></figure><hr><h2 id="✅-小结一句话："><a href="#✅-小结一句话：" class="headerlink" title="✅ 小结一句话："></a>✅ 小结一句话：</h2><blockquote><p>Kotlin DSL &#x3D; 自己写一个函数（用 lambda with receiver） + 定义类结构 + <code>apply()</code>，就能造出一套看起来像“自己写的语言”的代码。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiveData用法详解</title>
      <link href="/2025/04/04/LiveData%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/LiveData%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><strong>LiveData</strong> 是 Android Jetpack 中的一个生命周期感知型数据容器。它的主要特点是：</p><ul><li><strong>生命周期感知</strong>：LiveData 会根据观察者（如 Activity、Fragment）的生命周期状态自动管理数据更新，避免内存泄漏和崩溃问题。</li><li><strong>数据驱动 UI 更新</strong>：当 LiveData 数据发生变化时，所有处于活跃状态的观察者都会被自动通知更新 UI，无需手动管理。</li><li><strong>解耦 UI 与数据</strong>：在 MVVM 架构中，ViewModel 将数据放入 LiveData 中，UI 层只负责观察数据变化，从而实现数据和 UI 的分离，降低耦合度。</li></ul><hr><h2 id="二、为什么选择-LiveData？"><a href="#二、为什么选择-LiveData？" class="headerlink" title="二、为什么选择 LiveData？"></a>二、为什么选择 LiveData？</h2><h3 id="1-生命周期安全"><a href="#1-生命周期安全" class="headerlink" title="1. 生命周期安全"></a>1. 生命周期安全</h3><p>LiveData 了解观察者的生命周期状态（如创建、启动、暂停、销毁），仅当观察者处于活跃状态时才发送更新，这样可以避免：</p><ul><li>内存泄漏：当 Activity 或 Fragment 销毁后，LiveData 不再持有无用的引用。</li><li>更新崩溃：例如，当 UI 已经销毁时，不再尝试更新视图。</li></ul><h3 id="2-自动数据更新"><a href="#2-自动数据更新" class="headerlink" title="2. 自动数据更新"></a>2. 自动数据更新</h3><p>无需手动调用刷新方法。只要数据变化，所有绑定了 LiveData 的 UI 都会自动更新，这大大简化了代码逻辑。</p><h3 id="3-与-MVVM-架构的完美结合"><a href="#3-与-MVVM-架构的完美结合" class="headerlink" title="3. 与 MVVM 架构的完美结合"></a>3. 与 MVVM 架构的完美结合</h3><p>在 MVVM 架构中，ViewModel 存储 UI 数据，LiveData 则负责将数据传递给 UI 层，这种模式使得数据和界面逻辑彻底分离，便于维护和测试。</p><hr><h2 id="三、LiveData-的基本使用"><a href="#三、LiveData-的基本使用" class="headerlink" title="三、LiveData 的基本使用"></a>三、LiveData 的基本使用</h2><h3 id="1-创建-LiveData-对象"><a href="#1-创建-LiveData-对象" class="headerlink" title="1. 创建 LiveData 对象"></a>1. 创建 LiveData 对象</h3><p>通常，我们会使用 <code>MutableLiveData</code> 来创建一个可以修改的数据容器，然后在 ViewModel 中公开为只读的 <code>LiveData</code> 给 UI 层使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel : ViewModel() &#123;</span><br><span class="line">    // 内部可变的 LiveData</span><br><span class="line">    private val _message = MutableLiveData&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line">    // 对外只读的 LiveData</span><br><span class="line">    val message: LiveData&lt;String&gt; = _message</span><br><span class="line"></span><br><span class="line">    fun updateMessage(newMessage: String) &#123;</span><br><span class="line">        // setValue() 在主线程更新数据，postValue() 则适用于子线程更新数据</span><br><span class="line">        _message.value = newMessage</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-观察-LiveData-数据变化"><a href="#2-观察-LiveData-数据变化" class="headerlink" title="2. 观察 LiveData 数据变化"></a>2. 观察 LiveData 数据变化</h3><p>在 Activity 或 Fragment 中观察 LiveData，当数据发生变化时，观察者会收到通知，从而更新 UI：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var viewModel: MyViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        </span><br><span class="line">        viewModel = ViewModelProvider(this).get(MyViewModel::class.java)</span><br><span class="line">        </span><br><span class="line">        // 绑定观察者</span><br><span class="line">        viewModel.message.observe(this, Observer &#123; newMessage -&gt;</span><br><span class="line">            // 当 LiveData 数据变化时，这里的代码会执行，更新界面</span><br><span class="line">            findViewById&lt;TextView&gt;(R.id.textView).text = newMessage</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-数据更新方法"><a href="#3-数据更新方法" class="headerlink" title="3. 数据更新方法"></a>3. 数据更新方法</h3><ul><li><strong>setValue()</strong>：必须在主线程中调用，用于同步更新数据。</li><li><strong>postValue()</strong>：可在子线程中调用，内部机制会将更新切换到主线程再通知观察者。</li></ul><p>例如，在异步任务中更新数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread &#123;</span><br><span class="line">    // 模拟耗时操作</span><br><span class="line">    Thread.sleep(1000)</span><br><span class="line">    // 子线程中更新数据</span><br><span class="line">    viewModel.updateMessage(&quot;异步更新后的数据&quot;)</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><hr><h2 id="四、LiveData-的高级扩展"><a href="#四、LiveData-的高级扩展" class="headerlink" title="四、LiveData 的高级扩展"></a>四、LiveData 的高级扩展</h2><h3 id="1-Transformations-map"><a href="#1-Transformations-map" class="headerlink" title="1. Transformations.map()"></a>1. Transformations.map()</h3><p><code>map()</code> 用于将一个 LiveData 数据转换成另一种类型的 LiveData，而无需手动创建新的观察者。<br> <strong>示例：</strong> 将用户的年龄转换为是否成年（布尔值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val ageLiveData = MutableLiveData&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">// 使用 map() 将 ageLiveData 转换为是否成年</span><br><span class="line">val isAdultLiveData: LiveData&lt;Boolean&gt; = Transformations.map(ageLiveData) &#123; age -&gt;</span><br><span class="line">    age &gt;= 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isAdultLiveData.observe(this, Observer &#123; isAdult -&gt;</span><br><span class="line">    val message = if (isAdult) &quot;用户是成年人&quot; else &quot;用户是未成年人&quot;</span><br><span class="line">    println(message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 改变年龄数据，观察者会自动更新</span><br><span class="line">ageLiveData.value = 20  // 输出：用户是成年人</span><br></pre></td></tr></table></figure><h3 id="2-Transformations-switchMap"><a href="#2-Transformations-switchMap" class="headerlink" title="2. Transformations.switchMap()"></a>2. Transformations.switchMap()</h3><p><code>switchMap()</code> 用于根据一个 LiveData 的值切换到另一个 LiveData 数据源，适合于需要动态查询数据的场景（例如根据用户 ID 请求数据）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val userIdLiveData = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">// 假设 fetchUserDetails 返回一个 LiveData&lt;User&gt;</span><br><span class="line">val userLiveData: LiveData&lt;User&gt; = Transformations.switchMap(userIdLiveData) &#123; userId -&gt;</span><br><span class="line">    fetchUserDetails(userId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">userLiveData.observe(this, Observer &#123; user -&gt;</span><br><span class="line">    println(&quot;用户信息：$&#123;user.name&#125;, $&#123;user.email&#125;&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 当 userId 变化时，会自动触发新的数据请求</span><br><span class="line">userIdLiveData.value = &quot;12345&quot;</span><br></pre></td></tr></table></figure><p>在这里，当 <code>userIdLiveData</code> 改变时，<code>switchMap()</code> 会取消之前的查询并启动新的查询，将结果返回给 <code>userLiveData</code>。</p><hr><h2 id="五、LiveData-在-MVVM-中的应用"><a href="#五、LiveData-在-MVVM-中的应用" class="headerlink" title="五、LiveData 在 MVVM 中的应用"></a>五、LiveData 在 MVVM 中的应用</h2><p>在 MVVM 架构中，LiveData 扮演着数据和 UI 间的桥梁作用：</p><ol><li><strong>ViewModel 存储业务数据</strong>：ViewModel 通过 MutableLiveData 存储数据，并对外暴露只读 LiveData。</li><li><strong>UI 层观察数据变化</strong>：Activity 或 Fragment 观察 LiveData，当数据更新时自动刷新界面。</li><li><strong>生命周期管理</strong>：LiveData 会自动在 UI 组件处于活跃状态时通知更新，在 UI 不活跃时停止通知，避免无用的操作和内存泄漏。</li></ol><p>这种方式使得数据更新、UI 刷新以及生命周期管理变得简单且一致，开发者无需手动管理复杂的回调和状态变化。</p><hr><h2 id="六、注意事项与最佳实践"><a href="#六、注意事项与最佳实践" class="headerlink" title="六、注意事项与最佳实践"></a>六、注意事项与最佳实践</h2><h3 id="1-避免内存泄漏"><a href="#1-避免内存泄漏" class="headerlink" title="1. 避免内存泄漏"></a>1. 避免内存泄漏</h3><ul><li><strong>使用 ViewModel</strong>：将 LiveData 存储在 ViewModel 中，确保 Activity 或 Fragment 销毁时，数据不会因引用而泄漏。</li><li><strong>绑定生命周期</strong>：在 observe() 时传入生命周期拥有者，如 Activity 或 Fragment，以便 LiveData 根据生命周期自动取消观察。</li></ul><h3 id="2-数据一致性问题"><a href="#2-数据一致性问题" class="headerlink" title="2. 数据一致性问题"></a>2. 数据一致性问题</h3><ul><li>如果同时有多个数据源需要更新 UI，确保数据的发布顺序和依赖关系正确。</li><li>使用 Transformations 可以方便地管理数据转换，确保转换逻辑与业务逻辑分离。</li></ul><h3 id="3-主线程与子线程更新"><a href="#3-主线程与子线程更新" class="headerlink" title="3. 主线程与子线程更新"></a>3. 主线程与子线程更新</h3><ul><li>在主线程中使用 setValue()，在子线程中使用 postValue()，以免引起线程安全问题。</li></ul><hr><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><strong>LiveData</strong> 作为 Android Jetpack 的核心组件，在 MVVM 架构中发挥着至关重要的作用。它不仅能够自动感知生命周期，避免内存泄漏，还能简化数据和 UI 之间的更新逻辑。通过使用 <code>Transformations.map()</code> 和 <code>switchMap()</code>，你可以方便地对数据进行转换和动态切换，进一步提高代码的简洁性和可维护性。</p><h3 id="关键点回顾："><a href="#关键点回顾：" class="headerlink" title="关键点回顾："></a>关键点回顾：</h3><ul><li><strong>生命周期感知</strong>：LiveData 会自动根据观察者的生命周期状态通知数据更新。</li><li><strong>数据驱动 UI 更新</strong>：数据变化后，所有活跃的观察者都会自动刷新 UI。</li><li><strong>数据转换</strong>：通过 map() 和 switchMap() 扩展方法，可以方便地对数据进行转换和动态切换。</li><li><strong>MVVM 中的应用</strong>：ViewModel 存储数据，UI 通过观察 LiveData 来更新视图，极大简化了数据流转逻辑。</li></ul><p>掌握了 LiveData 的使用和扩展方法，你将能够更高效、更安全地构建响应式的 Android 应用。如果你在实际开发中遇到问题，欢迎深入探讨或查阅相关资料，持续提升开发技能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lifecycles用法示例</title>
      <link href="/2025/04/04/Lifecycles%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/04/04/Lifecycles%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>下面提供一个使用 Kotlin 讲解 Android Lifecycle 的示例，包含 LifecycleObserver、LiveData 和 ViewModel 的使用，帮助你理解如何在 Kotlin 中管理 Activity 的生命周期。</p><hr><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h2><p>在你的 <code>build.gradle</code> 文件中添加 Lifecycle 相关依赖（版本号可根据项目需求调整）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // Lifecycle 组件依赖</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-extensions:2.2.0&quot;</span><br><span class="line">    // 单独使用 ViewModel 与 LiveData（推荐这种方式，依赖更明确）</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&quot;</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:2.2.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-使用-LifecycleObserver-监听生命周期变化"><a href="#2-使用-LifecycleObserver-监听生命周期变化" class="headerlink" title="2. 使用 LifecycleObserver 监听生命周期变化"></a>2. 使用 LifecycleObserver 监听生命周期变化</h2><p>使用 Kotlin 编写一个 LifecycleObserver 类，通过注解监听生命周期事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.Lifecycle</span><br><span class="line">import androidx.lifecycle.LifecycleObserver</span><br><span class="line">import androidx.lifecycle.OnLifecycleEvent</span><br><span class="line">import android.util.Log</span><br><span class="line"></span><br><span class="line">class MyObserver : LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    fun onCreateEvent() &#123;</span><br><span class="line">        Log.d(&quot;MyObserver&quot;, &quot;onCreate 触发&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_START)</span><br><span class="line">    fun onStartEvent() &#123;</span><br><span class="line">        Log.d(&quot;MyObserver&quot;, &quot;onStart 触发&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span><br><span class="line">    fun onDestroyEvent() &#123;</span><br><span class="line">        Log.d(&quot;MyObserver&quot;, &quot;onDestroy 触发&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Activity 中注册这个观察者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import android.os.Bundle</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        // 注册 LifecycleObserver</span><br><span class="line">        val observer = MyObserver()</span><br><span class="line">        lifecycle.addObserver(observer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>MyObserver</code> 中的方法会在对应的生命周期事件时自动调用。</p><hr><h2 id="3-使用-LiveData-与-ViewModel"><a href="#3-使用-LiveData-与-ViewModel" class="headerlink" title="3. 使用 LiveData 与 ViewModel"></a>3. 使用 LiveData 与 ViewModel</h2><h3 id="定义-ViewModel"><a href="#定义-ViewModel" class="headerlink" title="定义 ViewModel"></a>定义 ViewModel</h3><p>创建一个继承自 <code>ViewModel</code> 的类，使用 MutableLiveData 来管理数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line">import androidx.lifecycle.MutableLiveData</span><br><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line">class MyViewModel : ViewModel() &#123;</span><br><span class="line">    // 内部可修改的 LiveData</span><br><span class="line">    private val _myData = MutableLiveData&lt;String&gt;()</span><br><span class="line">    // 对外只暴露不可变的 LiveData</span><br><span class="line">    val myData: LiveData&lt;String&gt; = _myData</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        loadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun loadData() &#123;</span><br><span class="line">        // 模拟异步加载数据，这里直接赋值</span><br><span class="line">        _myData.value = &quot;Hello, Lifecycle in Kotlin!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-Activity-中观察-LiveData"><a href="#在-Activity-中观察-LiveData" class="headerlink" title="在 Activity 中观察 LiveData"></a>在 Activity 中观察 LiveData</h3><p>在 Activity 中获取 ViewModel，并观察 LiveData 数据变化，自动更新 UI：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.util.Log</span><br><span class="line">import androidx.lifecycle.Observer</span><br><span class="line">import androidx.lifecycle.ViewModelProvider</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        // 获取 ViewModel 实例</span><br><span class="line">        val viewModel = ViewModelProvider(this).get(MyViewModel::class.java)</span><br><span class="line"></span><br><span class="line">        // 观察 LiveData 的变化</span><br><span class="line">        viewModel.myData.observe(this, Observer &#123; data -&gt;</span><br><span class="line">            // 当数据变化时，这里的代码会自动执行，比如更新 UI</span><br><span class="line">            Log.d(&quot;MainActivity&quot;, &quot;接收到数据：$data&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>LiveData</code> 会自动感知 <code>MainActivity</code> 的生命周期，仅在界面处于活跃状态时更新数据，从而避免内存泄露问题。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>LifecycleObserver</strong>：通过注解方法自动监听 Activity 或 Fragment 的生命周期，简化了传统生命周期回调的代码管理。</li><li><strong>LifecycleOwner</strong>：Activity 和 Fragment 默认实现此接口，可直接使用 <code>lifecycle.addObserver()</code> 注册观察者。</li><li><strong>LiveData 与 ViewModel</strong>：配合使用可以自动更新 UI，处理配置变化（如屏幕旋转）时数据不会丢失，同时减少内存泄露风险。</li></ul><p>这种方式能让你编写的代码更加模块化、易于维护和测试。希望这个 Kotlin 示例对你理解 Android Lifecycle 的使用有所帮助！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CollapsingToolbarLayout用法详解</title>
      <link href="/2025/04/04/CollapsingToolbarLayout%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/CollapsingToolbarLayout%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>CollapsingToolbarLayout</code> 是 Android Material Components 库中的一个布局组件，主要用于创建可以在滚动过程中折叠和展开的应用栏（AppBar）。它通常与 <code>AppBarLayout</code> 一起使用，以便为应用的顶部区域提供丰富的交互效果。<code>CollapsingToolbarLayout</code> 是实现 Material Design 风格中的可折叠应用栏的重要工具，广泛应用于那些需要动态调整应用栏内容的场景。</p><p><code>CollapsingToolbarLayout</code> 可以结合 <code>Toolbar</code>、<code>ImageView</code> 等控件一起使用，支持滚动时自动折叠、动态改变标题、背景等效果。它能够在用户滚动页面时提供丰富的视觉反馈，提高用户体验。</p><hr><h2 id="二、依赖与导入"><a href="#二、依赖与导入" class="headerlink" title="二、依赖与导入"></a>二、依赖与导入</h2><p>在使用 <code>CollapsingToolbarLayout</code> 之前，确保你的项目已加入 <code>Material Components</code> 的依赖。可以在项目的 <code>build.gradle</code> 文件中添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.google.android.material:material:1.4.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、CollapsingToolbarLayout-基本用法"><a href="#三、CollapsingToolbarLayout-基本用法" class="headerlink" title="三、CollapsingToolbarLayout 基本用法"></a>三、CollapsingToolbarLayout 基本用法</h2><h3 id="1-在-XML-布局中使用-CollapsingToolbarLayout"><a href="#1-在-XML-布局中使用-CollapsingToolbarLayout" class="headerlink" title="1. 在 XML 布局中使用 CollapsingToolbarLayout"></a>1. 在 XML 布局中使用 <code>CollapsingToolbarLayout</code></h3><p><code>CollapsingToolbarLayout</code> 通常需要放置在 <code>AppBarLayout</code> 中，并与 <code>Toolbar</code>、<code>ImageView</code> 等控件一起使用，以实现折叠和展开的效果。以下是一个基本的例子，展示了如何在 XML 布局中使用 <code>CollapsingToolbarLayout</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.appbar.AppBarLayout</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- CollapsingToolbarLayout 包裹 Toolbar 和其他视图 --&gt;</span><br><span class="line">    &lt;com.google.android.material.appbar.CollapsingToolbarLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</span><br><span class="line">        app:contentScrim=&quot;?attr/colorPrimary&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Toolbar 用于显示标题 --&gt;</span><br><span class="line">        &lt;androidx.appcompat.widget.Toolbar</span><br><span class="line">            android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">            android:title=&quot;Collapsing Toolbar Example&quot;</span><br><span class="line">            android:theme=&quot;@style/ThemeOverlay.MaterialComponents.ActionBar&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 用于显示背景图像，当滚动时图像会折叠 --&gt;</span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:id=&quot;@+id/headerImage&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;200dp&quot;</span><br><span class="line">            android:src=&quot;@drawable/sample_image&quot;</span><br><span class="line">            android:scaleType=&quot;centerCrop&quot; /&gt;</span><br><span class="line">    &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/com.google.android.material.appbar.AppBarLayout&gt;</span><br></pre></td></tr></table></figure><p>在这个布局中：</p><ul><li><code>CollapsingToolbarLayout</code> 包裹了 <code>Toolbar</code> 和其他视图（例如 <code>ImageView</code>）。</li><li><code>layout_scrollFlags</code> 控制视图滚动时的行为。<code>scroll|exitUntilCollapsed</code> 表示该视图会随着页面滚动而折叠，直到完全消失。</li><li><code>contentScrim</code> 属性用于设置折叠时的背景颜色。</li></ul><h3 id="2-配置折叠行为"><a href="#2-配置折叠行为" class="headerlink" title="2. 配置折叠行为"></a>2. 配置折叠行为</h3><p><code>CollapsingToolbarLayout</code> 可以设置多个滚动标志，来控制折叠行为。这些标志与 <code>AppBarLayout</code> 的滚动标志相似。常见的滚动标志包括：</p><ul><li><strong>scroll</strong>：该视图在滚动时会跟随滚动视图一起移动。</li><li><strong>exitUntilCollapsed</strong>：该视图会在滚动过程中折叠，直到完全消失。</li><li><strong>enterAlways</strong>：该视图在滚动时始终显示，并进入屏幕。</li><li><strong>snap</strong>：在滚动结束时，视图会立即折叠到固定位置。</li></ul><p>你可以根据需要选择合适的滚动标志来实现不同的滚动和折叠效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;</span><br></pre></td></tr></table></figure><h3 id="3-滚动视图与-CollapsingToolbarLayout-配合"><a href="#3-滚动视图与-CollapsingToolbarLayout-配合" class="headerlink" title="3. 滚动视图与 CollapsingToolbarLayout 配合"></a>3. 滚动视图与 <code>CollapsingToolbarLayout</code> 配合</h3><p><code>CollapsingToolbarLayout</code> 通常与可以滚动的视图（如 <code>RecyclerView</code> 或 <code>NestedScrollView</code>）结合使用，以实现更流畅的滚动折叠效果。你可以通过设置 <code>app:layout_behavior</code> 属性，控制这些滚动视图与应用栏的交互行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">    android:id=&quot;@+id/recyclerView&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt;</span><br></pre></td></tr></table></figure><p><code>@string/appbar_scrolling_view_behavior</code> 是 Material Design 中预定义的滚动行为，能够让滚动视图与 <code>AppBarLayout</code> 协同工作。</p><hr><h2 id="四、CollapsingToolbarLayout-特性"><a href="#四、CollapsingToolbarLayout-特性" class="headerlink" title="四、CollapsingToolbarLayout 特性"></a>四、CollapsingToolbarLayout 特性</h2><h3 id="1-动态改变标题"><a href="#1-动态改变标题" class="headerlink" title="1. 动态改变标题"></a>1. 动态改变标题</h3><p><code>CollapsingToolbarLayout</code> 允许你在滚动过程中动态改变 <code>Toolbar</code> 上的标题。通常，折叠时显示一个简短的标题，展开时显示完整的标题。你可以通过 <code>setTitle()</code> 和 <code>setExpandedTitleTextAppearance()</code> 等方法动态更新标题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val collapsingToolbarLayout = findViewById&lt;CollapsingToolbarLayout&gt;(R.id.collapsingToolbarLayout)</span><br><span class="line">val toolbar = findViewById&lt;Toolbar&gt;(R.id.toolbar)</span><br><span class="line"></span><br><span class="line">// 设置展开时的标题</span><br><span class="line">collapsingToolbarLayout.title = &quot;Collapsing Toolbar&quot;</span><br><span class="line"></span><br><span class="line">// 设置折叠时的标题样式</span><br><span class="line">collapsingToolbarLayout.setCollapsedTitleTextAppearance(R.style.CollapsedTitleTextStyle)</span><br><span class="line">collapsingToolbarLayout.setExpandedTitleTextAppearance(R.style.ExpandedTitleTextStyle)</span><br></pre></td></tr></table></figure><h3 id="2-设置折叠的背景图像"><a href="#2-设置折叠的背景图像" class="headerlink" title="2. 设置折叠的背景图像"></a>2. 设置折叠的背景图像</h3><p><code>CollapsingToolbarLayout</code> 支持动态设置背景图像，当用户滚动时，图像会折叠或展开。你可以通过 <code>setBackground()</code> 方法设置背景，或者直接在 XML 中使用 <code>ImageView</code> 来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val imageView = findViewById&lt;ImageView&gt;(R.id.headerImage)</span><br><span class="line">collapsingToolbarLayout.setBackgroundResource(R.drawable.sample_image)</span><br></pre></td></tr></table></figure><h3 id="3-支持渐变效果"><a href="#3-支持渐变效果" class="headerlink" title="3. 支持渐变效果"></a>3. 支持渐变效果</h3><p>你可以设置渐变效果，让 <code>CollapsingToolbarLayout</code> 在滚动时产生更平滑的折叠效果。例如，可以设置背景颜色的渐变、标题文字的渐变等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:contentScrim=&quot;?attr/colorPrimary&quot;</span><br><span class="line">app:statusBarScrim=&quot;?attr/colorPrimaryDark&quot;</span><br></pre></td></tr></table></figure><p><code>contentScrim</code> 设置折叠时的背景颜色，<code>statusBarScrim</code> 设置状态栏的背景颜色。</p><hr><h2 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h2><p><code>CollapsingToolbarLayout</code> 适用于需要动态、交互性强的应用栏设计场景。以下是一些常见的应用场景：</p><ol><li><strong>社交媒体应用</strong>：展示用户头像、昵称以及个人资料，支持折叠展开效果，增强用户体验。</li><li><strong>新闻或博客应用</strong>：展示文章标题、背景图片等内容，随着用户滚动，标题和图片动态变化。</li><li><strong>电子商务应用</strong>：商品详情页面中，展示商品图片、价格、描述等内容，折叠和展开的动态效果增强了视觉效果。</li><li><strong>图片浏览应用</strong>：展示大图或封面图像，折叠时可显示简短的标题或描述。</li></ol><hr><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p><code>CollapsingToolbarLayout</code> 是 Android Material Design 中一个非常强大的组件，它使得应用栏能够在滚动时实现折叠与展开的效果，极大地提升了用户体验。它与 <code>AppBarLayout</code> 配合使用，支持丰富的交互效果，能够根据不同的场景动态调整应用栏的内容和视觉效果。</p><h3 id="主要优点："><a href="#主要优点：" class="headerlink" title="主要优点："></a>主要优点：</h3><ul><li><strong>动态折叠与展开</strong>：通过设置滚动标志，<code>CollapsingToolbarLayout</code> 能够在用户滚动时提供丰富的视觉反馈。</li><li><strong>支持自定义背景与标题</strong>：可以动态设置背景图片、标题文字的显示效果。</li><li><strong>与滚动视图协同工作</strong>：可以与 <code>RecyclerView</code>、<code>NestedScrollView</code> 等控件结合，实现流畅的滚动和折叠交互。</li></ul><p><code>CollapsingToolbarLayout</code> 是构建现代化、交互性强的 Android 应用中不可或缺的布局组件，它提供了极大的灵活性和可定制性，适合各种折叠式应用栏场景。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AppbarLayout用法详解</title>
      <link href="/2025/04/04/AppbarLayout%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/AppbarLayout%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>AppBarLayout</code> 是 Android Material Components 库中的一个重要视图组件，作为布局的一部分，通常用于实现可滚动的应用栏。它通过与其他布局控件（如 <code>Toolbar</code>、<code>CollapsingToolbarLayout</code>）结合使用，支持一些常见的交互效果，比如折叠和展开的动画效果。<code>AppBarLayout</code> 主要用来创建符合 Material Design 风格的顶部区域，它为复杂的应用栏交互提供了强大的支持，尤其是在多层滚动视图中。</p><h3 id="主要特性："><a href="#主要特性：" class="headerlink" title="主要特性："></a>主要特性：</h3><ul><li><strong>滚动行为</strong>：支持和子视图（如 <code>RecyclerView</code>）的滚动交互，可以折叠和展开应用栏。</li><li><strong>折叠与展开</strong>：通过 <code>CollapsingToolbarLayout</code> 支持应用栏的折叠与展开动画。</li><li><strong>Material Design 支持</strong>：内置 Material Design 风格，符合现代 Android 应用的设计规范。</li></ul><hr><h2 id="二、依赖与导入"><a href="#二、依赖与导入" class="headerlink" title="二、依赖与导入"></a>二、依赖与导入</h2><p><code>AppBarLayout</code> 是 Android Material Components 库的一部分，在使用时需要确保已经在项目的 <code>build.gradle</code> 文件中添加了 Material Components 的依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.google.android.material:material:1.4.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、AppBarLayout-基本用法"><a href="#三、AppBarLayout-基本用法" class="headerlink" title="三、AppBarLayout 基本用法"></a>三、AppBarLayout 基本用法</h2><p><code>AppBarLayout</code> 通常与 <code>Toolbar</code>、<code>CollapsingToolbarLayout</code> 等组件一起使用。通过这些组件，你可以实现应用栏的动态折叠效果和其他交互动画。</p><h3 id="1-在布局文件中使用-AppBarLayout"><a href="#1-在布局文件中使用-AppBarLayout" class="headerlink" title="1. 在布局文件中使用 AppBarLayout"></a>1. 在布局文件中使用 <code>AppBarLayout</code></h3><p><code>AppBarLayout</code> 是一个容器布局，可以包含 <code>Toolbar</code> 和其他视图控件。以下是一个简单的例子，展示如何在 XML 布局文件中使用 <code>AppBarLayout</code> 来实现顶部可折叠的应用栏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.appbar.AppBarLayout</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:layout_scrollFlags=&quot;scroll|enterAlways&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- CollapsingToolbarLayout 用于实现折叠和展开效果 --&gt;</span><br><span class="line">    &lt;com.google.android.material.appbar.CollapsingToolbarLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Toolbar 作为应用栏的工具栏 --&gt;</span><br><span class="line">        &lt;androidx.appcompat.widget.Toolbar</span><br><span class="line">            android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">            android:title=&quot;AppBarLayout Example&quot;</span><br><span class="line">            android:theme=&quot;@style/ThemeOverlay.MaterialComponents.ActionBar&quot;/&gt;</span><br><span class="line">    &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/com.google.android.material.appbar.AppBarLayout&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>AppBarLayout</code> 是应用栏的父容器，包含 <code>CollapsingToolbarLayout</code> 和 <code>Toolbar</code>。</li><li><code>CollapsingToolbarLayout</code> 提供折叠效果，允许 <code>Toolbar</code> 在滚动时折叠或展开。</li><li><code>layout_scrollFlags</code> 用于指定 <code>AppBarLayout</code> 的滚动行为，如“scroll”、“enterAlways”、“exitUntilCollapsed”等。</li></ul><h3 id="2-配置滚动行为"><a href="#2-配置滚动行为" class="headerlink" title="2. 配置滚动行为"></a>2. 配置滚动行为</h3><p><code>AppBarLayout</code> 支持与子视图（如 <code>RecyclerView</code>）的滚动行为交互，通常通过 <code>layout_behavior</code> 属性来指定子视图的滚动效果。例如，可以使 <code>RecyclerView</code> 在滚动时与 <code>AppBarLayout</code> 协同滚动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">    android:id=&quot;@+id/recycler_view&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt;</span><br></pre></td></tr></table></figure><p>通过设置 <code>layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>，<code>RecyclerView</code> 会根据 <code>AppBarLayout</code> 的滚动来控制自身的显示和滚动。</p><hr><h2 id="四、AppBarLayout-特性"><a href="#四、AppBarLayout-特性" class="headerlink" title="四、AppBarLayout 特性"></a>四、AppBarLayout 特性</h2><h3 id="1-layout-scrollFlags-属性"><a href="#1-layout-scrollFlags-属性" class="headerlink" title="1. layout_scrollFlags 属性"></a>1. <code>layout_scrollFlags</code> 属性</h3><p><code>layout_scrollFlags</code> 属性用于控制 <code>AppBarLayout</code> 中各个子视图的滚动行为。常见的滚动标志有：</p><ul><li><strong>scroll</strong>：表示该视图可以随着滚动视图的滚动而滚动。</li><li><strong>enterAlways</strong>：当滚动发生时，该视图将始终出现在屏幕上。</li><li><strong>exitUntilCollapsed</strong>：当滚动时，该视图将被折叠，直到完全消失。</li></ul><p>通过组合这些标志，可以创建非常灵活的应用栏行为。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_scrollFlags=&quot;scroll|enterAlways&quot;</span><br></pre></td></tr></table></figure><p>表示该视图在滚动时可以显示，并在需要时返回。</p><h3 id="2-AppBarLayout-与-CollapsingToolbarLayout-配合"><a href="#2-AppBarLayout-与-CollapsingToolbarLayout-配合" class="headerlink" title="2. AppBarLayout 与 CollapsingToolbarLayout 配合"></a>2. <code>AppBarLayout</code> 与 <code>CollapsingToolbarLayout</code> 配合</h3><p><code>CollapsingToolbarLayout</code> 是 <code>AppBarLayout</code> 的常用子布局，用于实现更复杂的折叠效果。例如，使用 <code>CollapsingToolbarLayout</code> 可以实现动态缩小的 <code>Toolbar</code> 和背景图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.appbar.AppBarLayout</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.google.android.material.appbar.CollapsingToolbarLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</span><br><span class="line">        app:contentScrim=&quot;?attr/colorPrimary&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;androidx.appcompat.widget.Toolbar</span><br><span class="line">            android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">            android:title=&quot;Collapsing Toolbar&quot;</span><br><span class="line">            android:theme=&quot;@style/ThemeOverlay.MaterialComponents.ActionBar&quot;/&gt;</span><br><span class="line">    &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt;</span><br><span class="line">&lt;/com.google.android.material.appbar.AppBarLayout&gt;</span><br></pre></td></tr></table></figure><ul><li><code>app:contentScrim</code> 设置折叠时的背景颜色。</li><li><code>app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</code> 使得 <code>Toolbar</code> 可以随着滚动而折叠，直到完全消失。</li></ul><h3 id="3-setExpanded-与-setCollapsed-方法"><a href="#3-setExpanded-与-setCollapsed-方法" class="headerlink" title="3. setExpanded() 与 setCollapsed() 方法"></a>3. <code>setExpanded()</code> 与 <code>setCollapsed()</code> 方法</h3><p><code>AppBarLayout</code> 还提供了 <code>setExpanded()</code> 和 <code>setCollapsed()</code> 方法，可以动态控制应用栏的展开或折叠状态。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val appBarLayout: AppBarLayout = findViewById(R.id.app_bar_layout)</span><br><span class="line">appBarLayout.setExpanded(true)  // 展开应用栏</span><br><span class="line">appBarLayout.setExpanded(false) // 折叠应用栏</span><br></pre></td></tr></table></figure><p>这些方法可以结合动画效果来动态控制应用栏的展开或折叠状态。</p><h3 id="4-动态监听滚动状态"><a href="#4-动态监听滚动状态" class="headerlink" title="4. 动态监听滚动状态"></a>4. 动态监听滚动状态</h3><p>你可以通过 <code>AppBarLayout.OnOffsetChangedListener</code> 来监听 <code>AppBarLayout</code> 的滚动偏移量，从而执行特定操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val appBarLayout = findViewById&lt;AppBarLayout&gt;(R.id.app_bar_layout)</span><br><span class="line">appBarLayout.addOnOffsetChangedListener(object : AppBarLayout.OnOffsetChangedListener &#123;</span><br><span class="line">    override fun onOffsetChanged(appBarLayout: AppBarLayout, verticalOffset: Int) &#123;</span><br><span class="line">        if (verticalOffset == 0) &#123;</span><br><span class="line">            // 展开</span><br><span class="line">        &#125; else if (Math.abs(verticalOffset) &gt;= appBarLayout.totalScrollRange) &#123;</span><br><span class="line">            // 折叠</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过监听 <code>verticalOffset</code>，可以在应用栏完全展开或完全折叠时执行相应的操作。</p><hr><h2 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h2><p><code>AppBarLayout</code> 的主要作用是处理可滚动应用栏的交互行为，特别适用于以下场景：</p><ol><li><strong>社交应用</strong>：用于展示用户头像、个人资料或状态，支持滚动时的折叠和展开效果。</li><li><strong>新闻或内容浏览应用</strong>：用于展示页面标题、背景图等内容，支持和滚动视图的协同滚动。</li><li><strong>电子商务应用</strong>：用于展示商品信息或产品展示，提供更加吸引眼球的顶部应用栏。</li></ol><hr><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p><code>AppBarLayout</code> 是 Android Material Design 中一个重要的布局组件，它提供了应用栏的高度自定义、折叠和展开动画、以及与滚动视图的交互。结合 <code>CollapsingToolbarLayout</code> 和其他控件，开发者可以实现复杂且富有动感的顶部区域，提升用户体验。</p><h3 id="主要优点："><a href="#主要优点：" class="headerlink" title="主要优点："></a>主要优点：</h3><ul><li>提供灵活的滚动行为，支持与其他视图的协同滚动。</li><li>内置支持 Material Design 风格，符合现代 Android 应用设计规范。</li><li>支持与 <code>CollapsingToolbarLayout</code> 配合使用，实现更加丰富的交互效果。</li></ul><p><code>AppBarLayout</code> 是构建现代化、互动性强的 Android 应用中不可或缺的布局组件，它帮助开发者轻松实现折叠式应用栏以及其他复杂的动画效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaterialCardView用法详解</title>
      <link href="/2025/04/04/MateriaCardView%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/MateriaCardView%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>MaterialCardView</code> 是 Android Material Components 库中的一个视图控件，它基于 <code>CardView</code> 进行了增强，加入了更多 Material Design 风格的特性，使其更适合现代 Android 应用的设计要求。<code>MaterialCardView</code> 提供了简洁的卡片式界面，能够方便地实现圆角、阴影、背景等效果，从而帮助开发者构建更加美观、易于交互的 UI 元素。</p><p>与 <code>CardView</code> 相比，<code>MaterialCardView</code> 支持更多的功能，例如：</p><ul><li><strong>形状</strong>：支持更复杂的形状，除了圆角外，还支持自定义的形状和阴影效果。</li><li><strong>背景</strong>：可以设置与背景相关的更多属性。</li><li><strong>Ripple 效果</strong>：内置 Material Design 风格的水波纹点击效果。</li></ul><p><code>MaterialCardView</code> 适合用于展示内容卡片、列表项、照片、产品展示等，尤其是需要圆角和阴影效果的场景。</p><hr><h2 id="二、依赖与导入"><a href="#二、依赖与导入" class="headerlink" title="二、依赖与导入"></a>二、依赖与导入</h2><p>在使用 <code>MaterialCardView</code> 之前，需要确保你的项目已经加入了 Material Components 库的依赖。可以在项目的 <code>build.gradle</code> 文件中添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.google.android.material:material:1.4.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h2><h3 id="1-使用-XML-布局"><a href="#1-使用-XML-布局" class="headerlink" title="1. 使用 XML 布局"></a>1. 使用 XML 布局</h3><p><code>MaterialCardView</code> 的基本使用方法类似于 <code>CardView</code>，只需在布局文件中添加该控件。以下是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.card.MaterialCardView</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:cardCornerRadius=&quot;8dp&quot;</span><br><span class="line">    app:cardElevation=&quot;4dp&quot;</span><br><span class="line">    app:strokeColor=&quot;@color/colorAccent&quot;</span><br><span class="line">    app:strokeWidth=&quot;2dp&quot;</span><br><span class="line">    android:padding=&quot;16dp&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 卡片内容 --&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;This is a MaterialCardView&quot;</span><br><span class="line">        android:textSize=&quot;16sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/black&quot;/&gt;</span><br><span class="line">&lt;/com.google.android.material.card.MaterialCardView&gt;</span><br></pre></td></tr></table></figure><p>在上面的 XML 布局中：</p><ul><li><code>app:cardCornerRadius</code> 用于设置卡片的圆角半径。</li><li><code>app:cardElevation</code> 用于设置卡片的阴影深度，影响卡片的浮动效果。</li><li><code>app:strokeColor</code> 用于设置卡片的边框颜色。</li><li><code>app:strokeWidth</code> 用于设置卡片边框的宽度。</li><li><code>android:padding</code> 用于设置卡片内边距。</li></ul><h3 id="2-在代码中使用"><a href="#2-在代码中使用" class="headerlink" title="2. 在代码中使用"></a>2. 在代码中使用</h3><p>你也可以在 Java 或 Kotlin 代码中动态创建和设置 <code>MaterialCardView</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">val materialCardView = MaterialCardView(this).apply &#123;</span><br><span class="line">    layoutParams = ViewGroup.LayoutParams(</span><br><span class="line">        ViewGroup.LayoutParams.MATCH_PARENT, </span><br><span class="line">        ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">    )</span><br><span class="line">    radius = 8f</span><br><span class="line">    elevation = 4f</span><br><span class="line">    setCardBackgroundColor(ContextCompat.getColor(context, R.color.white))</span><br><span class="line">    setContentPadding(16, 16, 16, 16)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val textView = TextView(this).apply &#123;</span><br><span class="line">    text = &quot;This is a MaterialCardView&quot;</span><br><span class="line">    textSize = 16f</span><br><span class="line">    setTextColor(Color.BLACK)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">materialCardView.addView(textView)</span><br><span class="line">container.addView(materialCardView)</span><br></pre></td></tr></table></figure><p>这里，我们通过代码创建了一个 <code>MaterialCardView</code>，并为它设置了圆角、阴影、内边距等属性。</p><hr><h2 id="四、MaterialCardView-特性"><a href="#四、MaterialCardView-特性" class="headerlink" title="四、MaterialCardView 特性"></a>四、MaterialCardView 特性</h2><h3 id="1-圆角和阴影"><a href="#1-圆角和阴影" class="headerlink" title="1. 圆角和阴影"></a>1. 圆角和阴影</h3><p><code>MaterialCardView</code> 通过 <code>app:cardCornerRadius</code> 和 <code>app:cardElevation</code> 属性提供了圆角和阴影效果，适用于大多数需要卡片风格的 UI 元素。例如，带有圆角和阴影的卡片可以用于商品列表、用户信息展示等场景。</p><ul><li><strong>圆角</strong>：通过 <code>cardCornerRadius</code> 设置圆角半径，使得卡片的角落呈现圆形效果。</li><li><strong>阴影</strong>：通过 <code>cardElevation</code> 设置阴影的深度，影响卡片与背景的分离感，提升视觉效果。</li></ul><h3 id="2-背景与边框"><a href="#2-背景与边框" class="headerlink" title="2. 背景与边框"></a>2. 背景与边框</h3><p><code>MaterialCardView</code> 支持设置背景色和边框样式，可以使卡片看起来更具层次感。你可以通过 <code>setCardBackgroundColor()</code> 方法设置卡片的背景颜色，或者通过 <code>app:strokeColor</code> 和 <code>app:strokeWidth</code> 设置边框的颜色和宽度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.card.MaterialCardView</span><br><span class="line">    app:strokeColor=&quot;@color/colorPrimary&quot;</span><br><span class="line">    app:strokeWidth=&quot;2dp&quot;</span><br><span class="line">    app:cardBackgroundColor=&quot;@android:color/white&quot;</span><br><span class="line">    app:cardCornerRadius=&quot;12dp&quot;</span><br><span class="line">    app:cardElevation=&quot;6dp&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="3-水波纹效果（Ripple）"><a href="#3-水波纹效果（Ripple）" class="headerlink" title="3. 水波纹效果（Ripple）"></a>3. 水波纹效果（Ripple）</h3><p><code>MaterialCardView</code> 内置了 Material Design 的水波纹效果（Ripple），即点击时卡片会显示水波纹扩展的动画效果。这种效果增强了用户交互感，使得应用看起来更加现代化。</p><p><code>MaterialCardView</code> 的水波纹效果默认启用，你可以通过 <code>android:clickable</code> 属性控制点击事件的响应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.card.MaterialCardView</span><br><span class="line">    android:clickable=&quot;true&quot;</span><br><span class="line">    android:focusable=&quot;true&quot;</span><br><span class="line">    app:rippleColor=&quot;@color/ripple_color&quot;</span><br><span class="line">    ... /&gt;</span><br></pre></td></tr></table></figure><p>你可以使用 <code>app:rippleColor</code> 属性自定义水波纹的颜色。</p><h3 id="4-动态启用和禁用"><a href="#4-动态启用和禁用" class="headerlink" title="4. 动态启用和禁用"></a>4. 动态启用和禁用</h3><p><code>MaterialCardView</code> 的启用与禁用状态与其他视图组件类似，可以使用 <code>setEnabled()</code> 方法控制。禁用时，卡片的点击和交互效果都会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">materialCardView.isEnabled = false</span><br></pre></td></tr></table></figure><h3 id="5-设置点击监听器"><a href="#5-设置点击监听器" class="headerlink" title="5. 设置点击监听器"></a>5. 设置点击监听器</h3><p>你可以为 <code>MaterialCardView</code> 设置点击监听器，当卡片被点击时触发某些操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">materialCardView.setOnClickListener &#123;</span><br><span class="line">    Toast.makeText(this, &quot;Card Clicked&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h2><p><code>MaterialCardView</code> 广泛应用于需要视觉层次和交互效果的场景。例如：</p><ol><li><strong>商品卡片</strong>：用于展示商品信息的卡片，可以结合图片、价格、商品名称等内容。</li><li><strong>用户卡片</strong>：展示用户头像、昵称等信息，支持点击进入详细页面。</li><li><strong>信息展示</strong>：用于展示某些提示信息或操作按钮，卡片式设计能够使界面更加清晰。</li><li><strong>列表项</strong>：在列表中使用 <code>MaterialCardView</code> 来展示每一项，提供交互性。</li></ol><hr><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p><code>MaterialCardView</code> 是 Android Material Design 库中的重要组件，它为开发者提供了更为丰富和现代化的卡片式界面设计工具。通过支持圆角、阴影、边框、背景以及水波纹效果，<code>MaterialCardView</code> 使得 UI 元素的表现更加生动与灵活。</p><ul><li><strong>优势</strong>：<ul><li>丰富的 Material Design 特性，提升界面视觉效果。</li><li>自带水波纹点击效果，增强用户体验。</li><li>可以非常方便地与其他视图组件（如 <code>RecyclerView</code>、<code>TextView</code> 等）结合使用，构建更加复杂的 UI。</li></ul></li><li><strong>使用场景</strong>：<ul><li>商品卡片、用户卡片、列表项等多种场景。</li><li>提供简洁、现代、交互性强的界面设计。</li></ul></li></ul><p><code>MaterialCardView</code> 是现代 Android 应用设计中不可或缺的控件之一，通过它，开发者能够创建出更加美观且易于交互的用户界面。如果你正在构建 Material Design 风格的应用，不妨尝试使用 <code>MaterialCardView</code>，它将帮助你打造更加出色的 UI。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CoordinatorLayout用法详解</title>
      <link href="/2025/04/04/CoordinatorLayout%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/CoordinatorLayout%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>CoordinatorLayout</code> 是 Android 支持库（Support Library）提供的一个高级布局容器，它继承自 <code>FrameLayout</code>，是一个强大的布局容器，能够协调并支持更复杂的交互设计，尤其是在 Material Design 中。它提供了一种灵活的方式来协作处理子视图之间的行为，如与 <code>AppBarLayout</code>、<code>FloatingActionButton</code>、<code>Snackbar</code> 等组件的交互效果。</p><p><code>CoordinatorLayout</code> 主要目的是提供一种“协调”各个视图行为的机制，可以通过自定义或现成的行为（<code>Behavior</code>）来控制子视图的滑动、动画和响应。</p><hr><h2 id="二、CoordinatorLayout-特性"><a href="#二、CoordinatorLayout-特性" class="headerlink" title="二、CoordinatorLayout 特性"></a>二、CoordinatorLayout 特性</h2><p><code>CoordinatorLayout</code> 提供了以下几个重要特性：</p><ol><li><strong>响应滚动和手势</strong>：<code>CoordinatorLayout</code> 能够捕捉子视图的滚动和手势事件，并根据需要调整布局位置。</li><li><strong>子视图行为协调</strong>：可以让不同的视图（如 <code>AppBarLayout</code> 和 <code>FloatingActionButton</code>）之间协调运动，确保界面一致性和流畅的过渡效果。</li><li><strong>支持自定义行为</strong>：通过自定义 <code>Behavior</code> 类，可以非常灵活地控制视图之间的交互方式。</li><li><strong>Material Design 支持</strong>：协调 <code>AppBarLayout</code>、<code>Toolbar</code>、<code>FloatingActionButton</code> 等 Material Design 组件的行为。</li></ol><hr><h2 id="三、CoordinatorLayout-的基本使用"><a href="#三、CoordinatorLayout-的基本使用" class="headerlink" title="三、CoordinatorLayout 的基本使用"></a>三、CoordinatorLayout 的基本使用</h2><h3 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1. 依赖"></a>1. 依赖</h3><p>首先，需要在 <code>build.gradle</code> 文件中加入依赖（如果还没有加入的话）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.google.android.material:material:1.4.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-CoordinatorLayout-结构"><a href="#2-CoordinatorLayout-结构" class="headerlink" title="2. CoordinatorLayout 结构"></a>2. CoordinatorLayout 结构</h3><p><code>CoordinatorLayout</code> 是一个容器布局，所有其他子视图都可以放置在其内。通常，<code>CoordinatorLayout</code> 中的子视图会涉及到一些协调行为，例如与 <code>AppBarLayout</code> 一起滚动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.coordinatorlayout.widget.CoordinatorLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- AppBarLayout 用于实现可滚动的 Toolbar 和其他组件 --&gt;</span><br><span class="line">    &lt;com.google.android.material.appbar.AppBarLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;com.google.android.material.appbar.CollapsingToolbarLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;androidx.appcompat.widget.Toolbar</span><br><span class="line">                android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:title=&quot;CoordinatorLayout Example&quot;</span><br><span class="line">                android:theme=&quot;@style/ThemeOverlay.MaterialComponents.ActionBar&quot;/&gt;</span><br><span class="line">        &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt;</span><br><span class="line">    &lt;/com.google.android.material.appbar.AppBarLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 主体内容区域 --&gt;</span><br><span class="line">    &lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">        android:id=&quot;@+id/recycler_view&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 悬浮的 FloatingActionButton --&gt;</span><br><span class="line">    &lt;com.google.android.material.floatingactionbutton.FloatingActionButton</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;end|bottom&quot;</span><br><span class="line">        android:src=&quot;@drawable/ic_add&quot;</span><br><span class="line">        app:layout_behavior=&quot;com.google.android.material.behavior.HideBottomViewOnScrollBehavior&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure><h3 id="3-关键组件"><a href="#3-关键组件" class="headerlink" title="3. 关键组件"></a>3. 关键组件</h3><ul><li><strong>AppBarLayout</strong>：用于实现可滚动的应用栏，通常与 <code>Toolbar</code> 和 <code>CollapsingToolbarLayout</code> 一起使用，以实现折叠效果。</li><li><strong>FloatingActionButton</strong>：通常会放置在屏幕的右下角，<code>CoordinatorLayout</code> 可以协调其在滚动视图中的行为。</li><li><strong>RecyclerView</strong>：可以与 <code>AppBarLayout</code> 协作，配合 <code>layout_behavior</code> 属性实现滚动监听和交互。</li></ul><hr><h2 id="四、CoordinatorLayout-的关键属性和方法"><a href="#四、CoordinatorLayout-的关键属性和方法" class="headerlink" title="四、CoordinatorLayout 的关键属性和方法"></a>四、CoordinatorLayout 的关键属性和方法</h2><h3 id="1-app-layout-behavior"><a href="#1-app-layout-behavior" class="headerlink" title="1. app:layout_behavior"></a>1. <code>app:layout_behavior</code></h3><p><code>app:layout_behavior</code> 属性用于指定该视图与 <code>CoordinatorLayout</code> 中其他视图的行为。常见的行为类包括：</p><ul><li><code>com.google.android.material.behavior.HideBottomViewOnScrollBehavior</code>：使底部视图（如 <code>FloatingActionButton</code>）在滚动时隐藏。</li><li><code>com.google.android.material.appbar.AppBarLayout.ScrollingViewBehavior</code>：使 <code>RecyclerView</code> 或其他滚动视图与 <code>AppBarLayout</code> 协同滚动。</li></ul><h3 id="2-setBehavior"><a href="#2-setBehavior" class="headerlink" title="2. setBehavior()"></a>2. <code>setBehavior()</code></h3><p>可以通过 <code>CoordinatorLayout</code> 提供的 <code>setBehavior()</code> 方法为子视图设置行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val coordinatorLayout: CoordinatorLayout = findViewById(R.id.coordinator_layout)</span><br><span class="line">val fab: FloatingActionButton = findViewById(R.id.fab)</span><br><span class="line">val params = fab.layoutParams as CoordinatorLayout.LayoutParams</span><br><span class="line">params.behavior = HideBottomViewOnScrollBehavior()</span><br><span class="line">fab.layoutParams = params</span><br></pre></td></tr></table></figure><h3 id="3-自定义-Behavior"><a href="#3-自定义-Behavior" class="headerlink" title="3. 自定义 Behavior"></a>3. 自定义 Behavior</h3><p>通过继承 <code>CoordinatorLayout.Behavior</code> 类，可以创建自己的视图行为。行为类主要重写以下方法：</p><ul><li><code>onNestedScroll()</code></li><li><code>onInterceptTouchEvent()</code></li><li><code>onLayoutChild()</code></li></ul><p>例如，下面的代码实现了一个 <code>Behavior</code>，它让 <code>FloatingActionButton</code> 在滚动时隐藏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyFloatingActionButtonBehavior(context: Context, attrs: AttributeSet) :</span><br><span class="line">    CoordinatorLayout.Behavior&lt;FloatingActionButton&gt;(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    override fun onNestedScroll(</span><br><span class="line">        coordinatorLayout: CoordinatorLayout,</span><br><span class="line">        child: FloatingActionButton,</span><br><span class="line">        target: View,</span><br><span class="line">        dx: Int,</span><br><span class="line">        dy: Int,</span><br><span class="line">        consumed: IntArray</span><br><span class="line">    ) &#123;</span><br><span class="line">        if (dy &gt; 0) &#123;</span><br><span class="line">            child.hide() // 向下滚动时隐藏 FloatingActionButton</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            child.show() // 向上滚动时显示 FloatingActionButton</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五、CoordinatorLayout-常见用法"><a href="#五、CoordinatorLayout-常见用法" class="headerlink" title="五、CoordinatorLayout 常见用法"></a>五、CoordinatorLayout 常见用法</h2><h3 id="1-与-AppBarLayout-配合使用"><a href="#1-与-AppBarLayout-配合使用" class="headerlink" title="1. 与 AppBarLayout 配合使用"></a>1. 与 <code>AppBarLayout</code> 配合使用</h3><p><code>AppBarLayout</code> 是与 <code>CoordinatorLayout</code> 配合使用的一个关键组件。它能够实现 <code>Toolbar</code> 和其他视图的折叠效果。以下是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.appbar.AppBarLayout</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:layout_scrollFlags=&quot;scroll|enterAlways&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.appcompat.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">        android:title=&quot;CoordinatorLayout Example&quot;</span><br><span class="line">        android:theme=&quot;@style/ThemeOverlay.MaterialComponents.ActionBar&quot;/&gt;</span><br><span class="line">&lt;/com.google.android.material.appbar.AppBarLayout&gt;</span><br></pre></td></tr></table></figure><h3 id="2-与-FloatingActionButton-配合使用"><a href="#2-与-FloatingActionButton-配合使用" class="headerlink" title="2. 与 FloatingActionButton 配合使用"></a>2. 与 <code>FloatingActionButton</code> 配合使用</h3><p><code>FloatingActionButton</code> 可以与 <code>CoordinatorLayout</code> 配合，通过设置行为来实现更丰富的交互。例如，使用 <code>HideBottomViewOnScrollBehavior</code> 来在列表滚动时隐藏 <code>FloatingActionButton</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.floatingactionbutton.FloatingActionButton</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_gravity=&quot;end|bottom&quot;</span><br><span class="line">    android:src=&quot;@drawable/ic_add&quot;</span><br><span class="line">    app:layout_behavior=&quot;com.google.android.material.behavior.HideBottomViewOnScrollBehavior&quot;/&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p><code>CoordinatorLayout</code> 是一个功能强大的布局容器，它能够协调多个视图之间的交互行为，尤其适用于 Material Design 风格的 UI 设计。通过与 <code>AppBarLayout</code>、<code>FloatingActionButton</code> 等组件的结合，开发者能够创建出极具交互感的界面效果。你可以通过内置的 <code>Behavior</code> 类或者自定义行为来实现复杂的布局和动画效果，极大地增强用户体验。</p><h3 id="主要优势："><a href="#主要优势：" class="headerlink" title="主要优势："></a>主要优势：</h3><ul><li>提供了多种与视图交互的行为。</li><li>能够简化复杂的布局协调，尤其是在包含 <code>AppBarLayout</code> 和 <code>FloatingActionButton</code> 等组件时。</li><li>灵活的自定义行为支持，让开发者可以针对应用的需求实现个性化的交互效果。</li></ul><p><code>CoordinatorLayout</code> 是 Android 中非常实用的布局容器，特别适用于构建现代化的用户界面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Snackbar用法详解</title>
      <link href="/2025/04/04/Snackbar%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/Snackbar%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>Snackbar</code> 是 Android 提供的一种简洁、轻量级的提示框，用于在屏幕底部展示短暂的信息提示。它的设计初衷是为了提供一种比 <code>Toast</code> 更具互动性和灵活性的提示方式。与 <code>Toast</code> 的静态提示不同，<code>Snackbar</code> 提供了更多的交互功能，例如：支持撤销操作、自动隐藏和手动关闭。</p><p><code>Snackbar</code> 适用于展示短期通知，尤其是需要用户进行交互（如撤销操作）的场景。</p><hr><h2 id="二、Snackbar-与-Toast-的对比"><a href="#二、Snackbar-与-Toast-的对比" class="headerlink" title="二、Snackbar 与 Toast 的对比"></a>二、Snackbar 与 Toast 的对比</h2><table><thead><tr><th>特性</th><th>Snackbar</th><th>Toast</th></tr></thead><tbody><tr><td><strong>显示位置</strong></td><td>屏幕底部</td><td>屏幕中间或底部</td></tr><tr><td><strong>显示时间</strong></td><td>可定制（一般显示 2-3 秒）</td><td>自动消失（一般 2-3 秒）</td></tr><tr><td><strong>可交互性</strong></td><td>支持按钮操作（如撤销）</td><td>无法交互</td></tr><tr><td><strong>可以设置自定义动作</strong></td><td>可以添加撤销按钮、动作</td><td>只能显示文本</td></tr></tbody></table><p><code>Snackbar</code> 的主要优势在于支持交互操作和自定义动作，比如用户可以点击“撤销”按钮撤回某个操作，而 <code>Toast</code> 仅是展示提示信息并自动消失。</p><hr><h2 id="三、Snackbar-基本使用"><a href="#三、Snackbar-基本使用" class="headerlink" title="三、Snackbar 基本使用"></a>三、Snackbar 基本使用</h2><h3 id="1-导入必要的依赖"><a href="#1-导入必要的依赖" class="headerlink" title="1. 导入必要的依赖"></a>1. 导入必要的依赖</h3><p>在使用 <code>Snackbar</code> 之前，首先需要确保你的项目已经包含了 Material Components 库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradle复制编辑dependencies &#123;</span><br><span class="line">    implementation &#x27;com.google.android.material:material:1.4.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-显示简单的-Snackbar"><a href="#2-显示简单的-Snackbar" class="headerlink" title="2. 显示简单的 Snackbar"></a>2. 显示简单的 Snackbar</h3><p>最简单的 Snackbar 只需要传入要显示的文本，它会自动显示在屏幕底部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val rootView: View = findViewById(R.id.root_view)</span><br><span class="line">Snackbar.make(rootView, &quot;操作成功&quot;, Snackbar.LENGTH_SHORT).show()</span><br></pre></td></tr></table></figure><ul><li><strong>参数解释</strong>：<ul><li><code>rootView</code>：<code>Snackbar</code> 将依附在这个视图上，通常选择根视图（<code>rootView</code>）作为容器。</li><li><code>&quot;操作成功&quot;</code>：要展示的文本。</li><li><code>Snackbar.LENGTH_SHORT</code>：显示的时长。也可以选择 <code>LENGTH_LONG</code> 或 <code>LENGTH_INDEFINITE</code>（无限显示，直到用户主动消失）。</li></ul></li></ul><hr><h2 id="四、Snackbar-进阶使用"><a href="#四、Snackbar-进阶使用" class="headerlink" title="四、Snackbar 进阶使用"></a>四、Snackbar 进阶使用</h2><h3 id="1-添加操作按钮（交互性）"><a href="#1-添加操作按钮（交互性）" class="headerlink" title="1. 添加操作按钮（交互性）"></a>1. 添加操作按钮（交互性）</h3><p>可以为 <code>Snackbar</code> 添加一个操作按钮，让用户能够执行一些动作，例如撤销删除操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val rootView: View = findViewById(R.id.root_view)</span><br><span class="line">Snackbar.make(rootView, &quot;操作成功&quot;, Snackbar.LENGTH_LONG)</span><br><span class="line">    .setAction(&quot;撤销&quot;) &#123;</span><br><span class="line">        // 执行撤销操作</span><br><span class="line">        Toast.makeText(this, &quot;撤销操作&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">    .show()</span><br></pre></td></tr></table></figure><ul><li><code>setAction()</code>：添加一个按钮及其点击事件。在这里，我们添加了“撤销”按钮，点击时会显示一个提示。</li><li><code>setActionTextColor()</code>：可以用来设置按钮文本的颜色。</li></ul><hr><h3 id="2-修改-Snackbar-样式"><a href="#2-修改-Snackbar-样式" class="headerlink" title="2. 修改 Snackbar 样式"></a>2. 修改 Snackbar 样式</h3><p><code>Snackbar</code> 还支持自定义样式，例如背景色、文本颜色等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val rootView: View = findViewById(R.id.root_view)</span><br><span class="line">val snackbar = Snackbar.make(rootView, &quot;操作成功&quot;, Snackbar.LENGTH_LONG)</span><br><span class="line"></span><br><span class="line">val snackbarView = snackbar.view</span><br><span class="line">snackbarView.setBackgroundColor(ContextCompat.getColor(this, R.color.snackbar_background))</span><br><span class="line">val textView = snackbarView.findViewById&lt;TextView&gt;(com.google.android.material.R.id.snackbar_text)</span><br><span class="line">textView.setTextColor(Color.WHITE)</span><br><span class="line"></span><br><span class="line">snackbar.show()</span><br></pre></td></tr></table></figure><ul><li>通过 <code>snackbar.view</code> 获取到 <code>Snackbar</code> 的根视图，进一步定制 <code>Snackbar</code> 的样式。</li><li><code>setBackgroundColor()</code> 可以修改 <code>Snackbar</code> 背景色。</li><li><code>findViewById&lt;TextView&gt;(com.google.android.material.R.id.snackbar_text)</code> 获取到文本视图，修改文本颜色。</li></ul><hr><h3 id="3-设置自定义动画"><a href="#3-设置自定义动画" class="headerlink" title="3. 设置自定义动画"></a>3. 设置自定义动画</h3><p>Snackbar 的出现与消失是有默认动画的，你也可以自定义动画效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val snackbar = Snackbar.make(rootView, &quot;操作成功&quot;, Snackbar.LENGTH_LONG)</span><br><span class="line">snackbar.view.animation = AnimationUtils.loadAnimation(this, R.anim.snackbar_animation)</span><br><span class="line">snackbar.show()</span><br></pre></td></tr></table></figure><ul><li>通过 <code>snackbar.view.animation</code> 设置自定义动画，可以配合自己的动画资源文件进行定制。</li></ul><hr><h2 id="五、Snackbar-的生命周期"><a href="#五、Snackbar-的生命周期" class="headerlink" title="五、Snackbar 的生命周期"></a>五、Snackbar 的生命周期</h2><p><code>Snackbar</code> 的生命周期由三部分组成：显示、消失与撤销。</p><ol><li><strong>显示</strong>：<code>Snackbar</code> 会在短时间内显示在屏幕底部。</li><li><strong>自动消失</strong>：根据传入的显示时间（<code>LENGTH_SHORT</code>、<code>LENGTH_LONG</code> 等），<code>Snackbar</code> 会自动消失。</li><li><strong>手动消失</strong>：如果你需要手动关闭 <code>Snackbar</code>，可以使用 <code>dismiss()</code> 方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snackbar.dismiss()</span><br></pre></td></tr></table></figure><ol><li><strong>撤销操作</strong>：通过 <code>setAction()</code> 方法，可以为 <code>Snackbar</code> 添加交互操作，允许用户点击撤销等按钮。</li></ol><hr><h2 id="六、Snackbar-的注意事项"><a href="#六、Snackbar-的注意事项" class="headerlink" title="六、Snackbar 的注意事项"></a>六、Snackbar 的注意事项</h2><ol><li><strong>嵌套使用</strong>：在一个 <code>Activity</code> 或 <code>Fragment</code> 中，<code>Snackbar</code> 不应嵌套多个使用。如果需要显示多个提示信息，建议先调用 <code>dismiss()</code> 手动关闭前一个 <code>Snackbar</code>。</li><li><strong>与键盘交互</strong>：<code>Snackbar</code> 会随着键盘的弹出自动调整位置，因此通常不会被键盘遮挡。</li><li><strong>长时间显示</strong>：如果你使用 <code>Snackbar.LENGTH_INDEFINITE</code> 长时间显示 <code>Snackbar</code>，记得调用 <code>dismiss()</code> 关闭 <code>Snackbar</code>，以免一直显示在屏幕上。</li><li><strong>适应不同屏幕</strong>：由于 <code>Snackbar</code> 是一个浮动视图，它不会占用布局中的空间，因此对于小屏设备，建议不要让 <code>Snackbar</code> 显示过长时间，避免遮挡重要内容。</li></ol><hr><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><code>Snackbar</code> 是一种非常适合在 Android 中展示短暂提示信息的控件，特别适用于需要用户交互（如撤销）的场景。通过简单的 API，开发者可以实现丰富的提示功能，改善用户体验。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>显示简洁</li><li>可以进行交互操作（如撤销）</li><li>灵活的自定义样式</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>适用于短期提示，不适合长时间显示</li><li>需要手动管理显示时长和行为</li></ul><hr><p><code>Snackbar</code> 是一个高效的界面提示工具，能够让用户快速理解应用状态，同时保持界面的整洁和简洁。希望本文能够帮助你更好地理解和使用 <code>Snackbar</code>，从而提高用户体验。如果你有任何问题，或者需要更深入的实例演示，欢迎随时向我提问！</p><h1 id="我的例子！"><a href="#我的例子！" class="headerlink" title="我的例子！"></a>我的例子！</h1><p>在我的例子中，是点击一个fab换起Snackbar，其中亮点是强制改变了Snackbar的背景和字体的颜色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">binding.fab.setOnClickListener &#123; view -&gt;</span><br><span class="line">    val snackbar = Snackbar.make(view, &quot;Data deleted&quot;, Snackbar.LENGTH_SHORT)</span><br><span class="line">        .setAction(&quot;Undo&quot;) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;Data restored&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    //获取 Snackbar 的 View 并设置 tintList 强制背景为白色.tiniList超级超级超级级厉害的，能强制修改颜色，</span><br><span class="line">    //可用在button,ImageView,FloatingActionButton,但不能用在popupmenu上，修改popupmenu需要在value中定义style，然后在layout中使用这个style</span><br><span class="line">    val snackbarView = snackbar.view</span><br><span class="line">    snackbarView.backgroundTintList = ColorStateList.valueOf(Color.WHITE)</span><br><span class="line"></span><br><span class="line">    // 设置文字为黑色</span><br><span class="line">    val textView = snackbarView.findViewById&lt;TextView&gt;(com.google.android.material.R.id.snackbar_text)</span><br><span class="line">    textView?.setTextColor(Color.BLACK)</span><br><span class="line"></span><br><span class="line">    // 设置 Action 按钮的颜色（这里示例用黑色，你可以换成其它颜色）</span><br><span class="line">    val actionTextView = snackbarView.findViewById&lt;TextView&gt;(com.google.android.material.R.id.snackbar_action)</span><br><span class="line">    actionTextView?.setTextColor(Color.BLUE)</span><br><span class="line"></span><br><span class="line">    snackbar.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NavigationView详解</title>
      <link href="/2025/04/04/NavigationView%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/NavigationView%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="📌-Android-NavigationView-技术详解（2025-年版）"><a href="#📌-Android-NavigationView-技术详解（2025-年版）" class="headerlink" title="📌 Android NavigationView 技术详解（2025 年版）"></a>📌 Android <code>NavigationView</code> 技术详解（2025 年版）</h1><p>在现代 Android 应用中，良好的导航体验是提升用户满意度的关键。<code>NavigationView</code> 是 Google Material Design 指南推荐的组件之一，常与 <code>DrawerLayout</code> 结合使用，为应用提供<strong>侧滑导航菜单</strong>（Side Navigation Drawer）功能。本文将全面解析 <code>NavigationView</code> 的用法、特性与最佳实践，帮助你构建符合现代设计规范的 Android 应用。</p><hr><h2 id="🔧-什么是-NavigationView？"><a href="#🔧-什么是-NavigationView？" class="headerlink" title="🔧 什么是 NavigationView？"></a>🔧 什么是 <code>NavigationView</code>？</h2><p><code>NavigationView</code> 是 <code>com.google.android.material.navigation.NavigationView</code>，它是 Material Components 提供的 UI 组件，用于构建左侧侧滑菜单，通常嵌套在 <code>DrawerLayout</code> 中。</p><blockquote><p>📌 <code>NavigationView</code> 实际上是一个带有菜单项（Menu）和可选头部视图（Header）的 <code>FrameLayout</code>。</p></blockquote><hr><h2 id="🧱-基本结构"><a href="#🧱-基本结构" class="headerlink" title="🧱 基本结构"></a>🧱 基本结构</h2><p>典型布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.drawerlayout.widget.DrawerLayout</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 主内容 --&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=&quot;@+id/main_content&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 侧滑菜单 --&gt;</span><br><span class="line">    &lt;com.google.android.material.navigation.NavigationView</span><br><span class="line">        android:id=&quot;@+id/navigation_view&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_gravity=&quot;start&quot;</span><br><span class="line">        app:menu=&quot;@menu/drawer_menu&quot;</span><br><span class="line">        app:headerLayout=&quot;@layout/nav_header&quot;/&gt;</span><br><span class="line">&lt;/androidx.drawerlayout.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="📂-菜单与头部视图"><a href="#📂-菜单与头部视图" class="headerlink" title="📂 菜单与头部视图"></a>📂 菜单与头部视图</h2><h3 id="menu-属性"><a href="#menu-属性" class="headerlink" title="menu 属性"></a><code>menu</code> 属性</h3><p>通过 <code>app:menu</code> 指定 XML 菜单资源，菜单项可以设置图标和 ID：</p><p><strong>res&#x2F;menu&#x2F;drawer_menu.xml</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=&quot;@+id/nav_home&quot;</span><br><span class="line">        android:icon=&quot;@drawable/ic_home&quot;</span><br><span class="line">        android:title=&quot;首页&quot;/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=&quot;@+id/nav_settings&quot;</span><br><span class="line">        android:icon=&quot;@drawable/ic_settings&quot;</span><br><span class="line">        android:title=&quot;设置&quot;/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><h3 id="headerLayout-属性"><a href="#headerLayout-属性" class="headerlink" title="headerLayout 属性"></a><code>headerLayout</code> 属性</h3><p>用于定义顶部头像或账号信息：</p><p><strong>res&#x2F;layout&#x2F;nav_header.xml</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:background=&quot;?attr/colorPrimary&quot;</span><br><span class="line">    android:padding=&quot;16dp&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;160dp&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:src=&quot;@drawable/ic_person&quot;</span><br><span class="line">        android:layout_width=&quot;64dp&quot;</span><br><span class="line">        android:layout_height=&quot;64dp&quot;</span><br><span class="line">        android:tint=&quot;@android:color/white&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:text=&quot;欢迎，用户！&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/white&quot;</span><br><span class="line">        android:textSize=&quot;18sp&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="🚀-与-Navigation-Component-集成（推荐）"><a href="#🚀-与-Navigation-Component-集成（推荐）" class="headerlink" title="🚀 与 Navigation Component 集成（推荐）"></a>🚀 与 Navigation Component 集成（推荐）</h2><p><code>NavigationView</code> 能无缝集成 Jetpack 的 Navigation 组件，只需绑定 NavController：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑val navController = findNavController(R.id.nav_host_fragment)</span><br><span class="line">val navigationView = findViewById&lt;NavigationView&gt;(R.id.navigation_view)</span><br><span class="line">navigationView.setupWithNavController(navController)</span><br></pre></td></tr></table></figure><p>这样点击菜单项就会自动导航到目标 Fragment，无需手动处理点击事件。</p><hr><h2 id="🔁-动态操作菜单项"><a href="#🔁-动态操作菜单项" class="headerlink" title="🔁 动态操作菜单项"></a>🔁 动态操作菜单项</h2><p>你也可以通过代码访问或修改菜单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val menu = navigationView.menu</span><br><span class="line">val settingsItem = menu.findItem(R.id.nav_settings)</span><br><span class="line">settingsItem.title = &quot;偏好设置&quot;</span><br></pre></td></tr></table></figure><p>或者添加&#x2F;隐藏菜单项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settingsItem.isVisible = false</span><br></pre></td></tr></table></figure><hr><h2 id="🌙-支持暗黑模式"><a href="#🌙-支持暗黑模式" class="headerlink" title="🌙 支持暗黑模式"></a>🌙 支持暗黑模式</h2><p>由于使用 Material3 样式，<code>NavigationView</code> 会自动适配暗黑主题（Night Mode）。你可以通过切换系统主题或手动设置 <code>AppCompatDelegate.setDefaultNightMode()</code> 测试效果。</p><hr><h2 id="🧠-常见问题与解决方案"><a href="#🧠-常见问题与解决方案" class="headerlink" title="🧠 常见问题与解决方案"></a>🧠 常见问题与解决方案</h2><h3 id="1-抽屉图标不显示？"><a href="#1-抽屉图标不显示？" class="headerlink" title="1. 抽屉图标不显示？"></a>1. 抽屉图标不显示？</h3><p>确保在 <code>AppCompatActivity</code> 中调用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setSupportActionBar(toolbar)</span><br><span class="line">setupActionBarWithNavController(navController, appBarConfiguration)</span><br></pre></td></tr></table></figure><p>并设置 <code>AppBarConfiguration</code> 传入顶级目的地和 DrawerLayout。</p><hr><h3 id="2-NavigationView-内容被状态栏遮挡？"><a href="#2-NavigationView-内容被状态栏遮挡？" class="headerlink" title="2. NavigationView 内容被状态栏遮挡？"></a>2. NavigationView 内容被状态栏遮挡？</h3><p>加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:fitsSystemWindows=&quot;true&quot;</span><br></pre></td></tr></table></figure><p>并在主题中启用透明状态栏样式。</p><hr><h3 id="3-如何高亮当前选中的菜单项？"><a href="#3-如何高亮当前选中的菜单项？" class="headerlink" title="3. 如何高亮当前选中的菜单项？"></a>3. 如何高亮当前选中的菜单项？</h3><p>Jetpack Navigation 会自动处理，只要 <code>menu</code> 中的 <code>id</code> 与导航图 Fragment 的 <code>id</code> 对应即可。</p><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>组件</td><td><code>NavigationView</code> 是侧滑菜单组件</td></tr><tr><td>样式</td><td>支持 Material3 与暗黑模式</td></tr><tr><td>集成</td><td>建议配合 Jetpack Navigation 使用</td></tr><tr><td>扩展性</td><td>可自定义菜单、头部、监听点击事件</td></tr><tr><td>场景</td><td>大多数需要抽屉式导航的 App，如邮箱、社交、工具类应用</td></tr></tbody></table><hr><h2 id="🔚-写在最后"><a href="#🔚-写在最后" class="headerlink" title="🔚 写在最后"></a>🔚 写在最后</h2><p>在当今 Android 开发中，使用 <code>DrawerLayout + NavigationView + NavController</code> 是构建高质量导航界面的黄金组合。掌握 <code>NavigationView</code>，不仅能提升你的 UI 实力，也能为用户带来清晰、高效的导航体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DrawerLayout详解</title>
      <link href="/2025/04/04/DrawerLayout%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/DrawerLayout%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="📘-DrawerLayout-技术文档（2025-年版）"><a href="#📘-DrawerLayout-技术文档（2025-年版）" class="headerlink" title="📘 DrawerLayout 技术文档（2025 年版）"></a>📘 DrawerLayout 技术文档（2025 年版）</h1><hr><h2 id="1-🧭-简介"><a href="#1-🧭-简介" class="headerlink" title="1. 🧭 简介"></a>1. 🧭 简介</h2><p><code>DrawerLayout</code> 是 Android 官方支持的布局容器，用于实现侧边滑出的导航抽屉效果（Navigation Drawer）。广泛应用于包含多个导航项的 App 中，例如邮箱客户端、新闻阅读器、社交类应用等。</p><p><strong>特性：</strong></p><ul><li>支持左侧&#x2F;右侧抽屉（或同时存在）</li><li>支持滑动手势与菜单图标触发</li><li>与 <code>NavigationView</code> 和 Jetpack Navigation 组件良好兼容</li><li>支持 Material Design 风格</li></ul><hr><h2 id="2-🧩-核心概念与组件结构"><a href="#2-🧩-核心概念与组件结构" class="headerlink" title="2. 🧩 核心概念与组件结构"></a>2. 🧩 核心概念与组件结构</h2><p><code>DrawerLayout</code> 是一个 <code>ViewGroup</code> 容器，至少包含两个子布局：</p><ul><li><strong>主内容区域</strong>：通常为主界面，如 <code>FragmentContainerView</code> 或 <code>ConstraintLayout</code></li><li><strong>抽屉内容区域</strong>：通常放置 <code>NavigationView</code>，用于显示导航菜单项</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制编辑DrawerLayout</span><br><span class="line">├── 主界面内容（Main Content）</span><br><span class="line">└── 抽屉内容（Drawer - NavigationView）</span><br></pre></td></tr></table></figure><hr><h2 id="3-🛠️-基础用法"><a href="#3-🛠️-基础用法" class="headerlink" title="3. 🛠️ 基础用法"></a>3. 🛠️ 基础用法</h2><h3 id="3-1-XML-示例"><a href="#3-1-XML-示例" class="headerlink" title="3.1 XML 示例"></a>3.1 XML 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">xml复制编辑&lt;androidx.drawerlayout.widget.DrawerLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/drawer_layout&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 主界面内容 --&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=&quot;@+id/content_frame&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 侧边抽屉菜单 --&gt;</span><br><span class="line">    &lt;com.google.android.material.navigation.NavigationView</span><br><span class="line">        android:id=&quot;@+id/navigation_view&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_gravity=&quot;start&quot;</span><br><span class="line">        app:menu=&quot;@menu/drawer_menu&quot;</span><br><span class="line">        app:headerLayout=&quot;@layout/nav_header&quot; /&gt;</span><br><span class="line">&lt;/androidx.drawerlayout.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-Kotlin-控制打开与关闭"><a href="#3-2-Kotlin-控制打开与关闭" class="headerlink" title="3.2 Kotlin 控制打开与关闭"></a>3.2 Kotlin 控制打开与关闭</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑val drawerLayout = findViewById&lt;DrawerLayout&gt;(R.id.drawer_layout)</span><br><span class="line"></span><br><span class="line">drawerLayout.openDrawer(GravityCompat.START)  // 打开抽屉</span><br><span class="line">drawerLayout.closeDrawer(GravityCompat.START) // 关闭抽屉</span><br></pre></td></tr></table></figure><hr><h2 id="4-🔗-与-NavigationView-搭配使用"><a href="#4-🔗-与-NavigationView-搭配使用" class="headerlink" title="4. 🔗 与 NavigationView 搭配使用"></a>4. 🔗 与 NavigationView 搭配使用</h2><p><code>NavigationView</code> 是 Material Design 提供的控件，用于在抽屉中显示菜单项。</p><h3 id="4-1-menu-drawer-menu-xml"><a href="#4-1-menu-drawer-menu-xml" class="headerlink" title="4.1 menu&#x2F;drawer_menu.xml"></a>4.1 menu&#x2F;drawer_menu.xml</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xml复制编辑&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item android:id=&quot;@+id/nav_home&quot;</span><br><span class="line">          android:title=&quot;首页&quot;</span><br><span class="line">          android:icon=&quot;@drawable/ic_home&quot;/&gt;</span><br><span class="line">    &lt;item android:id=&quot;@+id/nav_settings&quot;</span><br><span class="line">          android:title=&quot;设置&quot;</span><br><span class="line">          android:icon=&quot;@drawable/ic_settings&quot;/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-Kotlin-中监听菜单点击"><a href="#4-2-Kotlin-中监听菜单点击" class="headerlink" title="4.2 Kotlin 中监听菜单点击"></a>4.2 Kotlin 中监听菜单点击</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑navigationView.setNavigationItemSelectedListener &#123; menuItem -&gt;</span><br><span class="line">    when (menuItem.itemId) &#123;</span><br><span class="line">        R.id.nav_home -&gt; &#123;</span><br><span class="line">            // TODO: 导航到首页</span><br><span class="line">        &#125;</span><br><span class="line">        R.id.nav_settings -&gt; &#123;</span><br><span class="line">            // TODO: 导航到设置页</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    drawerLayout.closeDrawer(GravityCompat.START)</span><br><span class="line">    true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-🚀-与-Jetpack-Navigation-集成（推荐方式）"><a href="#5-🚀-与-Jetpack-Navigation-集成（推荐方式）" class="headerlink" title="5. 🚀 与 Jetpack Navigation 集成（推荐方式）"></a>5. 🚀 与 Jetpack Navigation 集成（推荐方式）</h2><p>现代 Android 推荐使用 <strong>Navigation Component</strong> 管理 Fragment 导航。</p><h3 id="5-1-添加-Navigation-依赖"><a href="#5-1-添加-Navigation-依赖" class="headerlink" title="5.1 添加 Navigation 依赖"></a>5.1 添加 Navigation 依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groovy复制编辑implementation &quot;androidx.navigation:navigation-fragment-ktx:2.7.7&quot;</span><br><span class="line">implementation &quot;androidx.navigation:navigation-ui-ktx:2.7.7&quot;</span><br></pre></td></tr></table></figure><h3 id="5-2-使用-NavHostFragment-替换-FrameLayout"><a href="#5-2-使用-NavHostFragment-替换-FrameLayout" class="headerlink" title="5.2 使用 NavHostFragment 替换 FrameLayout"></a>5.2 使用 NavHostFragment 替换 FrameLayout</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xml复制编辑&lt;androidx.fragment.app.FragmentContainerView</span><br><span class="line">    android:id=&quot;@+id/nav_host_fragment&quot;</span><br><span class="line">    android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;</span><br><span class="line">    app:navGraph=&quot;@navigation/nav_graph&quot;</span><br><span class="line">    app:defaultNavHost=&quot;true&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="5-3-Kotlin-中配置-AppBar-和-DrawerLayout"><a href="#5-3-Kotlin-中配置-AppBar-和-DrawerLayout" class="headerlink" title="5.3 Kotlin 中配置 AppBar 和 DrawerLayout"></a>5.3 Kotlin 中配置 AppBar 和 DrawerLayout</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑val navController = findNavController(R.id.nav_host_fragment)</span><br><span class="line">val appBarConfig = AppBarConfiguration(</span><br><span class="line">    setOf(R.id.nav_home, R.id.nav_settings), drawerLayout</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">setupActionBarWithNavController(navController, appBarConfig)</span><br><span class="line">navigationView.setupWithNavController(navController)</span><br></pre></td></tr></table></figure><hr><h2 id="6-🎨-UI-自定义与最佳实践"><a href="#6-🎨-UI-自定义与最佳实践" class="headerlink" title="6. 🎨 UI 自定义与最佳实践"></a>6. 🎨 UI 自定义与最佳实践</h2><h3 id="✅-建议使用-Material-主题"><a href="#✅-建议使用-Material-主题" class="headerlink" title="✅ 建议使用 Material 主题"></a>✅ 建议使用 Material 主题</h3><p>确保你的主题继承自 <code>Theme.Material3.DayNight</code>，以获得最新 UI 支持。</p><h3 id="✅-自定义头部布局"><a href="#✅-自定义头部布局" class="headerlink" title="✅ 自定义头部布局"></a>✅ 自定义头部布局</h3><p>你可以自定义一个布局用于 <code>NavigationView</code> 的 <code>app:headerLayout</code> 属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">app:headerLayout=&quot;@layout/nav_header&quot;</span><br></pre></td></tr></table></figure><h3 id="✅-支持暗色模式"><a href="#✅-支持暗色模式" class="headerlink" title="✅ 支持暗色模式"></a>✅ 支持暗色模式</h3><p>确保资源使用 <code>night</code> 目录支持夜间模式，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pgsql复制编辑res/</span><br><span class="line">├── layout/</span><br><span class="line">│   └── nav_header.xml</span><br><span class="line">├── values-night/</span><br><span class="line">│   └── themes.xml</span><br></pre></td></tr></table></figure><hr><h2 id="7-✋-手势控制与监听抽屉状态"><a href="#7-✋-手势控制与监听抽屉状态" class="headerlink" title="7. ✋ 手势控制与监听抽屉状态"></a>7. ✋ 手势控制与监听抽屉状态</h2><h3 id="7-1-控制是否允许手势打开"><a href="#7-1-控制是否允许手势打开" class="headerlink" title="7.1 控制是否允许手势打开"></a>7.1 控制是否允许手势打开</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kotlin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">drawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED)</span><br></pre></td></tr></table></figure><h3 id="7-2-监听抽屉滑动-打开-关闭事件"><a href="#7-2-监听抽屉滑动-打开-关闭事件" class="headerlink" title="7.2 监听抽屉滑动&#x2F;打开&#x2F;关闭事件"></a>7.2 监听抽屉滑动&#x2F;打开&#x2F;关闭事件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑drawerLayout.addDrawerListener(object : DrawerLayout.DrawerListener &#123;</span><br><span class="line">    override fun onDrawerSlide(drawerView: View, slideOffset: Float) &#123;&#125;</span><br><span class="line">    override fun onDrawerOpened(drawerView: View) &#123;</span><br><span class="line">        Log.d(&quot;Drawer&quot;, &quot;已打开&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onDrawerClosed(drawerView: View) &#123;</span><br><span class="line">        Log.d(&quot;Drawer&quot;, &quot;已关闭&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onDrawerStateChanged(newState: Int) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="8-🧰-常见问题与排查技巧"><a href="#8-🧰-常见问题与排查技巧" class="headerlink" title="8. 🧰 常见问题与排查技巧"></a>8. 🧰 常见问题与排查技巧</h2><table><thead><tr><th>问题</th><th>原因和解决方式</th></tr></thead><tbody><tr><td>抽屉滑不出来</td><td>检查是否设置了错误的 <code>layout_gravity</code>；应为 <code>start</code> 或 <code>left</code></td></tr><tr><td>菜单图标未显示</td><td>使用 <code>app:showAsAction=&quot;always&quot;</code> 或使用 MaterialIcons</td></tr><tr><td>点击菜单项后抽屉不自动关闭</td><td>手动调用 <code>drawerLayout.closeDrawer(GravityCompat.START)</code></td></tr><tr><td>和返回按钮冲突（按返回时不关闭抽屉）</td><td>在 <code>onBackPressedDispatcher</code> 中优先关闭抽屉</td></tr></tbody></table><hr><h2 id="9-✅-总结"><a href="#9-✅-总结" class="headerlink" title="9. ✅ 总结"></a>9. ✅ 总结</h2><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>原生支持</td><td>AndroidX 中的官方组件</td></tr><tr><td>强大灵活</td><td>支持左&#x2F;右抽屉、手势控制、状态监听</td></tr><tr><td>可组合性强</td><td>可与 <code>NavigationView</code> 和 Jetpack Navigation 搭配</td></tr><tr><td>UI 可自定义</td><td>支持头部、暗色模式、动画、图标样式等</td></tr></tbody></table><hr><h3 id="🔚-推荐实践"><a href="#🔚-推荐实践" class="headerlink" title="🔚 推荐实践"></a>🔚 推荐实践</h3><ul><li>使用 <code>Navigation Component</code> 实现导航逻辑，简洁可靠。</li><li>遵循 Material Design 指南，优化用户体验。</li><li>抽屉内菜单不宜过多，推荐不超过 6 项。</li><li>主界面内容建议使用 <code>Fragment</code> 承载，便于后续维护。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TiniList使用详解</title>
      <link href="/2025/04/01/TiniList%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/01/TiniList%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="TintList-使用技术文档"><a href="#TintList-使用技术文档" class="headerlink" title="TintList 使用技术文档"></a>TintList 使用技术文档</h1><p>本文档详细介绍 Android 开发中 <code>TintList</code> 的概念、作用以及使用方法，帮助开发者掌握如何利用 TintList 动态改变控件的颜色。</p><hr><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Android 应用开发中，经常需要对控件的背景、图标等元素进行着色处理，以便实现动态主题、状态变化反馈或与应用整体风格保持一致。<code>ColorStateList</code> 是 Android 中一种描述颜色状态的对象，而 <code>TintList</code> 则通常指控件的背景或图标的“着色列表”，其底层实现就是使用 <code>ColorStateList</code> 对控件进行着色处理。</p><p>例如，许多控件（如 Button、ImageView、FloatingActionButton 等）提供了 <code>setBackgroundTintList()</code>、<code>setImageTintList()</code> 等方法，使得开发者可以轻松地为控件设置不同状态下的颜色。</p><hr><h2 id="2-ColorStateList-基础"><a href="#2-ColorStateList-基础" class="headerlink" title="2. ColorStateList 基础"></a>2. ColorStateList 基础</h2><p>具体可看我的另一篇文章<a href="https://goshenc.github.io/2025/04/01/ColorStateList%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">ColorStateList使用详解 | GoshenC</a></p><h3 id="2-1-什么是-ColorStateList"><a href="#2-1-什么是-ColorStateList" class="headerlink" title="2.1 什么是 ColorStateList"></a>2.1 什么是 ColorStateList</h3><p><code>ColorStateList</code> 是一个表示颜色列表的数据结构，能够根据控件当前的状态（如按下、聚焦、禁用等）返回不同的颜色。<br> 例如，可以定义如下 XML 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- 按下状态 --&gt;</span><br><span class="line">    &lt;item android:state_pressed=&quot;true&quot; android:color=&quot;#FF0000&quot; /&gt;</span><br><span class="line">    &lt;!-- 默认状态 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;#00FF00&quot; /&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure><p>当控件处于按下状态时，其颜色会变为红色，否则为绿色。</p><h3 id="2-2-动态创建-ColorStateList"><a href="#2-2-动态创建-ColorStateList" class="headerlink" title="2.2 动态创建 ColorStateList"></a>2.2 动态创建 ColorStateList</h3><p>除了在 XML 中定义，开发者也可以在代码中动态创建 ColorStateList，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val colors = intArrayOf(Color.RED, Color.GREEN)</span><br><span class="line">val states = arrayOf(</span><br><span class="line">    intArrayOf(android.R.attr.state_pressed), // 按下状态</span><br><span class="line">    intArrayOf()                              // 默认状态</span><br><span class="line">)</span><br><span class="line">val colorStateList = ColorStateList(states, colors)</span><br></pre></td></tr></table></figure><hr><h2 id="3-TintList-的使用"><a href="#3-TintList-的使用" class="headerlink" title="3. TintList 的使用"></a>3. TintList 的使用</h2><p>在大多数场景中，“tintList” 通常指控件的 tint 属性，即背景或图标的着色列表。以下以背景 TintList 为例说明其使用方法。</p><h3 id="3-1-控件背景着色"><a href="#3-1-控件背景着色" class="headerlink" title="3.1 控件背景着色"></a>3.1 控件背景着色</h3><p>许多控件都支持背景 tint 设置，这样可以将控件的背景颜色通过 ColorStateList 进行动态控制。例如，设置 FloatingActionButton 的背景 tint：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 引入必要的包</span><br><span class="line">import android.content.res.ColorStateList</span><br><span class="line">import android.graphics.Color</span><br><span class="line">import com.google.android.material.floatingactionbutton.FloatingActionButton</span><br><span class="line"></span><br><span class="line">// 假设 fab 为 FloatingActionButton 实例</span><br><span class="line">fab.backgroundTintList = ColorStateList.valueOf(Color.WHITE)</span><br></pre></td></tr></table></figure><p>上例中，<code>ColorStateList.valueOf(Color.WHITE)</code> 创建了一个只有白色的颜色状态列表，强制将控件背景显示为白色。</p><h3 id="3-2-图标着色"><a href="#3-2-图标着色" class="headerlink" title="3.2 图标着色"></a>3.2 图标着色</h3><p>类似地，ImageView 和其他支持 tint 的控件也可以使用 <code>setImageTintList()</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 假设 imageView 为 ImageView 实例</span><br><span class="line">imageView.imageTintList = ColorStateList.valueOf(Color.BLUE)</span><br></pre></td></tr></table></figure><p>这样，ImageView 中的图片将会应用蓝色着色。</p><hr><h2 id="4-使用案例：自定义-Snackbar-背景和文字颜色"><a href="#4-使用案例：自定义-Snackbar-背景和文字颜色" class="headerlink" title="4. 使用案例：自定义 Snackbar 背景和文字颜色"></a>4. 使用案例：自定义 Snackbar 背景和文字颜色</h2><p>以 Snackbar 为例说明如何使用 TintList 修改其背景颜色。默认情况下，Snackbar 的背景和文字颜色由 Material Design 主题控制，但有时需要自定义显示效果。</p><h3 id="4-1-示例代码"><a href="#4-1-示例代码" class="headerlink" title="4.1 示例代码"></a>4.1 示例代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">binding.fab.setOnClickListener &#123; view -&gt;</span><br><span class="line">    // 创建 Snackbar 对象</span><br><span class="line">    val snackbar = Snackbar.make(view, &quot;Data deleted&quot;, Snackbar.LENGTH_SHORT)</span><br><span class="line">        .setAction(&quot;Undo&quot;) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;Data restored&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    // 获取 Snackbar 的根布局</span><br><span class="line">    val snackbarView = snackbar.view</span><br><span class="line"></span><br><span class="line">    // 使用 TintList 强制设置背景为白色</span><br><span class="line">    snackbarView.backgroundTintList = ColorStateList.valueOf(Color.WHITE)</span><br><span class="line"></span><br><span class="line">    // 修改消息文本颜色为黑色</span><br><span class="line">    val textView = snackbarView.findViewById&lt;TextView&gt;(com.google.android.material.R.id.snackbar_text)</span><br><span class="line">    textView?.setTextColor(Color.BLACK)</span><br><span class="line"></span><br><span class="line">    // 修改 Action 按钮文本颜色（例如蓝色）</span><br><span class="line">    val actionTextView = snackbarView.findViewById&lt;TextView&gt;(com.google.android.material.R.id.snackbar_action)</span><br><span class="line">    actionTextView?.setTextColor(Color.BLUE)</span><br><span class="line"></span><br><span class="line">    // 显示 Snackbar</span><br><span class="line">    snackbar.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-代码讲解"><a href="#4-2-代码讲解" class="headerlink" title="4.2 代码讲解"></a>4.2 代码讲解</h3><ul><li><strong>创建 Snackbar：</strong><br> <code>Snackbar.make(view, &quot;Data deleted&quot;, Snackbar.LENGTH_SHORT)</code> 创建一个 Snackbar，其提示文本为 “Data deleted”，持续时间为短暂显示，并通过 <code>setAction(&quot;Undo&quot;)</code> 为其添加一个操作按钮。当点击 “Undo” 按钮时，将弹出 Toast。</li><li><strong>获取根布局：</strong><br> <code>snackbar.view</code> 返回 Snackbar 的根布局（通常为 Snackbar.SnackbarLayout），这使得我们可以修改其背景和内部控件的属性。</li><li><strong>设置背景 TintList：</strong><br> <code>snackbarView.backgroundTintList = ColorStateList.valueOf(Color.WHITE)</code> 使用 ColorStateList 将背景颜色强制着色为白色。<br> 这里的 <code>ColorStateList.valueOf(Color.WHITE)</code> 生成了一个只包含单一颜色的状态列表，无论控件处于何种状态都显示白色。</li><li><strong>修改文本颜色：</strong><br> 通过 <code>findViewById</code> 方法分别获取用于显示主要消息和 Action 按钮文本的 TextView，并将它们的文本颜色分别设置为黑色和蓝色。</li><li><strong>显示 Snackbar：</strong><br> 调用 <code>snackbar.show()</code> 显示 Snackbar。</li></ul><hr><h2 id="5-TintList-的应用场景"><a href="#5-TintList-的应用场景" class="headerlink" title="5. TintList 的应用场景"></a>5. TintList 的应用场景</h2><ul><li><strong>动态主题切换：</strong> 根据用户选择的主题动态改变控件颜色。</li><li><strong>状态反馈：</strong> 根据控件状态（如按下、禁用等）显示不同颜色反馈。</li><li><strong>自定义控件：</strong> 对于自定义控件，可以通过 TintList 实现颜色的动态更新，而无需创建多个不同的资源文件。</li></ul><hr><h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h2><ul><li><strong>主题覆盖：</strong> 在某些情况下，应用主题可能会覆盖代码中对 TintList 的设置。如果出现这种情况，请检查应用的主题配置或通过样式文件自定义相关控件的默认行为。</li><li><strong>兼容性：</strong> 大多数支持 tint 的控件都可以使用 TintList，但对某些自定义控件需要确保它们正确实现了 tint 属性。</li><li><strong>资源缓存：</strong> 修改后可能需要清理缓存或重启 IDE 才能看到效果。</li></ul><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p><code>TintList</code>（通过 ColorStateList 实现）是 Android 应用开发中一个强大的工具，能够帮助开发者根据控件状态动态修改颜色。无论是背景、图标还是文本颜色，通过正确使用 TintList，都可以使应用 UI 更加灵活和响应用户需求。希望本技术文档能帮助你更好地理解并应用 TintList 技术。</p><h2 id="我的实际应用"><a href="#我的实际应用" class="headerlink" title="我的实际应用"></a>我的实际应用</h2><p>这是我在修改snackbar中使用到的TinitList，因为默认snackbar的是黑底白字，我想改成白底黑字，在修改snackbar的背景颜色发现居然一定得使用TintList，否则修改不了，于是我有感而发，写下这篇文章。以下是我当时代码中关于TinitList的部分，希望能帮助你理解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">binding.fab.setOnClickListener &#123; view -&gt;</span><br><span class="line">    val snackbar = Snackbar.make(view, &quot;Data deleted&quot;, Snackbar.LENGTH_SHORT)</span><br><span class="line">        .setAction(&quot;Undo&quot;) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;Data restored&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    //获取 Snackbar 的 View 并设置 tintList 强制背景为白色.tiniList超级超级超级级厉害的，能强制修改颜色，</span><br><span class="line">    //可用在button,ImageView,FloatingActionButton,但不能用在popupmenu上，修改popupmenu需要在value中定义style，然后在layout中使用这个style</span><br><span class="line">    val snackbarView = snackbar.view</span><br><span class="line">    snackbarView.backgroundTintList = ColorStateList.valueOf(Color.WHITE)</span><br><span class="line"></span><br><span class="line">    // 设置文字为黑色</span><br><span class="line">    val textView = snackbarView.findViewById&lt;TextView&gt;(com.google.android.material.R.id.snackbar_text)</span><br><span class="line">    textView?.setTextColor(Color.BLACK)</span><br><span class="line"></span><br><span class="line">    // 设置 Action 按钮的颜色（这里示例用黑色，你可以换成其它颜色）</span><br><span class="line">    val actionTextView = snackbarView.findViewById&lt;TextView&gt;(com.google.android.material.R.id.snackbar_action)</span><br><span class="line">    actionTextView?.setTextColor(Color.BLUE)</span><br><span class="line"></span><br><span class="line">    snackbar.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ColorStateList使用详解</title>
      <link href="/2025/04/01/ColorStateList%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/01/ColorStateList%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="ColorStateList-使用详解"><a href="#ColorStateList-使用详解" class="headerlink" title="ColorStateList 使用详解"></a><strong>ColorStateList 使用详解</strong></h1><p><code>ColorStateList</code> 是 Android 中用于管理不同状态下颜色变化的工具，常用于按钮、文本、图标等 UI 组件。本文详细介绍 <code>ColorStateList</code> 的定义方式、使用方法以及高级用法。</p><hr><h2 id="1-ColorStateList-简介"><a href="#1-ColorStateList-简介" class="headerlink" title="1. ColorStateList 简介"></a><strong>1. ColorStateList 简介</strong></h2><p><code>ColorStateList</code> 允许开发者为控件的不同状态指定不同的颜色。例如：</p><ul><li>按钮被按下时变成红色，默认状态下是绿色。</li><li>文本在获取焦点时变为蓝色，失去焦点恢复默认颜色。</li><li>自定义 <code>Snackbar</code> 背景颜色。</li></ul><hr><h2 id="2-ColorStateList-的创建方式"><a href="#2-ColorStateList-的创建方式" class="headerlink" title="2. ColorStateList 的创建方式"></a><strong>2. ColorStateList 的创建方式</strong></h2><h3 id="2-1-在-XML-中定义-ColorStateList"><a href="#2-1-在-XML-中定义-ColorStateList" class="headerlink" title="2.1 在 XML 中定义 ColorStateList"></a><strong>2.1 在 XML 中定义 ColorStateList</strong></h3><p>可以在 <code>res/color/</code> 目录下创建 <code>.xml</code> 文件来定义 <code>ColorStateList</code>，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- 按下状态（高优先级） --&gt;</span><br><span class="line">    &lt;item android:state_pressed=&quot;true&quot; android:color=&quot;#FF0000&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 选中状态 --&gt;</span><br><span class="line">    &lt;item android:state_checked=&quot;true&quot; android:color=&quot;#00FF00&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 禁用状态 --&gt;</span><br><span class="line">    &lt;item android:state_enabled=&quot;false&quot; android:color=&quot;#808080&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 默认状态（必须放最后，否则可能被前面的状态匹配覆盖） --&gt;</span><br><span class="line">    &lt;item android:color=&quot;#000000&quot; /&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>state_pressed=&quot;true&quot;</code>：控件被按下时，颜色变为 <code>#FF0000</code>（红色）。</li><li><code>state_checked=&quot;true&quot;</code>：控件被选中时，颜色变为 <code>#00FF00</code>（绿色）。</li><li><code>state_enabled=&quot;false&quot;</code>：控件被禁用时，颜色变为 <code>#808080</code>（灰色）。</li><li><strong>默认颜色必须放在最后</strong>，否则可能会被前面状态覆盖。</li></ul><h3 id="2-2-代码动态创建-ColorStateList"><a href="#2-2-代码动态创建-ColorStateList" class="headerlink" title="2.2 代码动态创建 ColorStateList"></a><strong>2.2 代码动态创建 ColorStateList</strong></h3><p>如果需要在运行时动态生成 <code>ColorStateList</code>，可以使用 <code>ColorStateList()</code> 构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">val states = arrayOf(</span><br><span class="line">    intArrayOf(android.R.attr.state_pressed),  // 按下状态</span><br><span class="line">    intArrayOf(android.R.attr.state_checked),  // 选中状态</span><br><span class="line">    intArrayOf(-android.R.attr.state_enabled), // 禁用状态</span><br><span class="line">    intArrayOf()                               // 默认状态</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">val colors = intArrayOf(</span><br><span class="line">    Color.RED,      // 按下时红色</span><br><span class="line">    Color.GREEN,    // 选中时绿色</span><br><span class="line">    Color.GRAY,     // 禁用时灰色</span><br><span class="line">    Color.BLACK     // 默认状态黑色</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 创建 ColorStateList 对象</span><br><span class="line">val colorStateList = ColorStateList(states, colors)</span><br></pre></td></tr></table></figure><p><strong>参数解析：</strong></p><ul><li><code>states</code>：定义不同状态的数组，使用 <code>intArrayOf</code> 来表示不同的状态。</li><li><code>colors</code>：与 <code>states</code> 一一对应的颜色数组。</li></ul><hr><h2 id="3-ColorStateList-的应用场景"><a href="#3-ColorStateList-的应用场景" class="headerlink" title="3. ColorStateList 的应用场景"></a><strong>3. ColorStateList 的应用场景</strong></h2><h3 id="3-1-设置文本颜色"><a href="#3-1-设置文本颜色" class="headerlink" title="3.1 设置文本颜色"></a><strong>3.1 设置文本颜色</strong></h3><p><code>TextView</code> 及其子类（如 <code>Button</code>）可以使用 <code>setTextColor()</code> 直接应用 <code>ColorStateList</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setTextColor(colorStateList)</span><br></pre></td></tr></table></figure><p>如果在 XML 中定义了 <code>ColorStateList</code>（比如 <code>res/color/text_color.xml</code>），可以直接在 XML 中使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Hello World&quot;</span><br><span class="line">    android:textColor=&quot;@color/text_color&quot;/&gt;</span><br></pre></td></tr></table></figure><p>或者在代码中加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val textColor = ContextCompat.getColorStateList(context, R.color.text_color)</span><br><span class="line">textView.setTextColor(textColor)</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-设置背景颜色（TintList）"><a href="#3-2-设置背景颜色（TintList）" class="headerlink" title="3.2 设置背景颜色（TintList）"></a><strong>3.2 设置背景颜色（TintList）</strong></h3><p>有些控件（如 <code>FloatingActionButton</code>、<code>Button</code>）支持 <code>backgroundTintList</code>，可用于改变背景颜色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fab.backgroundTintList = colorStateList</span><br><span class="line">button.backgroundTintList = colorStateList</span><br></pre></td></tr></table></figure><p>在 XML 中可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xml复制编辑&lt;Button</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Click Me&quot;</span><br><span class="line">    android:backgroundTint=&quot;@color/button_color&quot;/&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-设置图标颜色（ImageView-Drawable）"><a href="#3-3-设置图标颜色（ImageView-Drawable）" class="headerlink" title="3.3 设置图标颜色（ImageView &amp; Drawable）"></a><strong>3.3 设置图标颜色（ImageView &amp; Drawable）</strong></h3><p>对于 <code>ImageView</code>，可以使用 <code>setImageTintList()</code> 设置 Tint 颜色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.imageTintList = colorStateList</span><br></pre></td></tr></table></figure><p>对于 <code>Drawable</code>，可以使用 <code>setTintList()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val drawable = ContextCompat.getDrawable(context, R.drawable.ic_example)</span><br><span class="line">drawable?.setTintList(colorStateList)</span><br><span class="line">imageView.setImageDrawable(drawable)</span><br></pre></td></tr></table></figure><hr><h3 id="3-4-设置-Snackbar-背景颜色"><a href="#3-4-设置-Snackbar-背景颜色" class="headerlink" title="3.4 设置 Snackbar 背景颜色"></a><strong>3.4 设置 Snackbar 背景颜色</strong></h3><p>在 <code>Snackbar</code> 中，我们可以使用 <code>backgroundTintList</code> 来改变背景颜色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val snackbar = Snackbar.make(view, &quot;Hello Snackbar&quot;, Snackbar.LENGTH_SHORT)</span><br><span class="line"></span><br><span class="line">// 修改背景颜色</span><br><span class="line">snackbar.view.backgroundTintList = colorStateList</span><br><span class="line"></span><br><span class="line">// 修改文字颜色</span><br><span class="line">val textView = snackbar.view.findViewById&lt;TextView&gt;(com.google.android.material.R.id.snackbar_text)</span><br><span class="line">textView.setTextColor(Color.BLACK)</span><br><span class="line"></span><br><span class="line">snackbar.show()</span><br></pre></td></tr></table></figure><hr><h3 id="3-5-设置-PopupMenu-颜色"><a href="#3-5-设置-PopupMenu-颜色" class="headerlink" title="3.5 设置 PopupMenu 颜色"></a><strong>3.5 设置 PopupMenu 颜色</strong></h3><p><code>PopupMenu</code> 默认颜色受 Material Design 主题影响，可以用 <code>ColorStateList</code> 修改 <code>MenuItem</code> 颜色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val popupMenu = PopupMenu(this, view)</span><br><span class="line">popupMenu.menuInflater.inflate(R.menu.popup_menu, popupMenu.menu)</span><br><span class="line"></span><br><span class="line">// 获取 PopupMenu 的 MenuItem 并设置 TextColor</span><br><span class="line">for (i in 0 until popupMenu.menu.size()) &#123;</span><br><span class="line">    val item = popupMenu.menu.getItem(i)</span><br><span class="line">    val spannable = SpannableString(item.title)</span><br><span class="line">    spannable.setSpan(ForegroundColorSpan(Color.RED), 0, spannable.length, 0)</span><br><span class="line">    item.title = spannable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">popupMenu.show()</span><br></pre></td></tr></table></figure><hr><h2 id="4-高级用法"><a href="#4-高级用法" class="headerlink" title="4. 高级用法"></a><strong>4. 高级用法</strong></h2><h3 id="4-1-使用-withAlpha-改变透明度"><a href="#4-1-使用-withAlpha-改变透明度" class="headerlink" title="4.1 使用 withAlpha() 改变透明度"></a><strong>4.1 使用 withAlpha() 改变透明度</strong></h3><p><code>ColorStateList.valueOf(Color.RED).withAlpha(128)</code> 可以为颜色增加透明度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val colorStateList = ColorStateList.valueOf(Color.RED).withAlpha(128)</span><br><span class="line">textView.setTextColor(colorStateList)</span><br></pre></td></tr></table></figure><hr><h3 id="4-2-结合-Material-Theme-适配暗黑模式"><a href="#4-2-结合-Material-Theme-适配暗黑模式" class="headerlink" title="4.2 结合 Material Theme 适配暗黑模式"></a><strong>4.2 结合 Material Theme 适配暗黑模式</strong></h3><p>在 <code>res/color/</code> 目录下创建 <code>color.xml</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item android:color=&quot;?attr/colorPrimary&quot; /&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure><p>这样 <code>ColorStateList</code> 会自动适配 Material Theme 颜色。</p><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h2><ol><li><code>ColorStateList</code> 允许为控件的不同状态指定不同颜色，支持 XML 和代码创建。</li><li>常用于 <code>TextView</code>、<code>Button</code>、<code>ImageView</code>、<code>Snackbar</code>、<code>PopupMenu</code> 等控件的颜色控制。</li><li>结合 <code>TintList</code> 可以改变背景、图标、Drawable 颜色。</li><li>通过 <code>withAlpha()</code> 可以调整透明度，结合 Material Theme 可适配暗黑模式。</li></ol><p>掌握 <code>ColorStateList</code> 和 <code>TintList</code>，可以让 UI 颜色控制更加灵活！</p><h1 id="我的实践-实现一个按钮按下时变成红色，默认状态下是绿色"><a href="#我的实践-实现一个按钮按下时变成红色，默认状态下是绿色" class="headerlink" title="我的实践 实现一个按钮按下时变成红色，默认状态下是绿色"></a>我的实践 实现一个按钮按下时变成红色，默认状态下是绿色</h1><p>要实现“按钮被按下时变成红色，默认状态下是绿色”，可以使用 <code>ColorStateList</code> 结合 <code>backgroundTintList</code> 或 <code>textColor</code>。下面是具体的 XML 和 Kotlin 代码示例。</p><hr><h2 id="方式-1：使用-XML-定义-ColorStateList"><a href="#方式-1：使用-XML-定义-ColorStateList" class="headerlink" title="方式 1：使用 XML 定义 ColorStateList"></a><strong>方式 1：使用 XML 定义 ColorStateList</strong></h2><h3 id="1-1-创建按钮颜色状态列表"><a href="#1-1-创建按钮颜色状态列表" class="headerlink" title="1.1 创建按钮颜色状态列表"></a><strong>1.1 创建按钮颜色状态列表</strong></h3><p>在 <code>res/color/</code> 目录下创建一个 <code>button_color.xml</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- 按下状态（高优先级） --&gt;</span><br><span class="line">    &lt;item android:state_pressed=&quot;true&quot; android:color=&quot;#FF0000&quot; /&gt; &lt;!-- 红色 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 默认状态（最后定义） --&gt;</span><br><span class="line">    &lt;item android:color=&quot;#00FF00&quot; /&gt; &lt;!-- 绿色 --&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-在-XML-布局中应用"><a href="#1-2-在-XML-布局中应用" class="headerlink" title="1.2 在 XML 布局中应用"></a><strong>1.2 在 XML 布局中应用</strong></h3><p>在 <code>activity_main.xml</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:id=&quot;@+id/myButton&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Click Me&quot;</span><br><span class="line">    android:textColor=&quot;@android:color/white&quot;</span><br><span class="line">    android:backgroundTint=&quot;@color/button_color&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>这个 <code>Button</code> 的背景颜色由 <code>button_color.xml</code> 控制。</li><li>当 <code>state_pressed=&quot;true&quot;</code>（即按钮被按下时），背景变为 <code>#FF0000</code>（红色）。</li><li>其他情况下，背景保持 <code>#00FF00</code>（绿色）。</li></ul><hr><h2 id="方式-2：在代码中动态创建-ColorStateList"><a href="#方式-2：在代码中动态创建-ColorStateList" class="headerlink" title="方式 2：在代码中动态创建 ColorStateList"></a><strong>方式 2：在代码中动态创建 ColorStateList</strong></h2><p>如果不想使用 XML，可以直接在 Kotlin 代码中动态创建 <code>ColorStateList</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import android.content.res.ColorStateList</span><br><span class="line">import android.graphics.Color</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.widget.Button</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val myButton: Button = findViewById(R.id.myButton)</span><br><span class="line"></span><br><span class="line">        // 定义按钮不同状态的颜色</span><br><span class="line">        val states = arrayOf(</span><br><span class="line">            intArrayOf(android.R.attr.state_pressed),  // 按下状态</span><br><span class="line">            intArrayOf()  // 默认状态</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        val colors = intArrayOf(</span><br><span class="line">            Color.RED,    // 按下时红色</span><br><span class="line">            Color.GREEN   // 默认状态绿色</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // 创建 ColorStateList 并应用到按钮背景</span><br><span class="line">        val colorStateList = ColorStateList(states, colors)</span><br><span class="line">        myButton.backgroundTintList = colorStateList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>states</code> 定义了两种状态：<ul><li><code>android.R.attr.state_pressed</code>（按钮被按下）。</li><li><code>intArrayOf()</code> 代表默认状态。</li></ul></li><li><code>colors</code> 定义了对应状态的颜色：<ul><li>按下时（<code>state_pressed</code>）是红色 (<code>Color.RED</code>)。</li><li>默认状态是绿色 (<code>Color.GREEN</code>)。</li></ul></li><li><code>myButton.backgroundTintList = colorStateList</code> 应用 <code>ColorStateList</code>。</li></ul><hr><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a><strong>效果</strong></h2><ol><li>按钮默认情况下是绿色。</li><li>当用户按下按钮时，按钮变为红色。</li><li>松开后恢复为绿色。</li></ol><p>这样，你就成功让按钮按下变红，松开变绿了！🚀</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Material3 资源管理全解析:Color,String,Style,Dimen,Array</title>
      <link href="/2025/03/31/Android%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%85%A8%E8%A7%A3%E6%9E%90-Color-String-Style-Dimen-Array/"/>
      <url>/2025/03/31/Android%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%85%A8%E8%A7%A3%E6%9E%90-Color-String-Style-Dimen-Array/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-资源管理全解析：Color、String、Style、Dimen、Array"><a href="#Android-资源管理全解析：Color、String、Style、Dimen、Array" class="headerlink" title="Android 资源管理全解析：Color、String、Style、Dimen、Array"></a>Android 资源管理全解析：Color、String、Style、Dimen、Array</h1><h2 id="1-资源（Resource）概述"><a href="#1-资源（Resource）概述" class="headerlink" title="1. 资源（Resource）概述"></a>1. 资源（Resource）概述</h2><p>在 Android 开发中，资源文件（res&#x2F;values 目录）用于存储 <strong>颜色、文本、样式、尺寸、数组</strong> 等 <strong>非代码</strong> 内容，便于：</p><ul><li>统一管理 UI 风格，增强可维护性</li><li>支持 <strong>多语言（国际化）</strong></li><li>适配 <strong>不同屏幕密度、尺寸、模式（夜间模式等）</strong></li><li>提高应用的 <strong>复用性和灵活性</strong></li></ul><hr><h2 id="2-颜色资源（Color）"><a href="#2-颜色资源（Color）" class="headerlink" title="2. 颜色资源（Color）"></a>2. 颜色资源（Color）</h2><h3 id="2-1-定义颜色（colors-xml）"><a href="#2-1-定义颜色（colors-xml）" class="headerlink" title="2.1 定义颜色（colors.xml）"></a>2.1 定义颜色（colors.xml）</h3><p>颜色资源用于 <strong>定义 UI 组件的颜色</strong>，可存储在 <code>res/values/colors.xml</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;!-- 基础颜色 --&gt;</span><br><span class="line">    &lt;color name=&quot;black&quot;&gt;#000000&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 主题颜色 --&gt;</span><br><span class="line">    &lt;color name=&quot;primary&quot;&gt;#6200EE&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;primaryVariant&quot;&gt;#3700B3&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;secondary&quot;&gt;#03DAC6&lt;/color&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 自定义动态色彩 --&gt;</span><br><span class="line">    &lt;color name=&quot;md_theme_light_primary&quot;&gt;#6750A4&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;md_theme_dark_primary&quot;&gt;#D0BCFF&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-颜色的引用"><a href="#2-2-颜色的引用" class="headerlink" title="2.2 颜色的引用"></a>2.2 颜色的引用</h3><h4 id="1-在-XML-布局中"><a href="#1-在-XML-布局中" class="headerlink" title="(1) 在 XML 布局中"></a><strong>(1) 在 XML 布局中</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:textColor=&quot;@color/primary&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="2-在-styles-xml"><a href="#2-在-styles-xml" class="headerlink" title="(2) 在 styles.xml"></a><strong>(2) 在 styles.xml</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:textColor&quot;&gt;@color/primary&lt;/item&gt;</span><br></pre></td></tr></table></figure><h4 id="3-在-Kotlin-代码中"><a href="#3-在-Kotlin-代码中" class="headerlink" title="(3) 在 Kotlin 代码中"></a><strong>(3) 在 Kotlin 代码中</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val color = ContextCompat.getColor(context, R.color.primary)</span><br><span class="line">textView.setTextColor(color)</span><br></pre></td></tr></table></figure><h3 id="2-3-适配夜间模式（values-night-colors-xml）"><a href="#2-3-适配夜间模式（values-night-colors-xml）" class="headerlink" title="2.3 适配夜间模式（values-night&#x2F;colors.xml）"></a>2.3 适配夜间模式（values-night&#x2F;colors.xml）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;primary&quot;&gt;#BB86FC&lt;/color&gt; &lt;!-- 夜间模式颜色 --&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="3-字符串资源（String）"><a href="#3-字符串资源（String）" class="headerlink" title="3. 字符串资源（String）"></a>3. 字符串资源（String）</h2><h3 id="3-1-定义字符串（strings-xml）"><a href="#3-1-定义字符串（strings-xml）" class="headerlink" title="3.1 定义字符串（strings.xml）"></a>3.1 定义字符串（strings.xml）</h3><p>字符串资源存放在 <code>res/values/strings.xml</code>，用于 <strong>文本国际化、多语言适配</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string name=&quot;app_name&quot;&gt;My Material3 App&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;hello_world&quot;&gt;Hello, Material3!&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 带格式参数 --&gt;</span><br><span class="line">    &lt;string name=&quot;welcome_message&quot;&gt;Welcome, %1$s!&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- HTML 富文本 --&gt;</span><br><span class="line">    &lt;string name=&quot;html_text&quot;&gt;&lt;![CDATA[&lt;b&gt;Bold Text&lt;/b&gt;]]&gt;&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-字符串的引用"><a href="#3-2-字符串的引用" class="headerlink" title="3.2 字符串的引用"></a>3.2 字符串的引用</h3><h4 id="1-在-XML-布局中-1"><a href="#1-在-XML-布局中-1" class="headerlink" title="(1) 在 XML 布局中"></a><strong>(1) 在 XML 布局中</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xml复制编辑&lt;TextView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;@string/hello_world&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="2-在-Kotlin-代码中"><a href="#2-在-Kotlin-代码中" class="headerlink" title="(2) 在 Kotlin 代码中"></a><strong>(2) 在 Kotlin 代码中</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val welcome = getString(R.string.welcome_message, &quot;Alice&quot;)</span><br></pre></td></tr></table></figure><h4 id="3-支持多语言"><a href="#3-支持多语言" class="headerlink" title="(3) 支持多语言"></a><strong>(3) 支持多语言</strong></h4><p>在 <code>res/values-es/strings.xml</code> 定义西班牙语：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string name=&quot;hello_world&quot;&gt;¡Hola, Material3!&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="4-样式资源（Style）"><a href="#4-样式资源（Style）" class="headerlink" title="4. 样式资源（Style）"></a>4. 样式资源（Style）</h2><h3 id="4-1-定义样式（styles-xml）"><a href="#4-1-定义样式（styles-xml）" class="headerlink" title="4.1 定义样式（styles.xml）"></a>4.1 定义样式（styles.xml）</h3><p><code>styles.xml</code> 允许 <strong>复用 UI 属性</strong>，减少代码冗余：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;!-- 自定义按钮样式 --&gt;</span><br><span class="line">    &lt;style name=&quot;CustomButton&quot; parent=&quot;Widget.Material3.Button&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:backgroundTint&quot;&gt;@color/primary&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:textColor&quot;&gt;@color/white&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-样式的引用"><a href="#4-2-样式的引用" class="headerlink" title="4.2 样式的引用"></a>4.2 样式的引用</h3><h4 id="1-在-XML-布局中-2"><a href="#1-在-XML-布局中-2" class="headerlink" title="(1) 在 XML 布局中"></a><strong>(1) 在 XML 布局中</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    style=&quot;@style/CustomButton&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Click Me&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="2-主题（Theme）"><a href="#2-主题（Theme）" class="headerlink" title="(2) 主题（Theme）"></a><strong>(2) 主题（Theme）</strong></h4><p><code>themes.xml</code> 设定全局主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;Theme.MaterialTest&quot; parent=&quot;Theme.Material3.Light.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;colorPrimary&quot;&gt;@color/primary&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:buttonStyle&quot;&gt;@style/CustomButton&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="3-在代码中应用"><a href="#3-在代码中应用" class="headerlink" title="(3) 在代码中应用"></a><strong>(3) 在代码中应用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setTextAppearance(R.style.CustomButton)</span><br></pre></td></tr></table></figure><hr><h2 id="5-尺寸资源（Dimen）"><a href="#5-尺寸资源（Dimen）" class="headerlink" title="5. 尺寸资源（Dimen）"></a>5. 尺寸资源（Dimen）</h2><h3 id="5-1-定义尺寸（dimens-xml）"><a href="#5-1-定义尺寸（dimens-xml）" class="headerlink" title="5.1 定义尺寸（dimens.xml）"></a>5.1 定义尺寸（dimens.xml）</h3><p><code>dimens.xml</code> 用于定义 <strong>像素、dp、sp、pt 等尺寸</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;dimen name=&quot;padding_small&quot;&gt;8dp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;padding_medium&quot;&gt;16dp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;text_size_large&quot;&gt;24sp&lt;/dimen&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><h3 id="5-2-尺寸的引用"><a href="#5-2-尺寸的引用" class="headerlink" title="5.2 尺寸的引用"></a>5.2 尺寸的引用</h3><h4 id="1-在-XML-布局中-3"><a href="#1-在-XML-布局中-3" class="headerlink" title="(1) 在 XML 布局中"></a><strong>(1) 在 XML 布局中</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:textSize=&quot;@dimen/text_size_large&quot;</span><br><span class="line">    android:padding=&quot;@dimen/padding_medium&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="2-在-Kotlin-代码中-1"><a href="#2-在-Kotlin-代码中-1" class="headerlink" title="(2) 在 Kotlin 代码中"></a><strong>(2) 在 Kotlin 代码中</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val padding = resources.getDimension(R.dimen.padding_small)</span><br><span class="line">textView.setPadding(padding.toInt(), padding.toInt(), padding.toInt(), padding.toInt())</span><br></pre></td></tr></table></figure><h3 id="5-3-适配不同屏幕密度"><a href="#5-3-适配不同屏幕密度" class="headerlink" title="5.3 适配不同屏幕密度"></a>5.3 适配不同屏幕密度</h3><ul><li><code>values-sw600dp/dimens.xml</code>：适配 <strong>大屏</strong></li><li><code>values-land/dimens.xml</code>：适配 <strong>横屏</strong></li></ul><hr><h2 id="6-数组资源（Array）"><a href="#6-数组资源（Array）" class="headerlink" title="6. 数组资源（Array）"></a>6. 数组资源（Array）</h2><h3 id="6-1-定义数组（arrays-xml）"><a href="#6-1-定义数组（arrays-xml）" class="headerlink" title="6.1 定义数组（arrays.xml）"></a>6.1 定义数组（arrays.xml）</h3><p><code>arrays.xml</code> 用于存储 <strong>字符串、颜色或整数数组</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;!-- 字符串数组 --&gt;</span><br><span class="line">    &lt;string-array name=&quot;fruit_array&quot;&gt;</span><br><span class="line">        &lt;item&gt;Apple&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;Banana&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;Cherry&lt;/item&gt;</span><br><span class="line">    &lt;/string-array&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 颜色数组 --&gt;</span><br><span class="line">    &lt;array name=&quot;color_array&quot;&gt;</span><br><span class="line">        &lt;item&gt;@color/primary&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;@color/secondary&lt;/item&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><h3 id="6-2-数组的引用"><a href="#6-2-数组的引用" class="headerlink" title="6.2 数组的引用"></a>6.2 数组的引用</h3><h4 id="1-在-Kotlin-代码中"><a href="#1-在-Kotlin-代码中" class="headerlink" title="(1) 在 Kotlin 代码中"></a><strong>(1) 在 Kotlin 代码中</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑val fruits = resources.getStringArray(R.array.fruit_array)</span><br><span class="line">val colors = resources.obtainTypedArray(R.array.color_array)</span><br></pre></td></tr></table></figure><h4 id="2-在-Spinner-中"><a href="#2-在-Spinner-中" class="headerlink" title="(2) 在 Spinner 中"></a><strong>(2) 在 Spinner 中</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Spinner</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:entries=&quot;@array/fruit_array&quot; /&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="7-总结与优化建议"><a href="#7-总结与优化建议" class="headerlink" title="7. 总结与优化建议"></a>7. 总结与优化建议</h2><ul><li><strong>Color</strong>：定义在 <code>colors.xml</code>，配合 <strong>夜间模式</strong> 使用 <code>values-night/colors.xml</code></li><li><strong>String</strong>：所有文本集中管理，支持多语言</li><li><strong>Style</strong>：提高 UI 复用性，避免重复代码</li><li><strong>Dimen</strong>：统一管理尺寸，支持不同屏幕适配</li><li><strong>Array</strong>：用于存储列表数据，如 Spinner 下拉项</li></ul><hr><p>掌握 <code>color、string、style、dimen、array</code> 资源管理，让你的 Android 代码更整洁、易维护，并支持 Material3 最新特性！ 🚀</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vector Asset的使用示例</title>
      <link href="/2025/03/31/Vector-Asset%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/31/Vector-Asset%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-使用-Vector-Asset-的技术解析"><a href="#Android-使用-Vector-Asset-的技术解析" class="headerlink" title="Android 使用 Vector Asset 的技术解析"></a>Android 使用 Vector Asset 的技术解析</h1><p>在 Android 开发中，图形资源一直是用户体验的重要组成部分。传统上，开发者常常依赖位图（Bitmap）资源，但随着多种屏幕分辨率的设备不断涌现，位图资源在扩展性和存储效率上逐渐暴露出不足。为了解决这一问题，Google 引入了 <strong>Vector Asset（矢量资源）</strong>，它能够以较小的体积提供高质量且可伸缩的图形表现。本文将详细介绍 Android 中 Vector Asset 的使用方法、优势、注意事项以及最佳实践。</p><hr><h2 id="1-什么是-Vector-Asset？"><a href="#1-什么是-Vector-Asset？" class="headerlink" title="1. 什么是 Vector Asset？"></a>1. 什么是 Vector Asset？</h2><p>Vector Asset 是基于 XML 定义的矢量图形资源，不同于位图资源，它通过数学公式来描述图形的轮廓和颜色，从而实现无限放大而不会失真。主要优点包括：</p><ul><li><strong>无失真缩放：</strong> 无论在何种分辨率下，矢量图形都能保持清晰的显示效果。</li><li><strong>文件体积小：</strong> 相对于同等质量的位图资源，矢量图通常占用更少的存储空间。</li><li><strong>灵活的颜色和尺寸调整：</strong> 可在运行时动态修改颜色和大小，适应不同的主题和布局需求。</li></ul><hr><h2 id="2-Android-Studio-中导入-Vector-Asset"><a href="#2-Android-Studio-中导入-Vector-Asset" class="headerlink" title="2. Android Studio 中导入 Vector Asset"></a>2. Android Studio 中导入 Vector Asset</h2><p>Android Studio 提供了直观的工具来导入和管理 Vector Asset，具体步骤如下：</p><h3 id="2-1-通过-Vector-Asset-Studio-导入"><a href="#2-1-通过-Vector-Asset-Studio-导入" class="headerlink" title="2.1 通过 Vector Asset Studio 导入"></a>2.1 通过 Vector Asset Studio 导入</h3><ol><li><strong>打开 Vector Asset Studio：</strong><br> 在项目的 <code>res</code> 目录下，右键点击 <code>drawable</code> 文件夹，选择 <strong>New → Vector Asset</strong>。</li><li><strong>选择图标或导入 SVG：</strong><ul><li>可以在内置的 Material 图标库中选择需要的图标；</li><li>或者点击 <strong>Local file (SVG, PSD)</strong> 按钮导入自定义的 SVG 文件。</li></ul></li><li><strong>配置资源属性：</strong><ul><li>在预览窗口中确认图标显示效果；</li><li>修改图标名称、尺寸以及填充色（可根据主题进行动态调整）；</li><li>点击 <strong>Next</strong> 和 <strong>Finish</strong> 完成导入。</li></ul></li></ol><h3 id="2-2-编辑-XML-文件"><a href="#2-2-编辑-XML-文件" class="headerlink" title="2.2 编辑 XML 文件"></a>2.2 编辑 XML 文件</h3><p>导入后的 Vector Asset 会在 <code>drawable</code> 文件夹下生成一个 XML 文件，类似下面的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:width=&quot;24dp&quot;</span><br><span class="line">    android:height=&quot;24dp&quot;</span><br><span class="line">    android:viewportWidth=&quot;24&quot;</span><br><span class="line">    android:viewportHeight=&quot;24&quot;&gt;</span><br><span class="line">    &lt;path</span><br><span class="line">        android:fillColor=&quot;#FF000000&quot;</span><br><span class="line">        android:pathData=&quot;M12,2L2,22h20L12,2z&quot;/&gt;</span><br><span class="line">&lt;/vector&gt;</span><br></pre></td></tr></table></figure><p>在该文件中：</p><ul><li><code>android:width</code> 和 <code>android:height</code> 定义了默认尺寸。</li><li><code>android:viewportWidth</code> 与 <code>android:viewportHeight</code> 定义了内部坐标系统。</li><li><code>&lt;path&gt;</code> 标签描述了具体的绘制路径及填充色。</li></ul><p>通过修改这些属性，可以实现对图标的个性化定制和主题适配。</p><hr><h2 id="3-在项目中使用-Vector-Asset"><a href="#3-在项目中使用-Vector-Asset" class="headerlink" title="3. 在项目中使用 Vector Asset"></a>3. 在项目中使用 Vector Asset</h2><h3 id="3-1-布局文件中引用"><a href="#3-1-布局文件中引用" class="headerlink" title="3.1 布局文件中引用"></a>3.1 布局文件中引用</h3><p>使用矢量资源与引用位图资源类似，例如在 <code>ImageView</code> 中直接设置 <code>src</code> 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:src=&quot;@drawable/ic_vector_example&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-动态设置"><a href="#3-2-动态设置" class="headerlink" title="3.2 动态设置"></a>3.2 动态设置</h3><p>在代码中，可以通过 <code>setImageResource()</code> 或使用 <code>AppCompatImageView</code> 来加载矢量资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val imageView: ImageView = findViewById(R.id.myImageView)</span><br><span class="line">imageView.setImageResource(R.drawable.ic_vector_example)</span><br></pre></td></tr></table></figure><p>对于更高级的动态操作（例如颜色变化），可以通过 <code>DrawableCompat</code> 来包装并修改矢量资源的属性。</p><hr><h2 id="4-兼容性注意事项"><a href="#4-兼容性注意事项" class="headerlink" title="4. 兼容性注意事项"></a>4. 兼容性注意事项</h2><p>虽然 Android 从 Lollipop (API 21) 开始原生支持矢量资源，但对于低版本设备（API 19 及以下）仍需注意兼容性问题。为此，Google 提供了 <strong>VectorDrawableCompat</strong>，以及在 <code>build.gradle</code> 文件中配置相关选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        vectorDrawables.useSupportLibrary = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，建议在代码中使用 <code>AppCompatImageView</code> 或在 XML 布局中添加 <code>app:srcCompat</code> 属性来确保兼容性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.appcompat.widget.AppCompatImageView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:srcCompat=&quot;@drawable/ic_vector_example&quot; /&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5. 最佳实践"></a>5. 最佳实践</h2><h3 id="5-1-尽量使用内置图标"><a href="#5-1-尽量使用内置图标" class="headerlink" title="5.1 尽量使用内置图标"></a>5.1 尽量使用内置图标</h3><p>Google 提供了丰富的 Material Design 图标，建议优先使用这些经过优化的图标库，既能保证一致性，又能减少额外资源导入。</p><h3 id="5-2-保持-SVG-文件简洁"><a href="#5-2-保持-SVG-文件简洁" class="headerlink" title="5.2 保持 SVG 文件简洁"></a>5.2 保持 SVG 文件简洁</h3><p>在导入自定义 SVG 文件前，可以借助工具（如 <a href="https://github.com/svg/svgo">SVGO</a>）对文件进行优化，去除不必要的属性和冗余数据，确保生成的 Vector Asset 文件保持轻量高效。</p><h3 id="5-3-动态适配主题"><a href="#5-3-动态适配主题" class="headerlink" title="5.3 动态适配主题"></a>5.3 动态适配主题</h3><p>利用 Android 的主题系统，可以在 Vector Asset 中通过属性引用来实现动态适配。例如，将 <code>fillColor</code> 设置为属性引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;path</span><br><span class="line">    android:fillColor=&quot;?attr/colorControlNormal&quot;</span><br><span class="line">    android:pathData=&quot;...&quot; /&gt;</span><br></pre></td></tr></table></figure><p>这样可以随着主题变化自动调整图标颜色，提高 UI 的一致性。</p><hr><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>使用 Vector Asset 是应对多分辨率设备和复杂 UI 需求的高效解决方案。它不仅能确保图形在各种设备上无失真显示，还能大幅降低 APK 文件的体积。通过 Android Studio 的内置工具、兼容性配置和最佳实践，开发者可以轻松引入并管理矢量资源，从而提升开发效率和用户体验。</p><p>随着 Android 平台的不断进步，Vector Asset 的使用方法和相关工具也在不断更新，但其核心优势始终不变——高效、灵活且易于维护。希望本文能为你在项目中更好地应用矢量图资源提供帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin的协程</title>
      <link href="/2025/03/30/Kotlin%E7%9A%84%E5%8D%8F%E7%A8%8B/"/>
      <url>/2025/03/30/Kotlin%E7%9A%84%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-协程技术文档"><a href="#Kotlin-协程技术文档" class="headerlink" title="Kotlin 协程技术文档"></a>Kotlin 协程技术文档</h1><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kotlin 协程是 Kotlin 官方提供的一种用于简化异步编程和并发任务处理的工具。它能够让你用同步的写法实现异步代码，大大简化了回调地狱（callback hell）问题，提高了代码的可读性和维护性。协程在 Android 开发、服务器开发等场景中都有广泛应用。</p><hr><h2 id="协程基本概念"><a href="#协程基本概念" class="headerlink" title="协程基本概念"></a>协程基本概念</h2><h3 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h3><p>协程是一种轻量级的线程，能够在单个线程内并发执行多个任务。它基于挂起（suspending）和恢复（resuming）机制，在任务遇到耗时操作（如 IO、网络请求）时挂起执行，不阻塞线程，待条件满足后恢复执行。</p><h3 id="协程与线程的对比"><a href="#协程与线程的对比" class="headerlink" title="协程与线程的对比"></a>协程与线程的对比</h3><ul><li><strong>轻量性</strong>：协程比线程更加轻量，一个应用可以同时启动成千上万个协程，而线程数量通常受限于系统资源。</li><li><strong>调度模型</strong>：协程由调度器（Dispatchers）管理，可以在多个线程间灵活调度，而线程调度依赖于操作系统。</li><li><strong>切换成本</strong>：协程的上下文切换成本远低于线程切换，性能开销较小。</li><li><strong>编程模型</strong>：协程可以用顺序化的代码编写异步逻辑，避免回调嵌套，使代码更直观。</li></ul><hr><h2 id="协程构建块"><a href="#协程构建块" class="headerlink" title="协程构建块"></a>协程构建块</h2><h3 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h3><ul><li><strong>定义</strong>：<code>CoroutineScope</code> 表示一个协程作用域，它限定了协程的生命周期。所有在该作用域内启动的协程都遵循同一个生命周期，便于集中管理。</li><li><strong>创建</strong>：可以通过 <code>GlobalScope</code>（不推荐使用）、<code>CoroutineScope(Job())</code> 或 Android 的 <code>viewModelScope</code>、<code>lifecycleScope</code> 来创建作用域。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自定义 CoroutineScope</span><br><span class="line">val myScope = CoroutineScope(Dispatchers.Main + Job())</span><br></pre></td></tr></table></figure><h3 id="启动协程：launch-与-async"><a href="#启动协程：launch-与-async" class="headerlink" title="启动协程：launch 与 async"></a>启动协程：launch 与 async</h3><ul><li><p><strong>launch</strong><br> 用于启动一个不需要返回结果的协程，返回一个 <code>Job</code> 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myScope.launch &#123;</span><br><span class="line">    // 在协程中执行耗时操作</span><br><span class="line">    delay(1000)</span><br><span class="line">    println(&quot;Hello from launch!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>async</strong><br> 用于启动一个协程并返回一个 <code>Deferred</code> 对象，表示未来可能返回的结果。常用于并行计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val deferredResult = myScope.async &#123;</span><br><span class="line">    // 执行计算并返回结果</span><br><span class="line">    delay(500)</span><br><span class="line">    return@async 42</span><br><span class="line">&#125;</span><br><span class="line">// 获取结果，注意：await() 是挂起函数</span><br><span class="line">val result = deferredResult.await()</span><br></pre></td></tr></table></figure></li></ul><h3 id="Job-与-Deferred"><a href="#Job-与-Deferred" class="headerlink" title="Job 与 Deferred"></a>Job 与 Deferred</h3><ul><li><strong>Job</strong>：表示一个协程任务，主要用于管理协程的生命周期（如取消协程）。</li><li><strong>Deferred</strong>：继承自 Job，表示一个带有返回值的任务，使用 <code>await()</code> 方法可以挂起协程等待结果。</li></ul><hr><h2 id="调度器-Dispatchers"><a href="#调度器-Dispatchers" class="headerlink" title="调度器 (Dispatchers)"></a>调度器 (Dispatchers)</h2><p>调度器决定协程在哪个线程或线程池上运行。常用的调度器包括：</p><h3 id="常见调度器"><a href="#常见调度器" class="headerlink" title="常见调度器"></a>常见调度器</h3><ul><li><strong>Dispatchers.Main</strong><br> 用于更新 UI 的主线程，适用于 Android 中与 UI 相关的操作。</li><li><strong>Dispatchers.IO</strong><br> 用于执行 IO 密集型任务，如网络请求、磁盘操作等。</li><li><strong>Dispatchers.Default</strong><br> 用于执行 CPU 密集型任务，如复杂计算。</li><li><strong>Dispatchers.Unconfined</strong><br> 不受限于特定线程，立即在当前线程中执行，通常用于测试或特殊场景。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在 IO 线程中执行网络请求</span><br><span class="line">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">    val data = fetchDataFromNetwork()</span><br><span class="line">    // 切换回主线程更新 UI</span><br><span class="line">    withContext(Dispatchers.Main) &#123;</span><br><span class="line">        updateUI(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义调度器"><a href="#自定义调度器" class="headerlink" title="自定义调度器"></a>自定义调度器</h3><p>可以创建自定义线程池，并用 <code>asCoroutineDispatcher()</code> 方法转换为协程调度器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val myExecutor = Executors.newFixedThreadPool(4)</span><br><span class="line">val myDispatcher = myExecutor.asCoroutineDispatcher()</span><br></pre></td></tr></table></figure><hr><h2 id="withContext-的使用"><a href="#withContext-的使用" class="headerlink" title="withContext() 的使用"></a><code>withContext()</code> 的使用</h2><p><code>withContext()</code> 是 Kotlin 协程中的 <strong>挂起函数</strong>，用于 <strong>在协程中切换执行的调度器</strong>。它不会创建新的协程，而是挂起当前协程并在指定的调度器上执行代码块，执行完成后恢复到原来的调度器。</p><p><code>withContext()</code> <strong>会挂起外部协程，直到内部代码执行完毕，才继续执行外部协程的后续代码</strong>，但<strong>不会阻塞线程</strong>。</p><hr><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    println(&quot;Start: $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        println(&quot;Switch to IO: $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(1000) // 模拟耗时操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;Back to main: $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a><strong>执行过程</strong></h3><ol><li><code>runBlocking</code> 在 <strong>主线程</strong> 中运行。</li><li><code>withContext(Dispatchers.IO)</code> 切换到 <strong>IO 线程池</strong> 并执行代码块。</li><li><code>delay(1000)</code> 让协程挂起 <strong>1 秒</strong>，但不会阻塞线程。</li><li><code>withContext</code> 执行完毕，恢复到 <strong>原来的调度器（主线程）</strong>。</li></ol><hr><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a><strong>常见用途</strong></h3><h4 id="1-在-Dispatchers-Main-执行-UI-更新"><a href="#1-在-Dispatchers-Main-执行-UI-更新" class="headerlink" title="1. 在 Dispatchers.Main 执行 UI 更新"></a><strong>1. 在 <code>Dispatchers.Main</code> 执行 UI 更新</strong></h4><p>适用于 <strong>Android 开发</strong>，用于 <strong>在后台线程执行任务，并回到主线程更新 UI</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            val data = withContext(Dispatchers.IO) &#123; fetchData() &#125;</span><br><span class="line">            textView.text = data // 回到主线程更新 UI</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private suspend fun fetchData(): String &#123;</span><br><span class="line">        delay(2000) // 模拟网络请求</span><br><span class="line">        return &quot;Data from server&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔹 <code>fetchData()</code> 在 <strong>IO 线程执行</strong>，获取数据后 <code>withContext</code> 自动 <strong>回到主线程</strong> 更新 <code>textView</code>。</p><hr><h4 id="2-计算密集型任务-Dispatchers-Default"><a href="#2-计算密集型任务-Dispatchers-Default" class="headerlink" title="2. 计算密集型任务 (Dispatchers.Default)"></a><strong>2. 计算密集型任务 (<code>Dispatchers.Default</code>)</strong></h4><p>适用于 <strong>CPU 密集型计算</strong>（如排序、加密、数据处理）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">suspend fun heavyComputation() &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        val result = (1..1_000_000).sum()</span><br><span class="line">        println(&quot;Computation result: $result&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔹 计算任务会在 <strong>默认线程池</strong>（<code>Default</code>）运行，不会阻塞 UI。</p><hr><h4 id="3-读取本地文件（IO-线程）"><a href="#3-读取本地文件（IO-线程）" class="headerlink" title="3. 读取本地文件（IO 线程）"></a><strong>3. 读取本地文件（IO 线程）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend fun readFile(): String &#123;</span><br><span class="line">    return withContext(Dispatchers.IO) &#123;</span><br><span class="line">        File(&quot;data.txt&quot;).readText()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔹 <strong>避免主线程阻塞</strong>，文件读取在 <strong>IO 线程</strong> 完成。</p><hr><h3 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a><strong>⚠️ 注意事项</strong></h3><ol><li><strong><code>withContext()</code> 不会创建新的协程</strong>，只是切换执行环境。</li><li><strong><code>withContext()</code> 适合执行一个需要返回结果的任务</strong>，如果要 <strong>同时运行多个任务</strong>，用 <code>launch</code> 或 <code>async</code>。</li><li><strong>不要在 <code>Dispatchers.Main</code> 中使用 <code>withContext(Dispatchers.Main)</code></strong>，会导致 <strong>额外的调度开销</strong>。</li></ol><hr><h3 id="🚀-总结"><a href="#🚀-总结" class="headerlink" title="🚀 总结"></a><strong>🚀 总结</strong></h3><ul><li><code>withContext()</code> 用于 <strong>切换线程并执行代码</strong>，执行完自动回到原来的线程。</li><li><strong>适用于</strong> IO 操作、计算任务、UI 更新等场景。</li><li><strong>不会创建新协程</strong>，而是 <strong>挂起当前协程</strong> 并切换调度器。</li></ul><p>💡 <strong>适用场景</strong>： ✅ <strong>网络请求</strong>（<code>Dispatchers.IO</code>）<br> ✅ <strong>数据库操作</strong>（<code>Dispatchers.IO</code>）<br> ✅ <strong>计算密集型任务</strong>（<code>Dispatchers.Default</code>）<br> ✅ <strong>UI 更新</strong>（<code>Dispatchers.Main</code>）</p><h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><h3 id="作用域与协程层级关系"><a href="#作用域与协程层级关系" class="headerlink" title="作用域与协程层级关系"></a>作用域与协程层级关系</h3><p>结构化并发（Structured Concurrency）要求协程在层次化的作用域内启动，确保父协程管理子协程的生命周期，避免出现未管理的孤儿协程。这样可以保证资源的及时释放与错误的统一处理。</p><h3 id="CoroutineScope-与-supervisorScope"><a href="#CoroutineScope-与-supervisorScope" class="headerlink" title="CoroutineScope 与 supervisorScope"></a>CoroutineScope 与 supervisorScope</h3><ul><li><p><strong>CoroutineScope</strong><br> 默认情况下，如果子协程发生异常，会取消整个作用域内所有协程。</p></li><li><p><strong>supervisorScope</strong><br> 在 <code>supervisorScope</code> 内，一个子协程的异常不会传播到其他子协程，可以实现部分任务失败而不影响整体流程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">supervisorScope &#123;</span><br><span class="line">    val job1 = launch &#123;</span><br><span class="line">        // 子任务 1</span><br><span class="line">    &#125;</span><br><span class="line">    val job2 = launch &#123;</span><br><span class="line">        // 子任务 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="协程取消与超时控制"><a href="#协程取消与超时控制" class="headerlink" title="协程取消与超时控制"></a>协程取消与超时控制</h2><h3 id="取消协程"><a href="#取消协程" class="headerlink" title="取消协程"></a>取消协程</h3><p>协程取消是一种协作机制，被取消的协程需要在合适的地方检测取消状态。常用方法包括：</p><ul><li><strong>调用 <code>job.cancel()</code></strong>：取消当前 Job 以及其所有子协程。</li><li><strong>挂起点检测</strong>：例如 <code>delay()</code>、<code>withContext()</code> 都会检查取消状态。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val job = myScope.launch &#123;</span><br><span class="line">    repeat(1000) &#123; i -&gt;</span><br><span class="line">        if (!isActive) return@launch // 检查协程是否被取消</span><br><span class="line">        println(&quot;Processing $i&quot;)</span><br><span class="line">        delay(100)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 取消协程</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure><h3 id="withTimeout-与-withTimeoutOrNull"><a href="#withTimeout-与-withTimeoutOrNull" class="headerlink" title="withTimeout 与 withTimeoutOrNull"></a>withTimeout 与 withTimeoutOrNull</h3><ul><li><p><strong>withTimeout</strong><br> 规定一段时间内未完成任务，则抛出 <code>TimeoutCancellationException</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    withTimeout(3000) &#123;</span><br><span class="line">        // 如果 3 秒内没有完成，则异常退出</span><br><span class="line">        performLongRunningTask()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (e: TimeoutCancellationException) &#123;</span><br><span class="line">    println(&quot;任务超时&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>withTimeoutOrNull</strong><br> 超时返回 <code>null</code>，不会抛异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val result = withTimeoutOrNull(3000) &#123;</span><br><span class="line">    performLongRunningTask()</span><br><span class="line">&#125;</span><br><span class="line">if (result == null) &#123;</span><br><span class="line">    println(&quot;任务超时&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="CoroutineExceptionHandler"><a href="#CoroutineExceptionHandler" class="headerlink" title="CoroutineExceptionHandler"></a>CoroutineExceptionHandler</h3><p>用于全局捕获协程未处理的异常。通过在协程上下文中添加 <code>CoroutineExceptionHandler</code>，可以统一处理异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val handler = CoroutineExceptionHandler &#123; _, exception -&gt;</span><br><span class="line">    println(&quot;捕获到异常：$&#123;exception.message&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">myScope.launch(handler) &#123;</span><br><span class="line">    throw RuntimeException(&quot;测试异常&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-catch-在协程中的使用"><a href="#try-catch-在协程中的使用" class="headerlink" title="try&#x2F;catch 在协程中的使用"></a>try&#x2F;catch 在协程中的使用</h3><p>在挂起函数内部，同步代码中的 <code>try/catch</code> 同样适用，用于捕获特定的异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myScope.launch &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        val result = performRiskOperation()</span><br><span class="line">        println(&quot;结果：$result&quot;)</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        println(&quot;错误：$&#123;e.message&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="协程通信与同步"><a href="#协程通信与同步" class="headerlink" title="协程通信与同步"></a>协程通信与同步</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 提供了一种在协程之间进行通信的方式，类似于阻塞队列。通过 Channel，可以实现生产者-消费者模型。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.channels.Channel</span><br><span class="line"></span><br><span class="line">val channel = Channel&lt;Int&gt;()</span><br><span class="line">// 生产者协程</span><br><span class="line">launch &#123;</span><br><span class="line">    for (i in 1..5) &#123;</span><br><span class="line">        channel.send(i)</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close() // 关闭 Channel</span><br><span class="line">&#125;</span><br><span class="line">// 消费者协程</span><br><span class="line">launch &#123;</span><br><span class="line">    for (number in channel) &#123;</span><br><span class="line">        println(&quot;接收数据: $number&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p>Flow 是 Kotlin 协程中的响应式流，用于处理异步数据流和背压控制。</p><ul><li><strong>定义 Flow</strong>：使用 <code>flow &#123;&#125;</code> 构建数据流</li><li><strong>收集数据</strong>：使用 <code>collect &#123;&#125;</code> 处理数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line">fun simpleFlow(): Flow&lt;Int&gt; = flow &#123;</span><br><span class="line">    for (i in 1..3) &#123;</span><br><span class="line">        delay(100)</span><br><span class="line">        emit(i) // 发射数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launch &#123;</span><br><span class="line">    simpleFlow().collect &#123; value -&gt;</span><br><span class="line">        println(&quot;收到：$value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="与-Android-集成"><a href="#与-Android-集成" class="headerlink" title="与 Android 集成"></a>与 Android 集成</h2><p>在 Android 开发中，协程可以很好地解决异步任务和 UI 更新问题。常见的集成方式包括：</p><h3 id="在-UI-线程中启动协程"><a href="#在-UI-线程中启动协程" class="headerlink" title="在 UI 线程中启动协程"></a>在 UI 线程中启动协程</h3><p>利用 <code>Dispatchers.Main</code> 在主线程中更新 UI：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CoroutineScope(Dispatchers.Main).launch &#123;</span><br><span class="line">    val data = withContext(Dispatchers.IO) &#123; fetchDataFromNetwork() &#125;</span><br><span class="line">    textView.text = data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-ViewModelScope-和-LifecycleScope"><a href="#使用-ViewModelScope-和-LifecycleScope" class="headerlink" title="使用 ViewModelScope 和 LifecycleScope"></a>使用 ViewModelScope 和 LifecycleScope</h3><ul><li><p><strong>viewModelScope</strong><br> 适用于 ViewModel 中启动协程，与 ViewModel 生命周期绑定，避免内存泄漏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel : ViewModel() &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            // 执行网络请求或数据加载</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>lifecycleScope</strong><br> 适用于 Activity 或 Fragment，自动管理协程生命周期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            // 执行与 UI 相关的协程操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="最佳实践与常见问题"><a href="#最佳实践与常见问题" class="headerlink" title="最佳实践与常见问题"></a>最佳实践与常见问题</h2><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><strong>避免使用 GlobalScope</strong><br> 全局作用域容易导致协程泄漏，建议使用结构化并发的 CoroutineScope。</li><li><strong>选择合适的调度器</strong><br> 根据任务类型（IO、CPU、UI）选择对应的调度器。</li><li><strong>合理使用超时与取消</strong><br> 对长时间等待的任务使用 withTimeout&#x2F;withTimeoutOrNull，确保协程及时取消。</li><li><strong>异常捕获</strong><br> 在关键业务逻辑中使用 try&#x2F;catch，同时配置 CoroutineExceptionHandler 捕获全局异常。</li><li><strong>整洁代码</strong><br> 将协程相关代码放入专门的 Repository 或 UseCase 层，分离 UI 层逻辑。</li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><strong>协程泄漏</strong><br> 未取消的协程会导致内存泄漏。确保在合适时机调用 cancel() 或使用绑定生命周期的 Scope。</li><li><strong>异常未捕获</strong><br> 子协程异常可能不会传递给父协程，使用 supervisorScope 或者合适的异常处理器来保证异常处理一致性。</li><li><strong>线程切换问题</strong><br> 协程中的上下文切换需要显式指定 withContext，否则可能导致 UI 阻塞或后台线程操作 UI。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析JSON格式数据示例</title>
      <link href="/2025/03/30/%E8%A7%A3%E6%9E%90JSON%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/30/%E8%A7%A3%E6%9E%90JSON%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>书上P444讲的更好</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，常用于 Web API 交互。Kotlin 提供了多种解析 JSON 数据的方法，其中 <code>org.json.JSONObject</code> 和 <code>Gson</code> 是常见的选择。</p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h2><ul><li><strong>解析网络请求返回的 JSON 数据</strong></li><li><strong>存储和读取本地 JSON 配置文件</strong></li><li><strong>序列化&#x2F;反序列化 Kotlin 数据类</strong></li></ul><h2 id="3-JSON-示例"><a href="#3-JSON-示例" class="headerlink" title="3. JSON 示例"></a>3. JSON 示例</h2><p>假设有如下 JSON 数据 <code>sample.json</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 1,</span><br><span class="line">      &quot;name&quot;: &quot;MyApp&quot;,</span><br><span class="line">      &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 2,</span><br><span class="line">      &quot;name&quot;: &quot;AnotherApp&quot;,</span><br><span class="line">      &quot;version&quot;: &quot;2.3.4&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-解析方式"><a href="#4-解析方式" class="headerlink" title="4. 解析方式"></a>4. 解析方式</h2><h3 id="4-1-使用-org-json-解析-JSON"><a href="#4-1-使用-org-json-解析-JSON" class="headerlink" title="4.1 使用 org.json 解析 JSON"></a><strong>4.1 使用 org.json 解析 JSON</strong></h3><p>Kotlin 可以使用 <code>org.json.JSONObject</code> 和 <code>org.json.JSONArray</code> 解析 JSON。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.json.JSONObject</span><br><span class="line"></span><br><span class="line">fun parseJson(jsonData: String) &#123;</span><br><span class="line">    val jsonObject = JSONObject(jsonData)</span><br><span class="line">    val appsArray = jsonObject.getJSONArray(&quot;apps&quot;)</span><br><span class="line">    </span><br><span class="line">    for (i in 0 until appsArray.length()) &#123;</span><br><span class="line">        val appObject = appsArray.getJSONObject(i)</span><br><span class="line">        val id = appObject.getInt(&quot;id&quot;)</span><br><span class="line">        val name = appObject.getString(&quot;name&quot;)</span><br><span class="line">        val version = appObject.getString(&quot;version&quot;)</span><br><span class="line">        </span><br><span class="line">        println(&quot;App ID: $id, Name: $name, Version: $version&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-使用-Gson-解析-JSON"><a href="#4-2-使用-Gson-解析-JSON" class="headerlink" title="4.2 使用 Gson 解析 JSON"></a><strong>4.2 使用 Gson 解析 JSON</strong></h3><p><code>Gson</code> 是 Google 提供的 JSON 库，可用于对象与 JSON 之间的转换。</p><p><strong>添加依赖：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;com.google.code.gson:gson:2.8.9&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义数据类并解析 JSON：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import com.google.gson.Gson</span><br><span class="line">import com.google.gson.annotations.SerializedName</span><br><span class="line"></span><br><span class="line">// 定义数据类</span><br><span class="line">data class App(</span><br><span class="line">    val id: Int,</span><br><span class="line">    val name: String,</span><br><span class="line">    val version: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">data class AppList(</span><br><span class="line">    @SerializedName(&quot;apps&quot;) val apps: List&lt;App&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fun parseJsonWithGson(jsonData: String) &#123;</span><br><span class="line">    val gson = Gson()</span><br><span class="line">    val appList = gson.fromJson(jsonData, AppList::class.java)</span><br><span class="line">    </span><br><span class="line">    appList.apps.forEach &#123;</span><br><span class="line">        println(&quot;App ID: $&#123;it.id&#125;, Name: $&#123;it.name&#125;, Version: $&#123;it.version&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-解析流程"><a href="#5-解析流程" class="headerlink" title="5. 解析流程"></a>5. 解析流程</h2><ol><li><strong>选择解析方式</strong>（<code>org.json</code> 或 <code>Gson</code>）。</li><li><strong>解析 JSON 数据</strong>（对象映射或手动解析）。</li><li><strong>处理数据</strong>（存储、展示或操作）。</li></ol><h2 id="6-适用场景对比"><a href="#6-适用场景对比" class="headerlink" title="6. 适用场景对比"></a>6. 适用场景对比</h2><table><thead><tr><th>解析方式</th><th>适用场景</th><th>备注</th></tr></thead><tbody><tr><td><code>org.json</code></td><td>简单解析 JSON</td><td>适合临时处理，性能较低</td></tr><tr><td><code>Gson</code></td><td>解析 API 响应或本地 JSON 文件</td><td>易用，支持复杂对象映射</td></tr></tbody></table><h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p>对于 Kotlin 开发者，<strong>推荐使用</strong> <code>**Gson**</code>，它提供了更灵活的数据映射能力，适用于大多数 JSON 解析需求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAX解析XML数据用法示例</title>
      <link href="/2025/03/30/SAX%E8%A7%A3%E6%9E%90XML%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/30/SAX%E8%A7%A3%E6%9E%90XML%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>使用 SAX 解析 XML 数据</strong></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>SAX（Simple API for XML）是一种基于事件驱动的 XML 解析方式，适用于处理大规模 XML 文档。SAX 解析器不会将整个 XML 加载到内存中，而是逐行解析，因此在 <strong>性能和内存占用方面优于 DOM 解析</strong>。</p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h2><ul><li><strong>处理大 XML 文件</strong>（如 RSS 订阅、日志文件）</li><li><strong>流式解析</strong>（节省内存）</li><li><strong>只需读取数据</strong>（无需修改 XML 结构）</li></ul><h2 id="3-XML-示例"><a href="#3-XML-示例" class="headerlink" title="3. XML 示例"></a>3. XML 示例</h2><p>假设有如下 XML 数据 <code>sample.xml</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;apps&gt;</span><br><span class="line">    &lt;app id=&quot;1&quot;&gt;</span><br><span class="line">        &lt;name&gt;MyApp&lt;/name&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/app&gt;</span><br><span class="line">    &lt;app id=&quot;2&quot;&gt;</span><br><span class="line">        &lt;name&gt;AnotherApp&lt;/name&gt;</span><br><span class="line">        &lt;version&gt;2.3.4&lt;/version&gt;</span><br><span class="line">    &lt;/app&gt;</span><br><span class="line">&lt;/apps&gt;</span><br></pre></td></tr></table></figure><h2 id="4-SAX-解析步骤"><a href="#4-SAX-解析步骤" class="headerlink" title="4. SAX 解析步骤"></a>4. SAX 解析步骤</h2><h3 id="4-1-创建-ContentHandler-处理-XML"><a href="#4-1-创建-ContentHandler-处理-XML" class="headerlink" title="4.1 创建 ContentHandler 处理 XML"></a><strong>4.1 创建 ContentHandler 处理 XML</strong></h3><p>SAX 解析基于 <code>ContentHandler</code> 处理 XML 解析事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import android.util.Log</span><br><span class="line">import org.xml.sax.Attributes</span><br><span class="line">import org.xml.sax.helpers.DefaultHandler</span><br><span class="line"></span><br><span class="line">class AppContentHandler : DefaultHandler() &#123;</span><br><span class="line">    private var nodeName = &quot;&quot;</span><br><span class="line">    private lateinit var id: StringBuilder</span><br><span class="line">    private lateinit var name: StringBuilder</span><br><span class="line">    private lateinit var version: StringBuilder</span><br><span class="line"></span><br><span class="line">    override fun startDocument() &#123;</span><br><span class="line">        id = StringBuilder()</span><br><span class="line">        name = StringBuilder()</span><br><span class="line">        version = StringBuilder()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun startElement(uri: String?, localName: String?, qName: String?, attributes: Attributes?) &#123;</span><br><span class="line">        nodeName = localName ?: &quot;&quot;</span><br><span class="line">        if (localName == &quot;app&quot; &amp;&amp; attributes != null) &#123;</span><br><span class="line">            Log.d(&quot;AppContentHandler&quot;, &quot;App ID: $&#123;attributes.getValue(&quot;id&quot;)&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun characters(ch: CharArray?, start: Int, length: Int) &#123;</span><br><span class="line">        when (nodeName) &#123;</span><br><span class="line">            &quot;name&quot; -&gt; name.append(ch, start, length)</span><br><span class="line">            &quot;version&quot; -&gt; version.append(ch, start, length)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun endElement(uri: String?, localName: String?, qName: String?) &#123;</span><br><span class="line">        if (localName == &quot;app&quot;) &#123;</span><br><span class="line">            Log.d(&quot;AppContentHandler&quot;, &quot;App Name: $&#123;name.toString().trim()&#125;&quot;)</span><br><span class="line">            Log.d(&quot;AppContentHandler&quot;, &quot;App Version: $&#123;version.toString().trim()&#125;&quot;)</span><br><span class="line">            name.setLength(0)</span><br><span class="line">            version.setLength(0)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-在-Activity-或-Service-中使用-SAX-解析-XML"><a href="#4-2-在-Activity-或-Service-中使用-SAX-解析-XML" class="headerlink" title="4.2 在 Activity 或 Service 中使用 SAX 解析 XML"></a><strong>4.2 在 Activity 或 Service 中使用 SAX 解析 XML</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.xml.sax.InputSource</span><br><span class="line">import java.io.StringReader</span><br><span class="line">import javax.xml.parsers.SAXParserFactory</span><br><span class="line"></span><br><span class="line">fun parseXml(xmlData: String) &#123;</span><br><span class="line">    val factory = SAXParserFactory.newInstance()</span><br><span class="line">    val parser = factory.newSAXParser()</span><br><span class="line">    val xmlReader = parser.xmlReader</span><br><span class="line">    xmlReader.contentHandler = AppContentHandler()</span><br><span class="line">    xmlReader.parse(InputSource(StringReader(xmlData)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-调用解析函数"><a href="#4-3-调用解析函数" class="headerlink" title="4.3 调用解析函数"></a><strong>4.3 调用解析函数</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val xmlData = &quot;&quot;&quot;</span><br><span class="line">&lt;apps&gt;</span><br><span class="line">    &lt;app id=&quot;1&quot;&gt;</span><br><span class="line">        &lt;name&gt;MyApp&lt;/name&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/app&gt;</span><br><span class="line">    &lt;app id=&quot;2&quot;&gt;</span><br><span class="line">        &lt;name&gt;AnotherApp&lt;/name&gt;</span><br><span class="line">        &lt;version&gt;2.3.4&lt;/version&gt;</span><br><span class="line">    &lt;/app&gt;</span><br><span class="line">&lt;/apps&gt;</span><br><span class="line">&quot;&quot;&quot;.trimIndent()</span><br><span class="line"></span><br><span class="line">parseXml(xmlData)</span><br></pre></td></tr></table></figure><h2 id="5-解析流程"><a href="#5-解析流程" class="headerlink" title="5. 解析流程"></a>5. 解析流程</h2><ol><li><code>startDocument()</code> 初始化变量。</li><li><code>startElement()</code> 读取 <strong>标签名称</strong> 和 <strong>属性</strong>。</li><li><code>characters()</code> 读取 <strong>标签内文本</strong>。</li><li><code>endElement()</code> 处理 <strong>数据存储和输出</strong>。</li></ol><h2 id="6-优势与局限性"><a href="#6-优势与局限性" class="headerlink" title="6. 优势与局限性"></a>6. 优势与局限性</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>✔ <strong>内存占用低</strong>（适合大 XML 文件） ✔ <strong>解析速度快</strong>（基于流式处理） ✔ <strong>官方推荐</strong>（Android 内置支持）</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>✘ <strong>不支持随机访问</strong>（只能顺序解析） ✘ <strong>不适合修改 XML 结构</strong>（仅适用于读取数据）</p><h2 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a>7. 适用场景</h2><ul><li><strong>解析网络请求返回的 XML</strong></li><li><strong>处理 RSS 订阅数据</strong></li><li><strong>解析配置文件</strong>（如 <code>AndroidManifest.xml</code>）</li></ul><h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a>8. 结论</h2><p>SAX 解析是一种 <strong>高效且轻量</strong> 的 XML 处理方式，适用于 Android 开发，尤其是需要解析大 XML 数据时。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用XmlPullParser解析XML格式数据的用法示例</title>
      <link href="/2025/03/30/%E4%BD%BF%E7%94%A8XmlPullParser%E8%A7%A3%E6%9E%90XML%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/30/%E4%BD%BF%E7%94%A8XmlPullParser%E8%A7%A3%E6%9E%90XML%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>使用 XmlPullParser 解析 XML 格式数据（Kotlin 版）</strong></p><p>书上P438讲的很好，看书我觉得更好</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>XmlPullParser 是 Android 官方提供的轻量级 XML 解析器，适用于资源受限的移动设备。它基于流式解析，不会将整个 XML 加载到内存中，因此适用于大数据量的 XML 解析。</p><p><strong>额外知识—选择合适的解析方式：</strong></p><table><thead><tr><th>方式</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>SAX</td><td>大型 XML，逐行解析</td><td>低内存占用</td><td>编码复杂</td></tr><tr><td>DOM</td><td>小型 XML，需要修改</td><td>易用</td><td>内存占用大</td></tr><tr><td>XmlPullParser</td><td>轻量 XML 解析</td><td>性能高</td><td>手写解析代码</td></tr><tr><td>Simple XML</td><td>复杂 XML，映射对象</td><td>代码清晰</td><td>依赖第三方库</td></tr></tbody></table><p>如果你处理的是 Android 端 XML 解析，建议优先使用 <strong>XmlPullParser</strong>，如果 XML 结构复杂且需要映射对象，可以考虑 <strong>Simple XML</strong>。</p><h2 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2. 使用步骤"></a>2. 使用步骤</h2><h3 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h3><p>XmlPullParser 是 Android 自带的 API，因此无需额外添加依赖。</p><h3 id="2-2-XML-示例数据"><a href="#2-2-XML-示例数据" class="headerlink" title="2.2 XML 示例数据"></a>2.2 XML 示例数据</h3><p>假设我们有一个 XML 文件 <code>sample.xml</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;catalog&gt;</span><br><span class="line">    &lt;book id=&quot;1&quot;&gt;</span><br><span class="line">        &lt;title&gt;Android Development&lt;/title&gt;</span><br><span class="line">        &lt;author&gt;John Doe&lt;/author&gt;</span><br><span class="line">        &lt;price&gt;29.99&lt;/price&gt;</span><br><span class="line">    &lt;/book&gt;</span><br><span class="line">    &lt;book id=&quot;2&quot;&gt;</span><br><span class="line">        &lt;title&gt;Kotlin for Beginners&lt;/title&gt;</span><br><span class="line">        &lt;author&gt;Jane Smith&lt;/author&gt;</span><br><span class="line">        &lt;price&gt;35.50&lt;/price&gt;</span><br><span class="line">    &lt;/book&gt;</span><br><span class="line">&lt;/catalog&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-解析-XML-数据"><a href="#2-3-解析-XML-数据" class="headerlink" title="2.3 解析 XML 数据"></a>2.3 解析 XML 数据</h3><h4 id="2-3-1-创建-XmlPullParser-对象"><a href="#2-3-1-创建-XmlPullParser-对象" class="headerlink" title="2.3.1 创建 XmlPullParser 对象"></a>2.3.1 创建 XmlPullParser 对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val factory = XmlPullParserFactory.newInstance()</span><br><span class="line">val parser = factory.newPullParser()</span><br><span class="line">parser.setInput(xmlData.reader())</span><br></pre></td></tr></table></figure><h4 id="2-3-2-解析-XML"><a href="#2-3-2-解析-XML" class="headerlink" title="2.3.2 解析 XML"></a>2.3.2 解析 XML</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var eventType = parser.eventType</span><br><span class="line">var tagName: String?</span><br><span class="line">var title = &quot;&quot;</span><br><span class="line">var author = &quot;&quot;</span><br><span class="line">var price = &quot;&quot;</span><br><span class="line"></span><br><span class="line">while (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">    when (eventType) &#123;</span><br><span class="line">        XmlPullParser.START_TAG -&gt; &#123;</span><br><span class="line">            tagName = parser.name</span><br><span class="line">            when (tagName) &#123;</span><br><span class="line">                &quot;title&quot; -&gt; title = parser.nextText()</span><br><span class="line">                &quot;author&quot; -&gt; author = parser.nextText()</span><br><span class="line">                &quot;price&quot; -&gt; price = parser.nextText()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventType = parser.next()</span><br><span class="line">    </span><br><span class="line">    // 输出解析结果</span><br><span class="line">    if (title.isNotEmpty() &amp;&amp; author.isNotEmpty() &amp;&amp; price.isNotEmpty()) &#123;</span><br><span class="line">        println(&quot;Book: $title, Author: $author, Price: $price&quot;)</span><br><span class="line">        title = &quot;&quot;</span><br><span class="line">        author = &quot;&quot;</span><br><span class="line">        price = &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-解析流程解析"><a href="#3-解析流程解析" class="headerlink" title="3. 解析流程解析"></a>3. 解析流程解析</h2><ul><li><code>XmlPullParser.START_TAG</code>：检测到 XML 元素开始标签时，获取标签名。</li><li><code>parser.nextText()</code>：提取标签的文本内容。</li><li><code>XmlPullParser.END_DOCUMENT</code>：解析结束。</li></ul><h2 id="4-优势"><a href="#4-优势" class="headerlink" title="4. 优势"></a>4. 优势</h2><ul><li><strong>内存占用低</strong>：适用于大文件解析。</li><li><strong>速度快</strong>：只遍历一次 XML。</li><li><strong>原生支持</strong>：无需额外依赖。</li></ul><h2 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h2><ul><li>解析配置文件（如 <code>AndroidManifest.xml</code>）。</li><li>解析网络返回的 XML 数据。</li><li>解析 RSS 订阅数据。</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>XmlPullParser 是 Android 推荐的 XML 解析方式，适用于移动端高效处理 XML 数据。通过流式解析，可以显著降低内存占用，提高应用性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp的用法示例</title>
      <link href="/2025/03/29/OkHttp%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/29/OkHttp%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>OkHttp 是一个高效、灵活的 HTTP 客户端库，在 Android 开发中非常常用。下面介绍如何在 Android 中使用 OkHttp，并附上常见的 GET 和 POST 请求示例。</p><h2 id="1-添加-OkHttp-依赖"><a href="#1-添加-OkHttp-依赖" class="headerlink" title="1. 添加 OkHttp 依赖"></a><strong>1. 添加 <code>OkHttp</code> 依赖</strong></h2><p>如果你还没有添加 <code>OkHttp</code>，需要在 <code>build.gradle.kts</code> 添加依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;) // 最新版</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你用的是 <code>build.gradle</code>（Groovy 语法）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.squareup.okhttp3:okhttp:4.12.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-基本的-GET-请求-同步"><a href="#2-基本的-GET-请求-同步" class="headerlink" title="2. 基本的 GET 请求(同步)"></a><strong>2. 基本的 GET 请求(同步)</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import okhttp3.OkHttpClient</span><br><span class="line">import okhttp3.Request</span><br><span class="line">import okhttp3.Response</span><br><span class="line">import java.io.IOException</span><br><span class="line"></span><br><span class="line">fun sendGetRequest(): String? &#123;</span><br><span class="line">    val client = OkHttpClient() // 创建 OkHttpClient 实例</span><br><span class="line"></span><br><span class="line">    val request = Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/data&quot;) // 目标 URL</span><br><span class="line">        .get() // GET 请求</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    return try &#123;</span><br><span class="line">        val response: Response = client.newCall(request).execute() // 执行请求（同步）</span><br><span class="line">        if (response.isSuccessful) response.body?.string() else null</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3><ul><li><code>OkHttpClient</code>：创建 HTTP 客户端实例。</li><li><code>Request.Builder()</code>：构建 HTTP 请求。</li><li><code>.execute()</code>：执行 <strong>同步请求</strong>（会阻塞线程）。</li><li><code>response.body?.string()</code>：获取服务器返回的字符串。</li></ul><hr><h2 id="3-GET-请求（异步）"><a href="#3-GET-请求（异步）" class="headerlink" title="3. GET 请求（异步）"></a><strong>3. GET 请求（异步）</strong></h2><p>如果你不想阻塞主线程，可以使用 <strong>异步请求</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import okhttp3.*</span><br><span class="line">import java.io.IOException</span><br><span class="line">//callback 变量最终是用来将结果传递到最下面的回调函数里的，这个 回调函数 里的 result 就是 callback 传递的值</span><br><span class="line">fun sendGetRequestAsync(callback: (String?) -&gt; Unit) &#123;</span><br><span class="line">    val client = OkHttpClient()</span><br><span class="line">    val request = Request.Builder().url(&quot;https://api.example.com/data&quot;).build()</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(object : Callback &#123;</span><br><span class="line">        override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">            callback(null) // 发生错误，返回 null到下面回调函数的result中</span><br><span class="line">        &#125;</span><br><span class="line">        override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">            callback(response.body?.string()) // 请求成功，把返回的数据传递给回调函数中的result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用示例</span><br><span class="line">fun main() &#123;</span><br><span class="line">    sendGetRequestAsync &#123; result -&gt;</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            println(&quot;服务器返回数据：$result&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;请求失败&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li><code>.enqueue()</code>：使用异步请求，不会阻塞主线程。</li><li><strong>onFailure</strong>：请求失败时回调。</li><li><strong>onResponse</strong>：请求成功时回调，并返回数据。</li></ul><hr><h2 id="4-POST-请求（JSON-数据）"><a href="#4-POST-请求（JSON-数据）" class="headerlink" title="4. POST 请求（JSON 数据）"></a><strong>4. POST 请求（JSON 数据）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import okhttp3.MediaType.Companion.toMediaTypeOrNull</span><br><span class="line">import okhttp3.OkHttpClient</span><br><span class="line">import okhttp3.Request</span><br><span class="line">import okhttp3.RequestBody</span><br><span class="line">import okhttp3.Response</span><br><span class="line"></span><br><span class="line">fun sendPostRequest(json: String): String? &#123;</span><br><span class="line">    val client = OkHttpClient()</span><br><span class="line"></span><br><span class="line">    val requestBody = RequestBody.create(&quot;application/json&quot;.toMediaTypeOrNull(), json)//这里的json是传入的参数</span><br><span class="line"></span><br><span class="line">    val request = Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/login&quot;)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    return try &#123;</span><br><span class="line">        val response: Response = client.newCall(request).execute()</span><br><span class="line">        if (response.isSuccessful) response.body?.string() else null</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val jsonData = &quot;&quot;&quot;&#123;&quot;username&quot;:&quot;test&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&quot;&quot;&quot;</span><br><span class="line">val response = sendPostRequest(jsonData)</span><br><span class="line">println(&quot;服务器返回: $response&quot;)</span><br></pre></td></tr></table></figure><h3 id="异步版本POST请求"><a href="#异步版本POST请求" class="headerlink" title="异步版本POST请求"></a>异步版本POST请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import okhttp3.*</span><br><span class="line">import java.io.IOException</span><br><span class="line"></span><br><span class="line">fun sendPostRequestAsync(json: String, callback: (String?) -&gt; Unit) &#123;</span><br><span class="line">    val client = OkHttpClient()</span><br><span class="line"></span><br><span class="line">    // 创建请求体</span><br><span class="line">    val requestBody = RequestBody.create(&quot;application/json&quot;.toMediaTypeOrNull(), json)</span><br><span class="line"></span><br><span class="line">    // 创建请求</span><br><span class="line">    val request = Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/login&quot;)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    // 异步请求，使用 enqueue 发送请求</span><br><span class="line">    client.newCall(request).enqueue(object : Callback &#123;</span><br><span class="line">        override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">            callback(null)  // 请求失败，传递 null 给回调</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">            // 请求成功时，检查响应状态</span><br><span class="line">            if (response.isSuccessful) &#123;</span><br><span class="line">                callback(response.body?.string())  // 请求成功，传递响应内容给回调</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                callback(null)  // 如果请求不成功，传递 null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如何使用如下所示</span><br><span class="line">fun main() &#123;</span><br><span class="line">    val json = &quot;&quot;&quot;&#123;&quot;username&quot;:&quot;test&quot;, &quot;password&quot;:&quot;123456&quot;&#125;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    sendPostRequestAsync(json) &#123; result -&gt;</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            println(&quot;请求成功，返回数据：$result&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;请求失败&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="5-在-Android-里使用（结合协程）"><a href="#5-在-Android-里使用（结合协程）" class="headerlink" title="5. 在 Android 里使用（结合协程）"></a><strong>5. 在 Android 里使用（结合协程）</strong></h2><p>在 Android 开发中，推荐 <strong>协程+OkHttp</strong>，避免阻塞 UI 线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">suspend fun fetchData(): String? &#123;</span><br><span class="line">    return withContext(Dispatchers.IO) &#123;</span><br><span class="line">        val client = OkHttpClient()</span><br><span class="line">        val request = Request.Builder()</span><br><span class="line">            .url(&quot;https://api.example.com/data&quot;)</span><br><span class="line">            .get()</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            val response = client.newCall(request).execute()</span><br><span class="line">            if (response.isSuccessful) response.body?.string() else null</span><br><span class="line">        &#125; catch (e: IOException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">            null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-Activity-中调用"><a href="#在-Activity-中调用" class="headerlink" title="在 Activity 中调用"></a><strong>在 <code>Activity</code> 中调用</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    val data = fetchData()</span><br><span class="line">    textView.text = data // 更新 UI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>请求方式</th><th>方法</th><th>是否阻塞线程</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td><code>execute()</code></td><td>✅ <strong>同步（会阻塞）</strong></td></tr><tr><td><strong>GET（异步）</strong></td><td><code>enqueue()</code></td><td>❌ <strong>异步（不会阻塞）</strong></td></tr><tr><td><strong>POST</strong></td><td><code>execute()</code></td><td>✅ <strong>同步（会阻塞）</strong></td></tr><tr><td><strong>POST（协程）</strong></td><td><code>withContext(Dispatchers.IO)</code></td><td>✅ <strong>推荐（不会阻塞）</strong></td></tr></tbody></table><ul><li><strong>在 Android 里，推荐使用</strong>：<ul><li><strong><code>enqueue()</code></strong>（异步回调）</li><li><strong><code>withContext(Dispatchers.IO)</code></strong>（协程）</li></ul></li><li><strong>避免在主线程执行 <code>execute()</code>，否则会导致 ANR（应用无响应）</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HttpURLConnection的用法示例</title>
      <link href="/2025/03/29/HttpURLConnection%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/29/HttpURLConnection%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><code>HttpURLConnection</code> 是 Android 进行网络请求的一个轻量级 HTTP 客户端，适用于简单的 GET 和 POST 请求。以下是 <code>HttpURLConnection</code> 的基本使用方法。</p><hr><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a><strong>使用步骤</strong></h2><ol><li><strong>创建 URL 对象</strong></li><li><strong>打开连接并配置请求</strong></li><li><strong>发送请求</strong></li><li><strong>读取响应</strong></li><li><strong>关闭连接</strong></li></ol><hr><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="1-GET-请求"><a href="#1-GET-请求" class="headerlink" title="1. GET 请求"></a><strong>1. GET 请求</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.net.HttpURLConnection</span><br><span class="line">import java.net.URL</span><br><span class="line"></span><br><span class="line">fun sendGetRequest(urlString: String): String? &#123;</span><br><span class="line">    var connection: HttpURLConnection? = null</span><br><span class="line">    try &#123;</span><br><span class="line">        val url = URL(urlString)</span><br><span class="line">        connection = url.openConnection() as HttpURLConnection</span><br><span class="line">        connection.requestMethod = &quot;GET&quot;</span><br><span class="line">        connection.connectTimeout = 5000  // 超时时间</span><br><span class="line">        connection.readTimeout = 5000</span><br><span class="line">        connection.doInput = true  // 允许输入流</span><br><span class="line"></span><br><span class="line">        if (connection.responseCode == HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">            return connection.inputStream.bufferedReader().use &#123; it.readText() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        connection?.disconnect()  // 断开连接</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">val response = sendGetRequest(&quot;https://api.example.com/data&quot;)</span><br><span class="line">println(response)</span><br></pre></td></tr></table></figure><hr><h3 id="2-POST-请求"><a href="#2-POST-请求" class="headerlink" title="2. POST 请求"></a><strong>2. POST 请求</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.io.OutputStream</span><br><span class="line">import java.net.HttpURLConnection</span><br><span class="line">import java.net.URL</span><br><span class="line"></span><br><span class="line">fun sendPostRequest(urlString: String, postData: String): String? &#123;</span><br><span class="line">    var connection: HttpURLConnection? = null</span><br><span class="line">    try &#123;</span><br><span class="line">        val url = URL(urlString)</span><br><span class="line">        connection = url.openConnection() as HttpURLConnection</span><br><span class="line">        connection.requestMethod = &quot;POST&quot;</span><br><span class="line">        connection.connectTimeout = 5000</span><br><span class="line">        connection.readTimeout = 5000</span><br><span class="line">        connection.doOutput = true  // 允许输出流</span><br><span class="line">        connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;) // 发送 JSON 数据</span><br><span class="line"></span><br><span class="line">        // 发送数据</span><br><span class="line">        connection.outputStream.use &#123; os: OutputStream -&gt;</span><br><span class="line">            os.write(postData.toByteArray())</span><br><span class="line">            os.flush()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (connection.responseCode == HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">            return connection.inputStream.bufferedReader().use &#123; it.readText() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        connection?.disconnect()</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">val jsonBody = &quot;&quot;&quot;&#123;&quot;username&quot;:&quot;test&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&quot;&quot;&quot;</span><br><span class="line">val postResponse = sendPostRequest(&quot;https://api.example.com/login&quot;, jsonBody)</span><br><span class="line">println(postResponse)</span><br></pre></td></tr></table></figure><hr><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol><li><p><strong>网络请求必须在子线程执行</strong></p><ul><li>在 Android 9 及以上，主线程访问网络会抛出 <code>NetworkOnMainThreadException</code>。</li><li>可以使用 <code>Coroutine</code> 或 <code>Thread</code> 处理。</li></ul><p><strong>使用 <code>Coroutine</code> 进行网络请求</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line">suspend fun fetchData(): String? &#123;</span><br><span class="line">    return withContext(Dispatchers.IO) &#123; </span><br><span class="line">        sendGetRequest(&quot;https://api.example.com/data&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>fetchData()</code></strong></p><p><strong>不能在主线程直接调用 <code>fetchData()</code>，需要在协程中调用，例如：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        val result = fetchData()</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(6000) // 等待协程执行（仅示例用，实际开发不推荐）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>权限</strong></p><ul><li>在 <code>AndroidManifest.xml</code> 中添加权限：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>超时设置</strong></p><ul><li><code>connectTimeout</code> 和 <code>readTimeout</code> 防止请求长时间挂起。</li></ul></li></ol><hr><h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a><strong>替代方案</strong></h2><p>在 Android 现代开发中，建议使用 <code>OkHttp</code> 或 <code>Retrofit</code> 进行网络请求，<code>HttpURLConnection</code> 适用于轻量级请求或对库依赖要求较高的项目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Service用法示例</title>
      <link href="/2025/03/28/Service%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/28/Service%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="Service-是什么"><a href="#Service-是什么" class="headerlink" title="Service 是什么"></a>Service 是什么</h2><p>Service 是 Android 中实现程序后台运行的解决方案，它非常适合执行那些不需要和用户交互而 且还要求长期运行的任务。Service 的运行不依赖于任何用户界面，即使程序被切换到后台，或 者用户打开了另外一个应用程序，Service 仍然能够保持正常运行。</p><p>不过需要注意的是，Service 并不是运行在一个独立的进程当中的，而是依赖于创建 Service 时 所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的 Service 也会停止运行。</p><p>另外，也不要被 Service 的后台概念所迷惑，实际上 Service 并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在 Service 的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。</p><h2 id="Android-多线程编程"><a href="#Android-多线程编程" class="headerlink" title="Android 多线程编程"></a>Android 多线程编程</h2><p>当我们需要执行一些耗时操作，比如发 起一条网络请求时，考虑到网速等其他原因，服务器未必能够立刻响应我们的请求，如果不将 这类操作放在子线程里运行，就会导致主线程被阻塞，从而影响用户对软件的正常使用。</p><h3 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="线程的基本用法"></a>线程的基本用法</h3><p>义一 个线程只需要新建一个类继承自 Thread，然后重写父类的 run () 方法，并在里面编写耗时逻辑 即可，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyThread : Thread()&#123;</span><br><span class="line">    override fun run()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么该如何启动这个线程呢？其实很简单，只需要创建 MyThread 的实例，然后调用它的 start () 方法即可，这样 run () 方法中的代码就会在子线程当中运行了，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyThread().start()</span><br></pre></td></tr></table></figure><p>当然，使用继承的方式耦合性有点高，我们会更多地选择使用实现 Runnable 接口的方式来定义 一个线程，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyThread : Runnable &#123; </span><br><span class="line">     override fun run() &#123; </span><br><span class="line">        // 编写具体的逻辑 </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用了这种写法，启动线程的方法也需要进行相应的改变，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val myThread = MyThread() </span><br><span class="line">Thread(myThread).start() </span><br></pre></td></tr></table></figure><p>可以看到，Thread 的构造函数接收一个 Runnable 参数，而我们创建的 MyThread 实例正是一 个实现了 Runnable 接口的对象，所以可以直接将它传入 Thread 的构造函数里。接着调用 Thread 的 start () 方法，run () 方法中的代码就会在子线程当中运行了。</p><p>当然，如果你不想专门再定义一个类去实现 Runnable 接口，也可以使用 Lambda 的方式，这种 写法更为常见，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread &#123; </span><br><span class="line"> // 编写具体的逻辑 </span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><p>以上几种线程的使用方式你应该不会感到陌生，因为在 Java 中创建和启动线程也是使用同样的 方式。而 Kotlin 还给我们提供了一种更加简单的开启线程的方式，写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread &#123; </span><br><span class="line"> // 编写具体的逻辑 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 thread 是一个 Kotlin 内置的顶层函数，我们只需要在 Lambda 表达式中编写具体的逻辑 就可以了，连 start () 方法都不用调用，thread 函数在内部帮我们全部都处理好了。</p><h3 id="在子线程中更新-UI"><a href="#在子线程中更新-UI" class="headerlink" title="在子线程中更新 UI"></a>在子线程中更新 UI</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity()&#123;</span><br><span class="line">    val updateText = 1</span><br><span class="line">    lateinit var textView : TextView</span><br><span class="line">    </span><br><span class="line">    val handle = object : Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        override fun handleMessage(msg:Message)&#123;</span><br><span class="line">            when(msg.what)&#123;</span><br><span class="line">                updateText -&gt; textView.text = &quot;Nice to meet you&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onCreate(savedInstanceState : Bundle?)&#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        val binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        textView = binding.textView</span><br><span class="line">        val changeTextBtn = binding.changeTextBtn</span><br><span class="line">        changeTextBtn.setOnClickListener&#123;</span><br><span class="line">            thread&#123;</span><br><span class="line">                val msg = Message()</span><br><span class="line">                mag.what = updateText</span><br><span class="line">                handle.sendMessage(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析异步消息处理机制"><a href="#解析异步消息处理机制" class="headerlink" title="解析异步消息处理机制"></a>解析异步消息处理机制</h3><p>Android 中的异步消息处理主要由 4 个部分组成：Message、Handler、MessageQueue 和 Looper。</p><ul><li><p>Message</p><p>Message 是在线程之间传递的消息，它可以在内部携带少量的消息，用于在不同线程之间传递数据。</p></li><li><p>Handler</p><p>Handler 主要是用于发送和处理消息的，发出的消息经过一系列地辗转处理后，最终会传递到 Handler 的 handleMessage () 方法中</p></li><li><p>MessageQueue</p><p>MessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只有一个 MessageQueue 对象。</p></li><li><p>Looper</p><p>Looper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop () 方法后，就会进入一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息时，就会将它取出，并传递到 Handler 的 handleMessage () 方法中。每个线程中只会有一个 Looper 对象</p></li></ul><h4 id="异步消息处理流程"><a href="#异步消息处理流程" class="headerlink" title="异步消息处理流程"></a>异步消息处理流程</h4><p>首先需要在主线程当中创建一个 Handler 对象，并重写 handleMessage () 方法。然后当子线程中国需要进行 UI 操作时，就创建一个 Message 对象，并通过 Handler 将这条消息发送出去。之后这条消息就会被添加到 MessageQueue 的队列中等待被处理，而 Looper 则会一直尝试从 MessageQueue 中取出待处理消息，最后分发回 Handler 的 handleMessage () 方法中。由于 Handle 的构造函数中我们传入了 Looper.getMainLooper ()，所以此时 handleMessage () 方法中的代码也会在主线程中运行</p><h3 id="使用-AsyncTask"><a href="#使用-AsyncTask" class="headerlink" title="使用 AsyncTask"></a>使用 AsyncTask</h3><p>首先来看一下 AsyncTask 的基本用法。由于 AsyncTask 是一个抽象类，所以如果我们想使用 它，就必须创建一个子类去继承它。在继承时我们可以为 AsyncTask 类指定 3 个泛型参数，这 3 个参数的用途如下。</p><ul><li>Params。在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。</li><li>Progress。在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为单位进度</li><li>Result。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型</li></ul><p>因此，一个最简单的自定义 AsyncTask 就可以写成如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class DownloadTask : AsyncTask&lt;Unit, Int, Boolean&gt;() &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里我们把 AsyncTask 的第一个泛型参数指定为 Unit，表示在执行 AsyncTask 的时候不需要传 入参数给后台任务。第二个泛型参数指定为 Int，表示使用整型数据来作为进度显示单位。第三 个泛型参数指定为 Boolean，则表示使用布尔型数据来反馈执行结果。</p><p>当然，目前我们自定义的 DownloadTask 还是一个空任务，并不能进行任何实际的操作，我们 还需要重写 AsyncTask 中的几个方法才能完成对任务的定制。经常需要重写的方法有以下 4 个。</p><ul><li><p>onPreExecute()</p><p>这个方法回在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等</p></li><li><p>doInBackground(Params…)</p><p>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成，就可以通过 return 语句将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Unit，就可以不返回任务执行的结果注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress (Progress…) 方法来完成。</p></li><li><p>onProgressUpdate(Progress…)</p><p>当在后台任务中调用了 publishProgress (Progress…) 方法后， onProgressUpdate (Progress…) 方法就会很快被调用，该方法中携带的参数就是 在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对 界面元素进行相应的更新。</p></li><li><p>onPostExecute(Result)</p><p>当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数 据会作为参数传递到此方法中，可以利用返回的数据进行一些 UI 操作，比如说提醒任务执 行的结果，以及关闭进度条对话框等。</p></li></ul><h2 id="Service-的基本用法"><a href="#Service-的基本用法" class="headerlink" title="Service 的基本用法"></a>Service 的基本用法</h2><h3 id="定义一个-Service"><a href="#定义一个-Service" class="headerlink" title="定义一个 Service"></a>定义一个 Service</h3><p>首先看一下如何在项目中定义一个 Service。新建一个 ServiceTest 项目，然后右击 com.example.servicetest→New→Service→Service，</p><p>可以看到，这里我们将类名定义成 MyService，Exported 属性表示是否将这个 Service 暴露给 外部其他程序访问，Enabled 属性表示是否启用这个 Service。将两个属性都勾中，点 击 “Finish” 完成创建。</p><p>现在观察 MyService 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyService : Service() &#123; </span><br><span class="line"> </span><br><span class="line"> override fun onBind(intent: Intent): IBinder &#123; </span><br><span class="line">     TODO(&quot;Return the communication channel to the service.&quot;) </span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看到，MyService 是继承自系统的 Service 类的。目前 MyService 中可以算是空空如也， 但有一个 onBind () 方法特别醒目。这个方法是 Service 中唯一的抽象方法，所以必须在子类里 实现。我们会在后面的小节中使用到 onBind () 方法，目前可以暂时将它忽略。 既然是定义一个 Service，自然应该在 Service 中处理一些事情了，那处理事情的逻辑应该写在 哪里呢？这时就可以重写 Service 中的另外一些方法了，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyService : Service() &#123; </span><br><span class="line"> ... </span><br><span class="line"> override fun onCreate() &#123; </span><br><span class="line"> super.onCreate() </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int &#123; </span><br><span class="line"> return super.onStartCommand(intent, flags, startId) </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> override fun onDestroy() &#123; </span><br><span class="line"> super.onDestroy() </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们又重写了 onCreate ()、onStartCommand () 和 onDestroy () 这 3 个方 法，它们是每个 Service 中最常用到的 3 个方法了。其中 onCreate () 方法会在 Service 创建的 时候调用，onStartCommand () 方法会在每次 Service 启动的时候调用，onDestroy () 方法 会在 Service 销毁的时候调用。</p><p>通常情况下，如果我们希望 Service 一旦启动就立刻去执行某个动作，就可以将逻辑写在 onStartCommand () 方法里。而当 Service 销毁时，我们又应该在 onDestroy () 方法中回收 那些不再使用的资源。</p><h3 id="启动和停止-Service"><a href="#启动和停止-Service" class="headerlink" title="启动和停止 Service"></a>启动和停止 Service</h3><p>定义好了 Service 之后，接下来就应该考虑如何启动以及停止这个 Service。启动和停止的方法 当然你也不会陌生，主要是借助 Intent 来实现的。下面就让我们在 ServiceTest 项目中尝试启动 以及停止 MyService。</p><p>修改 MainActivity 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity()&#123;</span><br><span class="line">    override fun onCreate(savedInstanceState : Bundle?)&#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        val binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        val startServiceBtn = binding.startServiceBtn</span><br><span class="line">        val stopServiceBtn = binding.stopServiceBtn</span><br><span class="line">        startServiceBtn.setOnClickListener&#123;</span><br><span class="line">            val intent = Intent(this,MyService::class.java)</span><br><span class="line">            startService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">        stioServiceBtn.setOnCLickListener&#123;</span><br><span class="line">            val intent = Intent(this,Myservice::class.java)</span><br><span class="line">            stopService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OnCreate-方法和-onStartCommand-方法区别"><a href="#OnCreate-方法和-onStartCommand-方法区别" class="headerlink" title="OnCreate () 方法和 onStartCommand () 方法区别"></a>OnCreate () 方法和 onStartCommand () 方法区别</h4><p>onCreate () 方法是在 Service 第一次创建的时候调用的，而 onStartCommand () 方法则 在每次启动 Service 的时候都会调用。由于刚才我们是第一次点击 “Start Service” 按钮， Service 此时还未创建过，所以两个方法都会执行，之后如果你再连续多点击几次 “Start Service” 按钮，你就会发现只有 onStartCommand () 方法可以得到执行了。</p><h3 id="Activity-和-Service-进行通信"><a href="#Activity-和-Service-进行通信" class="headerlink" title="Activity 和 Service 进行通信"></a>Activity 和 Service 进行通信</h3><p>使用 onBind () 方法</p><p>比如说，目前我们希望在 MyService 里提供一个下载功能，然后在 Activity 中可以决定何时开始 下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的 Binder 对象来对下载功 能进行管理。修改 MyService 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyService : Service() &#123;</span><br><span class="line">    private val mBinder = DownloadBinder()</span><br><span class="line">    </span><br><span class="line">    class DownloadBinder : Binder()&#123;</span><br><span class="line">        </span><br><span class="line">        fun startDownload()&#123;</span><br><span class="line">            Log.d(&quot;MyService&quot;,&quot;startDownload executed&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fun getProgress() : Int &#123;</span><br><span class="line">            Log.d(&quot;MyService&quot;,&quot;getProgress executed&quot;)</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onBind(intent:Intent) : IBinder&#123;</span><br><span class="line">        return mBinder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们新建了一个 DownloadBinder 类，并让它继承自 Binder，然后在它的内 部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法，并没有实现真正的功 能，我们在这两个方法中分别打印了一行日志。</p><p>接着，在 MyService 中创建了 DownloadBinder 的实例，然后在 onBind () 方法里返回了这个 实例，这样 MyService 中的工作就全部完成了。</p><p>下面就要看一看在 Activity 中如何调用 Service 里的这些方法了。首先需要在布局文件里新增两 个按钮，修改 activity_main.xml 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class="line">     android:orientation=&quot;vertical&quot; </span><br><span class="line">     android:layout_width=&quot;match_parent&quot; </span><br><span class="line">     android:layout_height=&quot;match_parent&quot;&gt; </span><br><span class="line"></span><br><span class="line">         ... </span><br><span class="line"></span><br><span class="line">             &lt;Button </span><br><span class="line">                 android:id=&quot;@+id/bindServiceBtn&quot; </span><br><span class="line">                 android:layout_width=&quot;match_parent&quot; </span><br><span class="line">                 android:layout_height=&quot;wrap_content&quot; </span><br><span class="line">                 android:text=&quot;Bind Service&quot; /&gt; </span><br><span class="line"></span><br><span class="line">             &lt;Button </span><br><span class="line">                 android:id=&quot;@+id/unbindServiceBtn&quot; </span><br><span class="line">                 android:layout_width=&quot;match_parent&quot; </span><br><span class="line">                 android:layout_height=&quot;wrap_content&quot; </span><br><span class="line">                 android:text=&quot;Unbind Service&quot; /&gt; </span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>这两个按钮分别是用于绑定和取消绑定 Service 的，那到底谁需要和 Service 绑定呢？当然就是 Activity 了。当一个 Activity 和 Service 绑定了之后，就可以调用该 Service 里的 Binder 提供的 方法了。修改 MainActivity 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity()&#123;</span><br><span class="line">    lateinit var downloadBinder : MyService.DownloadBinder</span><br><span class="line">    </span><br><span class="line">    private val connection = object : ServiceConnection&#123;</span><br><span class="line">        override fun onServiceConnected(name:ComponentName,service:IBinder)&#123;</span><br><span class="line">            downloadBinder = service as MyService.DownloadBinder</span><br><span class="line">            downloadBinder.startDownload()</span><br><span class="line">            downloadBinder.getProgress()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        override fun onServiceDisconnected(name : ComponentName)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?)&#123;</span><br><span class="line">        、、、</span><br><span class="line">        bindServiceBtn.setOnClickListener&#123;</span><br><span class="line">            val intent = Intent(this, MyService::class.java)</span><br><span class="line">            bindService(intent,connection,Context.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line">        unbindServiceBtn.setOnClickListener&#123;</span><br><span class="line">            unbindService(connection)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service-的生命周期"><a href="#Service-的生命周期" class="headerlink" title="Service 的生命周期"></a>Service 的生命周期</h2><p>一旦在项目的任何位置调用了 Context 的 startService() 方法，相应的 Service 就会启动， 并回调 onStartCommand () 方法。如果这个 Service 之前还没有创建过，onCreate () 方法会 先于 onStartCommand () 方法执行。Service 启动了之后会一直保持运行状态，直到 stopService() 或 stopSelf () 方法被调用，或者被系统回收。注意，虽然每调用一次 startService() 方法，onStartCommand () 就会执行一次，但实际上每个 Service 只会存在 一个实例。所以不管你调用了多少次 startService() 方法，只需调用一次 stopService() 或 stopSelf () 方法，Service 就会停止。 另外，还可以调用 Context 的 bindService() 来获取一个 Service 的持久连接，这时就会回调 Service 中的 onBind () 方法。类似地，如果这个 Service 之前还没有创建过，onCreate () 方 法会先于 onBind () 方法执行。之后，调用方可以获取到 onBind () 方法里返回的 IBinder 对象 的实例，这样就能自由地和 Service 进行通信了。只要调用方和 Service 之间的连接没有断开， Service 就会一直保持运行状态，直到被系统回收。 当调用了 startService() 方法后，再去调用 stopService() 方法。这时 Service 中的 onDestroy () 方法就会执行，表示 Service 已经销毁了。类似地，当调用了 bindService() 方法后，再去调用 unbindService() 方法，onDestroy () 方法也会执行，这两种情况都很好 理解。但是需要注意，我们是完全有可能对一个 Service 既调用了 startService() 方法，又 调用了 bindService() 方法的，在这种情况下该如何让 Service 销毁呢？根据 Android 系统的 机制，一个 Service 只要被启动或者被绑定了之后，就会处于运行状态，必须要让以上两种条件 同时不满足，Service 才能被销毁。所以，这种情况下要同时调用 stopService() 和 unbindService() 方法，onDestroy () 方法才会执行。 这样你就把 Service 的生命周期完整地走了一遍。</p><h2 id="Service-的更多技巧"><a href="#Service-的更多技巧" class="headerlink" title="Service 的更多技巧"></a>Service 的更多技巧</h2><h3 id="使用前台-Service"><a href="#使用前台-Service" class="headerlink" title="使用前台 Service"></a>使用前台 Service</h3><p>修改 MyService 中的代 码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyService : Service()&#123;</span><br><span class="line">    、、、</span><br><span class="line">    override fun onCreate()&#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        Log.d(&quot;MyService&quot;,&quot;onCreate executed&quot;)</span><br><span class="line">        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager</span><br><span class="line">        if(Build.VERSION.SDK_INT &gt;= Build&gt;VERSION_CODES.0)&#123;</span><br><span class="line">            val channel = NotoficationManager(&quot;my_service&quot;,&quot;前台Service通知&quot;,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">            manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line">        val intent = Intent(this, MainActivity::class.java)</span><br><span class="line">        val pi = PendingIntent.getActivity(this,0,intent,0)</span><br><span class="line">        val notification = NotificationCompat.Builder(this,&quot;my_service&quot;)</span><br><span class="line">        .setContextTitle(&quot;This is content text&quot;)</span><br><span class="line">        .setSmallIcon(R.drawable.small_icon)</span><br><span class="line">        .setLargeIcon(BitmapFactory.decodeResource(resoruces,R.drabable.large_icon))</span><br><span class="line">        .setContentIntent(pi)</span><br><span class="line">        .build()</span><br><span class="line">        startForeground(1,notification)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 startForeground () 方法后就会让 MyService 变成一个前 台 Service，并在系统状态栏显示出来。</p><p>另外，从 Android 9.0 系统开始，使用前台 Service 必须在 AndroidManifest.xml 文件中进行权 限声明才行，而且如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class="line"> package=&quot;com.example.servicetest&quot;&gt; </span><br><span class="line">     &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;添加这个</span><br><span class="line">     &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_DATA_SYNC&quot;/&gt;/*添加这个，对应android:foregroundServiceType=&quot;dataSync&quot;所需要的权限*/</span><br><span class="line">         ... </span><br><span class="line">        &lt;service</span><br><span class="line">            android:name=&quot;.MyService&quot;</span><br><span class="line">            android:enabled=&quot;true&quot;</span><br><span class="line">            android:exported=&quot;false&quot;</span><br><span class="line">            android:foregroundServiceType=&quot;dataSync&quot;/&gt;/*添加这个属性，前台service一定要的，也可以是mediaPlayback等，但要添加相应的权限*/</span><br><span class="line">            ...</span><br><span class="line">&lt;/manifest&gt; </span><br></pre></td></tr></table></figure><p>现在即使你退出应用程序，MyService 也会一直处于运行状态，而且不用担心会被系统回收。 当然，MyService 所对应的通知也会一直显示在状态栏上面。如果用户不希望我们的程序一直 运行，也可以选择手动杀掉应用，这样 MyService 就会跟着一起停止运行了。</p><h3 id="使用-IntentService"><a href="#使用-IntentService" class="headerlink" title="使用 IntentService"></a>使用 IntentService</h3><p>Android 专门提供了一个 IntentService 类，这个类就很好地解决了前面所提到的两种尴尬，下面我们就来看一下它的用法。</p><p>新建一个 MyIntentService 类继承自 IntentService，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyIntentService : IntentService(&quot;MyIntentService&quot;)&#123;</span><br><span class="line">    override fun onHandleIntent(intent:Intent?)&#123;</span><br><span class="line">        //打印当前线程的id</span><br><span class="line">        Log.d(&quot;MyIntentService&quot;, &quot;Thread id is $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onDestroy()&#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        Log.d(&quot;MyIntentService&quot;,&quot;onDestroy executed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来修改 activity_main.xml 中的代码，加入一个用于启动 MyIntentService 的按钮，如下 所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class="line"> android:orientation=&quot;vertical&quot; </span><br><span class="line"> android:layout_width=&quot;match_parent&quot; </span><br><span class="line"> android:layout_height=&quot;match_parent&quot;&gt; </span><br><span class="line"> </span><br><span class="line">     ... </span><br><span class="line"></span><br><span class="line">     &lt;Button </span><br><span class="line">         android:id=&quot;@+id/startIntentServiceBtn&quot; </span><br><span class="line">         android:layout_width=&quot;match_parent&quot; </span><br><span class="line">         android:layout_height=&quot;wrap_content&quot; </span><br><span class="line">         android:text=&quot;Start IntentService&quot; /&gt; </span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt; </span><br></pre></td></tr></table></figure><p>然后修改 MainActivity 中的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity()&#123;</span><br><span class="line">    、、、</span><br><span class="line">    override fun onCreate(savedInstanceState:Bundle?)&#123;</span><br><span class="line">        、、、</span><br><span class="line">        startIntentServiceBtn.setOnClickListener&#123;</span><br><span class="line">            //打印主线程的id</span><br><span class="line">            Log.d(&quot;MainActivity&quot;,&quot;Thread id is $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">            val intent = Intent(this,MyIntentService::class.java)</span><br><span class="line">            startService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在 “Start IntentService” 按钮的点击事件里启动了 MyIntentService，并在这 里打印了一下主线程名，稍后用于和 IntentService 进行比对。你会发现，其实 IntentService 的启动方式和普通的 Service 没什么两样</p><p>最后不要忘记，Service 都是需要在 AndroidManifest.xml 里注册的，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">、、、</span><br><span class="line">&lt;service</span><br><span class="line">         android:name=&quot;MyIntentService&quot;</span><br><span class="line">         android:enabled=&quot;true&quot;</span><br><span class="line">         android:exported=&quot;true&quot;</span><br><span class="line">         /&gt;</span><br><span class="line">、、、</span><br></pre></td></tr></table></figure><h2 id="Kotlin-课堂：泛型的高级特性"><a href="#Kotlin-课堂：泛型的高级特性" class="headerlink" title="Kotlin 课堂：泛型的高级特性"></a>Kotlin 课堂：泛型的高级特性</h2><h3 id="对泛型进行实化"><a href="#对泛型进行实化" class="headerlink" title="对泛型进行实化"></a>对泛型进行实化</h3><p>那么具体该怎么写才能将泛型实化呢？首先，该函数必须是内联函数才行，也就是要用 inline 关键字来修饰该函数。其次，在声明泛型的地方必须加上 reified 关键字来表示该泛型要进行 实化。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; getGenericType() &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数中的泛型 T 就是一个被实化的泛型，因为它满足了内联函数和 reified 关键字这两个前 提条件。那么借助泛型实化，到底可以实现什么样的效果呢？从函数名就可以看出来了，这里 我们准备实现一个获取泛型实际类型的功能，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; getGenericType() = T::class.java </span><br></pre></td></tr></table></figure><p>虽然只有一行代码，但是这里却实现了一个 Java 中完全不可能实现的功能： getGenericType () 函数直接返回了当前指定泛型的实际类型。T.class 这样的语法在 Java 中是不合法的，而在 Kotlin 中，借助泛型实化功能就可以使用 T::class.java 这样的语法了</p><p>现在我们可以使用如下代码对 getGenericType () 函数进行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main() &#123; </span><br><span class="line">     val result1 = getGenericType&lt;String&gt;() </span><br><span class="line">     val result2 = getGenericType&lt;Int&gt;() </span><br><span class="line">     println(&quot;result1 is $result1&quot;) </span><br><span class="line">     println(&quot;result2 is $result2&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型实化的应用"><a href="#泛型实化的应用" class="headerlink" title="泛型实化的应用"></a>泛型实化的应用</h3><p>新建一个 reiﬁed.kt 文件，然后在里面编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; startActivity(context: Context) &#123; </span><br><span class="line">     val intent = Intent(context, T::class.java) </span><br><span class="line">     context.startActivity(intent) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个 startActivity () 函数，该函数接收一个 Context 参数，并同时使用 inline 和 reified 关键字让泛型 T 成为了一个被实化的泛型。接下来就是神奇的地方了， Intent 接收的第二个参数本来应该是一个具体 Activity 的 Class 类型，但由于现在 T 已经是一个 被实化的泛型了，因此这里我们可以直接传入 T::class.java。最后调用 Context 的 startActivity () 方法来完成 Activity 的启动</p><p>现在，如果我们想要启动 TestActivity，只需要这样写就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context) </span><br></pre></td></tr></table></figure><p>添加一个新的 startActivity () 函数重载，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; startActivity(context: Context, block: Intent.() -&gt; Unit) &#123; </span><br><span class="line">     val intent = Intent(context, T::class.java) </span><br><span class="line">     intent.block() </span><br><span class="line">     context.startActivity(intent) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看到，这次的 startActivity () 函数中增加了一个函数类型参数，并且它的函数类型是 定义在 Intent 类当中的。在创建完 Intent 的实例之后，随即调用该函数类型参数，并把 Intent 的 实例传入，这样调用 startActivity () 函数的时候就可以在 Lambda 表达式中为 Intent 传递 参数了，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context) &#123; </span><br><span class="line">     putExtra(&quot;param1&quot;, &quot;data&quot;) </span><br><span class="line">     putExtra(&quot;param2&quot;, 123) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WorkManager用法示例</title>
      <link href="/2025/03/28/WorkManager%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/28/WorkManager%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="WorkManager-是什么？"><a href="#WorkManager-是什么？" class="headerlink" title="WorkManager 是什么？"></a><strong>WorkManager 是什么？</strong></h2><p>WorkManager 是 Android 用来执行<strong>后台任务</strong>的工具，适用于：</p><ul><li><strong>执行一次</strong>的任务（比如：上传日志、备份数据）。</li><li><strong>定期执行</strong>的任务（比如：每 15 分钟同步数据）。</li><li><strong>即使应用关闭、设备重启后也能执行</strong>的任务。</li></ul><hr><h2 id="1-引入-WorkManager"><a href="#1-引入-WorkManager" class="headerlink" title="1. 引入 WorkManager"></a><strong>1. 引入 WorkManager</strong></h2><p>先在 <code>build.gradle.kts</code>（模块级）中添加依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;) // WorkManager 最新版</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 <strong>同步 Gradle</strong>（点击“Sync Now”）。</p><hr><h2 id="2-创建-Worker"><a href="#2-创建-Worker" class="headerlink" title="2. 创建 Worker"></a><strong>2. 创建 Worker</strong></h2><p>Worker 是 WorkManager 执行任务的地方。我们需要创建一个类，继承 <code>Worker</code> 或 <code>CoroutineWorker</code>（推荐）。</p><h3 id="简单任务示例"><a href="#简单任务示例" class="headerlink" title="简单任务示例"></a><strong>简单任务示例</strong></h3><p>新建一个 <code>MyWorker.kt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import android.util.Log</span><br><span class="line">import androidx.work.Worker</span><br><span class="line">import androidx.work.WorkerParameters</span><br><span class="line"></span><br><span class="line">class MyWorker(context: Context, workerParams: WorkerParameters) : Worker(context, workerParams) &#123;</span><br><span class="line">    override fun doWork(): Result &#123;</span><br><span class="line">        Log.d(&quot;MyWorker&quot;, &quot;后台任务正在执行...&quot;)</span><br><span class="line"></span><br><span class="line">        // 假设任务执行成功</span><br><span class="line">        return Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-在应用中启动-WorkManager"><a href="#3-在应用中启动-WorkManager" class="headerlink" title="3. 在应用中启动 WorkManager"></a><strong>3. 在应用中启动 WorkManager</strong></h2><p>在 <code>MainActivity.kt</code> 里启动这个任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.work.OneTimeWorkRequest</span><br><span class="line">import androidx.work.WorkManager</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        // 创建一个任务</span><br><span class="line">        val workRequest = OneTimeWorkRequest.Builder(MyWorker::class.java).build()</span><br><span class="line"></span><br><span class="line">        // 启动任务</span><br><span class="line">        WorkManager.getInstance(this).enqueue(workRequest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，每次启动应用，WorkManager 就会执行 <code>MyWorker</code> 里的代码。</p><hr><h2 id="4-传递参数"><a href="#4-传递参数" class="headerlink" title="4. 传递参数"></a><strong>4. 传递参数</strong></h2><p>如果 Worker 需要参数，比如<strong>下载文件的 URL</strong>，可以这样传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.work.Data</span><br><span class="line"></span><br><span class="line">val data = Data.Builder()</span><br><span class="line">    .putString(&quot;url&quot;, &quot;https://example.com/file.jpg&quot;)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">val workRequest = OneTimeWorkRequest.Builder(MyWorker::class.java)</span><br><span class="line">    .setInputData(data) // 传递参数</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(this).enqueue(workRequest)</span><br></pre></td></tr></table></figure><p>然后在 <code>MyWorker</code> 里接收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override fun doWork(): Result &#123;</span><br><span class="line">    val url = inputData.getString(&quot;url&quot;) ?: &quot;未提供 URL&quot;</span><br><span class="line">    Log.d(&quot;MyWorker&quot;, &quot;下载文件：$url&quot;)</span><br><span class="line"></span><br><span class="line">    return Result.success()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-周期性任务"><a href="#5-周期性任务" class="headerlink" title="5. 周期性任务"></a><strong>5. 周期性任务</strong></h2><p>如果任务需要<strong>定期执行</strong>（比如每 15 分钟备份数据），可以用 <code>PeriodicWorkRequest</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import androidx.work.PeriodicWorkRequest</span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">val periodicWorkRequest = PeriodicWorkRequest.Builder(MyWorker::class.java, 15, TimeUnit.MINUTES)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(this).enqueue(periodicWorkRequest)</span><br></pre></td></tr></table></figure><p>⚠️ <strong>注意</strong>：最小间隔是 <strong>15 分钟</strong>，不能更短！</p><hr><h2 id="6-任务约束（例如仅在-WiFi-下运行）"><a href="#6-任务约束（例如仅在-WiFi-下运行）" class="headerlink" title="6. 任务约束（例如仅在 WiFi 下运行）"></a><strong>6. 任务约束（例如仅在 WiFi 下运行）</strong></h2><p>可以加一些条件，比如：</p><ul><li>只有在 <strong>WiFi 连接</strong> 时运行。</li><li>只有在 <strong>充电状态</strong> 时运行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import androidx.work.Constraints</span><br><span class="line">import androidx.work.NetworkType</span><br><span class="line"></span><br><span class="line">val constraints = Constraints.Builder()</span><br><span class="line">    .setRequiredNetworkType(NetworkType.UNMETERED) // WiFi 才执行</span><br><span class="line">    .setRequiresCharging(true) // 充电时才执行</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">val workRequest = OneTimeWorkRequest.Builder(MyWorker::class.java)</span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(this).enqueue(workRequest)</span><br></pre></td></tr></table></figure><hr><h2 id="7-监听任务状态"><a href="#7-监听任务状态" class="headerlink" title="7. 监听任务状态"></a><strong>7. 监听任务状态</strong></h2><p>如果想知道任务是否执行成功，可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val workManager = WorkManager.getInstance(this)</span><br><span class="line">workManager.getWorkInfoByIdLiveData(workRequest.id).observe(this) &#123; workInfo -&gt;</span><br><span class="line">    if (workInfo != null) &#123;</span><br><span class="line">        when (workInfo.state) &#123;</span><br><span class="line">            WorkInfo.State.ENQUEUED -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务等待中&quot;)</span><br><span class="line">            WorkInfo.State.RUNNING -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务执行中&quot;)</span><br><span class="line">            WorkInfo.State.SUCCEEDED -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务成功&quot;)</span><br><span class="line">            WorkInfo.State.FAILED -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务失败&quot;)</span><br><span class="line">            WorkInfo.State.CANCELLED -&gt; Log.d(&quot;MyWorker&quot;, &quot;任务已取消&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8-取消任务"><a href="#8-取消任务" class="headerlink" title="8. 取消任务"></a><strong>8. 取消任务</strong></h2><p>可以随时取消任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(this).cancelWorkById(workRequest.id) // 取消某个任务</span><br><span class="line">WorkManager.getInstance(this).cancelAllWork() // 取消所有任务</span><br></pre></td></tr></table></figure><hr><h2 id="9-链式任务（Chained-Work）"><a href="#9-链式任务（Chained-Work）" class="headerlink" title="9. 链式任务（Chained Work）"></a>9. 链式任务（Chained Work）</h2><ul><li><p><strong>作用：</strong> 如果有多个任务需要依次执行，比如先下载数据再处理数据，可以把它们链接起来。</p></li><li><p><strong>简单例子：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val workA = OneTimeWorkRequestBuilder&lt;WorkerA&gt;().build()</span><br><span class="line">val workB = OneTimeWorkRequestBuilder&lt;WorkerB&gt;().build()</span><br><span class="line">val workC = OneTimeWorkRequestBuilder&lt;WorkerC&gt;().build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(context)</span><br><span class="line">    .beginWith(workA)   // 先执行 workA</span><br><span class="line">    .then(workB)        // workA 执行完后再执行 workB</span><br><span class="line">    .then(workC)        // workB 执行完后再执行 workC</span><br><span class="line">    .enqueue()          // 提交整个链条任务</span><br></pre></td></tr></table></figure><p>这样就能保证任务按照你设定的顺序依次完成。</p></li></ul><hr><h2 id="10-唯一任务（Unique-Work）"><a href="#10-唯一任务（Unique-Work）" class="headerlink" title="10. 唯一任务（Unique Work）"></a>10. 唯一任务（Unique Work）</h2><ul><li><p><strong>作用：</strong> 防止同样的任务重复执行。比如不希望同时有两个相同的任务在运行。</p></li><li><p><strong>简单例子：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val uniqueWorkRequest = OneTimeWorkRequestBuilder&lt;MyWorker&gt;().build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(context).enqueueUniqueWork(</span><br><span class="line">    &quot;uniqueTask&quot;,                  // 给任务起一个唯一的名字</span><br><span class="line">    ExistingWorkPolicy.REPLACE,    // 如果已有同名任务，替换掉旧的任务</span><br><span class="line">    uniqueWorkRequest</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用唯一任务可以确保同一时刻不会有多个相同任务重复运行。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>功能</th><th>代码</th></tr></thead><tbody><tr><td><strong>一次性任务</strong></td><td><code>OneTimeWorkRequest.Builder(MyWorker::class.java).build()</code></td></tr><tr><td><strong>周期性任务</strong></td><td><code>PeriodicWorkRequest.Builder(MyWorker::class.java, 15, TimeUnit.MINUTES).build()</code></td></tr><tr><td><strong>传递参数</strong></td><td><code>Data.Builder().putString(&quot;key&quot;, &quot;value&quot;).build()</code></td></tr><tr><td><strong>添加约束</strong></td><td><code>Constraints.Builder().setRequiredNetworkType(NetworkType.UNMETERED).build()</code></td></tr><tr><td><strong>监听任务状态</strong></td><td><code>workManager.getWorkInfoByIdLiveData(id).observe(...)</code></td></tr><tr><td><strong>取消任务</strong></td><td><code>WorkManager.getInstance(this).cancelWorkById(id)</code></td></tr></tbody></table><hr><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h2><ul><li><strong>一次性任务</strong>（如：上传日志、备份数据库）。</li><li><strong>定期任务</strong>（如：自动同步数据，每天上传一次）。</li><li><strong>后台任务</strong>（如：下载大文件）。</li><li><strong>任务可以应用退出后执行</strong>（如：应用关闭后仍继续备份数据）。</li></ul><p><strong>❌ WorkManager 不能做的事情</strong></p><ul><li><strong>定时精准任务</strong>（比如定点 3:00AM 运行，推荐用 <code>AlarmManager</code>）。</li><li><strong>即时任务</strong>（如果任务必须立刻完成，建议用 <code>ForegroundService</code>）。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AsyncTask的用法示例</title>
      <link href="/2025/03/27/AsyncTask%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/27/AsyncTask%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-中-AsyncTask-的使用教程"><a href="#Kotlin-中-AsyncTask-的使用教程" class="headerlink" title="Kotlin 中 AsyncTask 的使用教程"></a>Kotlin 中 AsyncTask 的使用教程</h1><p>AsyncTask 用于将耗时操作放到后台线程执行，同时在任务开始和结束时在主线程更新 UI。本文将逐步讲解其基本概念、生命周期方法，并提供一个简单的示例代码。</p><p>值得注意的是， 从 Android 11 开始，AsyncTask 已被弃用，建议在新项目中使用 Kotlin 协程、WorkManager 或其他异步方案，本文仅做学习记录使用，而且第一行代码P396 10.2.4讲的更详细更好。</p><hr><h2 id="1-AsyncTask-的基本概念"><a href="#1-AsyncTask-的基本概念" class="headerlink" title="1. AsyncTask 的基本概念"></a>1. AsyncTask 的基本概念</h2><p>AsyncTask 使用三个泛型参数来确定任务的输入、进度和结果类型：</p><ul><li><strong>Params</strong>：传递给任务的参数类型。</li><li><strong>Progress</strong>：任务执行中更新进度时使用的数据类型。</li><li><strong>Result</strong>：任务执行完毕后返回的结果类型。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class MyTask : AsyncTask&lt;Void, Int, String&gt;() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>表示该任务不需要输入参数（Void）、进度为 Int 类型、最终结果为 String。</p><hr><h2 id="2-AsyncTask-的生命周期方法"><a href="#2-AsyncTask-的生命周期方法" class="headerlink" title="2. AsyncTask 的生命周期方法"></a>2. AsyncTask 的生命周期方法</h2><p>AsyncTask 定义了多个回调方法，每个方法在任务执行的不同阶段被调用：</p><ul><li><strong>onPreExecute()</strong><br> 在任务开始前调用，通常用于初始化 UI（例如显示进度条）。</li><li><strong>doInBackground(vararg params: Params)</strong><br> 在后台线程中执行耗时操作。此方法不能直接更新 UI，但可以调用 <code>publishProgress()</code> 触发进度更新。</li><li><strong>onProgressUpdate(vararg values: Progress)</strong><br> 当调用 <code>publishProgress()</code> 时在主线程中执行，用于更新 UI 中的进度显示。</li><li><strong>onPostExecute(result: Result)</strong><br> 在后台任务执行完毕后调用，运行在主线程中，可以使用任务返回的结果更新 UI。</li><li><strong>onCancelled()</strong><br> 当任务被取消时调用，可用于清理操作。</li></ul><hr><h2 id="3-Kotlin-示例代码"><a href="#3-Kotlin-示例代码" class="headerlink" title="3. Kotlin 示例代码"></a>3. Kotlin 示例代码</h2><p>下面的示例展示了如何使用 AsyncTask 在后台模拟一个耗时任务（例如计数操作），并在 UI 上更新进度和显示结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import android.os.AsyncTask</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.widget.ProgressBar</span><br><span class="line">import android.widget.TextView</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var progressBar: ProgressBar</span><br><span class="line">    private lateinit var textView: TextView</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        progressBar = findViewById(R.id.progressBar)</span><br><span class="line">        textView = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">        // 传入一个整数参数，这个参数会被传递到doInBackground()方法当中，例如：10</span><br><span class="line">        MyTask().execute(10)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // MyTask 类继承自 AsyncTask&lt;Int, Int, String&gt;</span><br><span class="line">    private inner class MyTask : AsyncTask&lt;Int, Int, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        // 在任务开始前调用，通常用于初始化界面，比如显示进度条</span><br><span class="line">        override fun onPreExecute() &#123;</span><br><span class="line">            super.onPreExecute()</span><br><span class="line">            progressBar.progress = 0</span><br><span class="line">            textView.text = &quot;任务开始...&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 在后台线程中执行耗时操作</span><br><span class="line">        // params 数组中包含 execute() 方法传入的参数，这里我们只传入一个 Int 类型的参数</span><br><span class="line">        override fun doInBackground(vararg params: Int?): String &#123;</span><br><span class="line">            // 获取传入的参数值，假设它表示任务总步数</span><br><span class="line">            val totalSteps = params.firstOrNull() ?: 0</span><br><span class="line">            for (i in 1..totalSteps) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 模拟耗时操作，例如睡眠 1 秒</span><br><span class="line">                    Thread.sleep(1000)</span><br><span class="line">                &#125; catch (e: InterruptedException) &#123;</span><br><span class="line">                    e.printStackTrace()</span><br><span class="line">                &#125;</span><br><span class="line">                // 调用 publishProgress() 更新进度，触发 onProgressUpdate()</span><br><span class="line">                publishProgress(i)</span><br><span class="line">            &#125;</span><br><span class="line">            // 返回任务完成后的结果</span><br><span class="line">            return &quot;任务完成，共计 $totalSteps 秒&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 在主线程中接收并更新任务进度</span><br><span class="line">        override fun onProgressUpdate(vararg values: Int?) &#123;</span><br><span class="line">            super.onProgressUpdate(*values)</span><br><span class="line">            // 更新 ProgressBar 和 TextView 显示当前进度</span><br><span class="line">            values.firstOrNull()?.let &#123; progress -&gt;</span><br><span class="line">                progressBar.progress = progress * 100 / (intent.getIntExtra(&quot;TOTAL_STEPS&quot;, 10))</span><br><span class="line">                textView.text = &quot;当前进度: $progress/$&#123;intent.getIntExtra(&quot;TOTAL_STEPS&quot;, 10)&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 在任务执行完毕后调用，传入 doInBackground() 返回的结果</span><br><span class="line">        override fun onPostExecute(result: String?) &#123;</span><br><span class="line">            super.onPostExecute(result)</span><br><span class="line">            textView.text = result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 可选：任务取消时调用</span><br><span class="line">        override fun onCancelled() &#123;</span><br><span class="line">            super.onCancelled()</span><br><span class="line">            textView.text = &quot;任务取消&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ul><li><strong>onPreExecute()</strong><br> 初始化 ProgressBar 和 TextView 的显示状态。</li><li><strong>doInBackground()</strong><br> 在后台执行一个简单的循环操作，每次循环暂停 50 毫秒，并调用 <code>publishProgress()</code> 更新 UI 的进度。</li><li><strong>onProgressUpdate()</strong><br> 接收到进度后，在主线程更新 ProgressBar 和 TextView。</li><li><strong>onPostExecute()</strong><br> 当任务执行完毕后，显示完成消息。</li></ul><hr><h2 id="4-注意事项与最佳实践"><a href="#4-注意事项与最佳实践" class="headerlink" title="4. 注意事项与最佳实践"></a>4. 注意事项与最佳实践</h2><ul><li><strong>内存泄漏问题</strong><br> 如果 AsyncTask 是作为 Activity 的内部类存在，当 Activity 被销毁时可能导致内存泄漏。建议将 AsyncTask 定义为静态内部类，并通过 WeakReference 持有 Activity 的引用。</li><li><strong>执行策略</strong><br> 在 API 11（Android 3.0）及以上版本，AsyncTask 默认串行执行。如果需要并行执行，可以使用 <code>executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)</code>。</li><li><strong>已弃用提醒</strong><br> 从 Android 11 开始，AsyncTask 已被弃用，建议在新项目中使用 Kotlin 协程、WorkManager 或其他异步方案。</li></ul><hr><h2 id="5-为什么推荐-Kotlin-协程？"><a href="#5-为什么推荐-Kotlin-协程？" class="headerlink" title="5. 为什么推荐 Kotlin 协程？"></a>5. 为什么推荐 Kotlin 协程？</h2><ul><li><strong>代码简洁</strong><br> Kotlin 协程可以让异步代码写得像同步代码，减少回调层级和代码冗余。</li><li><strong>更好的错误处理与取消机制</strong><br> 协程内置了结构化并发，便于管理任务生命周期和异常处理。</li><li><strong>官方支持</strong><br> 谷歌和 JetBrains 都推荐在 Android 项目中使用 Kotlin 协程来处理异步任务。</li></ul><hr><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文详细介绍了在 Kotlin 中使用 AsyncTask 的方法，包括各个生命周期回调的作用和示例代码。虽然 AsyncTask 曾经为 Android 异步处理提供了简化方案，但随着技术的发展，Kotlin 协程已成为更推荐的选择。在学习 AsyncTask 的同时，建议大家尽快熟悉并尝试使用 Kotlin 协程以提升代码的简洁性和可维护性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>infix用法示例</title>
      <link href="/2025/03/26/inflix%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/26/inflix%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-infix-函数？"><a href="#什么是-infix-函数？" class="headerlink" title="什么是 infix 函数？"></a><strong>什么是 <code>infix</code> 函数？</strong></h3><p><code>infix</code> 关键字可以让 <strong>单参数的函数</strong> 以 <strong>更自然的语法</strong> 书写，使代码更易读。<br> 你可以把它理解为 <strong>一种特殊的调用方式</strong>，不需要 <code>.</code> 和 <code>()</code>，让代码像 <strong>自然语言</strong> 一样流畅。</p><p>要使用 <code>infix</code>，需要满足 <strong>三个条件</strong>：</p><ol><li><strong>必须是成员函数或扩展函数</strong>（它必须属于某个类或某种类型）。</li><li><strong>必须只有且只能有一个参数</strong>（如果有多个参数，就不能用 <code>infix</code>）。</li><li>⭐⭐⭐⭐⭐⭐<strong>调用时可以省略 <code>.</code> 和 <code>()</code></strong>（但仍然可以用 <code>.</code> 调用）。</li></ol><hr><h3 id="简单示例-1：数字比较"><a href="#简单示例-1：数字比较" class="headerlink" title="简单示例 1：数字比较"></a><strong>简单示例 1：数字比较</strong></h3><h4 id="不使用-infix"><a href="#不使用-infix" class="headerlink" title="不使用 infix"></a><strong>不使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun isBigger(a: Int, b: Int): Boolean &#123;</span><br><span class="line">    return a &gt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(isBigger(10, 5)) // 输出：true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数 <code>isBigger(10, 5)</code> 可读性一般，我们可以用 <code>infix</code> 改写它。</p><hr><h4 id="使用-infix"><a href="#使用-infix" class="headerlink" title="使用 infix"></a><strong>使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">infix fun Int.isBiggerThan(other: Int): Boolean &#123;</span><br><span class="line">    return this &gt; other</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(10 isBiggerThan 5) // 输出：true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <code>10 isBiggerThan 5</code> 读起来就像 <strong>自然语言</strong>，比 <code>isBigger(10, 5)</code> 更易懂。</p><hr><h3 id="简单示例-2：创建-“名字-值”-对"><a href="#简单示例-2：创建-“名字-值”-对" class="headerlink" title="简单示例 2：创建 “名字-值” 对"></a><strong>简单示例 2：创建 “名字-值” 对</strong></h3><h4 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a><strong>普通方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun pair(key: String, value: String): Pair&lt;String, String&gt; &#123;</span><br><span class="line">    return Pair(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val result = pair(&quot;name&quot;, &quot;Alice&quot;)</span><br><span class="line">    println(result) // 输出： (name, Alice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="使用-infix-1"><a href="#使用-infix-1" class="headerlink" title="使用 infix"></a><strong>使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">infix fun String.with(value: String): Pair&lt;String, String&gt; &#123;</span><br><span class="line">    return Pair(this, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val result = &quot;name&quot; with &quot;Alice&quot;</span><br><span class="line">    println(result) // 输出： (name, Alice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <code>&quot;name&quot; with &quot;Alice&quot;</code> 读起来更像 <strong>自然语言</strong>，比 <code>pair(&quot;name&quot;, &quot;Alice&quot;)</code> 更直观。</p><hr><h3 id="简单示例-3：自定义数学运算"><a href="#简单示例-3：自定义数学运算" class="headerlink" title="简单示例 3：自定义数学运算"></a><strong>简单示例 3：自定义数学运算</strong></h3><h4 id="普通加法"><a href="#普通加法" class="headerlink" title="普通加法"></a><strong>普通加法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    fun add(other: Point): Point &#123;</span><br><span class="line">        return Point(this.x + other.x, this.y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(2, 3)</span><br><span class="line">    val p2 = Point(4, 5)</span><br><span class="line">    val result = p1.add(p2)</span><br><span class="line"></span><br><span class="line">    println(&quot;($&#123;result.x&#125;, $&#123;result.y&#125;)&quot;) // 输出：(6, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="使用-infix-2"><a href="#使用-infix-2" class="headerlink" title="使用 infix"></a><strong>使用 <code>infix</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    infix fun add(other: Point): Point &#123;</span><br><span class="line">        return Point(this.x + other.x, this.y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(2, 3)</span><br><span class="line">    val p2 = Point(4, 5)</span><br><span class="line">    val result = p1 add p2  // 👈 重点：不需要 `.` 和 `()` 了！</span><br><span class="line"></span><br><span class="line">    println(&quot;($&#123;result.x&#125;, $&#123;result.y&#125;)&quot;) // 输出：(6, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <code>p1 add p2</code> <strong>比 <code>p1.add(p2)</code> 更像数学公式</strong>，可读性更强。</p><h4 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    infix fun Point.add(other: Point): Point &#123; //和正确例子唯一差别就是这一行</span><br><span class="line">        return Point(this.x + other.x, this.y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(2, 3)</span><br><span class="line">    val p2 = Point(4, 5)</span><br><span class="line">    val result = p1 add p2  // 👈 重点：不需要 . 和 () 了！</span><br><span class="line"></span><br><span class="line">    println(&quot;($&#123;result.x&#125;, $&#123;result.y&#125;)&quot;) // 输出：(6, 8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>不能编译</strong>，是因为 <strong>infix 函数不能在类内部对自身类型（<code>Point</code>）扩展</strong>。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><strong><code>infix</code> 让代码更像自然语言，增强可读性</strong>。</li><li><strong>只能用于</strong>：<ul><li><strong>类的成员函数</strong>（如 <code>Point</code> 里的 <code>add</code>）。</li><li><strong>扩展函数</strong>（如 <code>String.with()</code>）。</li><li><strong>且只接受一个参数</strong>。</li></ul></li><li><strong>调用时可以省略 <code>.</code> 和 <code>()</code></strong>，让代码更流畅。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide的基本用法</title>
      <link href="/2025/03/24/Glide%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-%E4%B8%80/"/>
      <url>/2025/03/24/Glide%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/guolin_blog/article/details/53759439">Glide用法一</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/53939176">Glide用法二</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/54895665">Glide用法三</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/70215985">Glide用法四</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/71524668">Glide用法五</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/72866313">Glide用法六</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/78357251">Glide用法七</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/78582548">Glide用法八</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Bitmap.createBitmap()用法示例</title>
      <link href="/2025/03/24/Android-Bitmap-createBitmap-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/24/Android-Bitmap-createBitmap-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-Bitmap-createBitmap-用法全解析"><a href="#Android-Bitmap-createBitmap-用法全解析" class="headerlink" title="Android Bitmap.createBitmap() 用法全解析"></a>Android Bitmap.createBitmap() 用法全解析</h1><p>在 Android 开发中，<code>Bitmap.createBitmap()</code> 是一个非常强大的方法，可以用来 <strong>创建新的位图</strong>，并且可以 <strong>进行旋转、缩放、平移、镜像翻转、裁剪等操作</strong>。本篇文章将详细介绍 <code>Bitmap.createBitmap()</code> 的各种用法。</p><hr><h2 id="1-Bitmap-createBitmap-基础用法"><a href="#1-Bitmap-createBitmap-基础用法" class="headerlink" title="1. Bitmap.createBitmap() 基础用法"></a>1. <code>Bitmap.createBitmap()</code> 基础用法</h2><h3 id="1-1-创建一个空白-Bitmap"><a href="#1-1-创建一个空白-Bitmap" class="headerlink" title="1.1 创建一个空白 Bitmap"></a><strong>1.1 创建一个空白 Bitmap</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)</span><br></pre></td></tr></table></figure><ul><li><code>width</code>：Bitmap 的宽度。</li><li><code>height</code>：Bitmap 的高度。</li><li><code>Bitmap.Config.ARGB_8888</code>：像素格式，支持透明度。</li></ul><blockquote><p><strong>用途</strong>：用于创建空白的 <code>Bitmap</code>，然后通过 <code>Canvas</code> 进行绘制。</p></blockquote><hr><h2 id="2-旋转（Rotate）"><a href="#2-旋转（Rotate）" class="headerlink" title="2. 旋转（Rotate）"></a>2. 旋转（Rotate）</h2><p>如果拍照后的图片方向不正确，可以使用 <code>Matrix</code> 进行旋转。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rotateBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, degree: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postRotate(degree.toFloat()) <span class="comment">// 旋转 degree 度</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>postRotate(degree)</code>：将图片旋转指定角度。</li></ul><p><strong>示例：旋转 90 度</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rotatedBitmap = rotateBitmap(originalBitmap, <span class="number">90</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="3-缩放（Scale）"><a href="#3-缩放（Scale）" class="headerlink" title="3. 缩放（Scale）"></a>3. 缩放（Scale）</h2><p>如果想要调整图片大小，可以使用 <code>postScale()</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scaleBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, sx: <span class="type">Float</span>, sy: <span class="type">Float</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postScale(sx, sy) <span class="comment">// 设置缩放比例</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：缩小 50%</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scaledBitmap = scaleBitmap(originalBitmap, <span class="number">0.5f</span>, <span class="number">0.5f</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="4-平移（Translate）"><a href="#4-平移（Translate）" class="headerlink" title="4. 平移（Translate）"></a>4. 平移（Translate）</h2><p>可以使用 <code>postTranslate()</code> 来移动 <code>Bitmap</code> 位置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">translateBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, dx: <span class="type">Float</span>, dy: <span class="type">Float</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postTranslate(dx, dy) <span class="comment">// X 方向右移 dx，Y 方向下移 dy</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：右移 50px，下移 100px</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> translatedBitmap = translateBitmap(originalBitmap, <span class="number">50f</span>, <span class="number">100f</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="5-镜像翻转（Flip）"><a href="#5-镜像翻转（Flip）" class="headerlink" title="5. 镜像翻转（Flip）"></a>5. 镜像翻转（Flip）</h2><h3 id="5-1-左右翻转（水平镜像）"><a href="#5-1-左右翻转（水平镜像）" class="headerlink" title="5.1 左右翻转（水平镜像）"></a><strong>5.1 左右翻转（水平镜像）</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">flipHorizontal</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postScale(-<span class="number">1f</span>, <span class="number">1f</span>) <span class="comment">// 水平方向镜像</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-上下翻转（垂直镜像）"><a href="#5-2-上下翻转（垂直镜像）" class="headerlink" title="5.2 上下翻转（垂直镜像）"></a><strong>5.2 上下翻转（垂直镜像）</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">flipVertical</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postScale(<span class="number">1f</span>, -<span class="number">1f</span>) <span class="comment">// 垂直方向镜像</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：左右翻转</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> flippedBitmap = flipHorizontal(originalBitmap)</span><br></pre></td></tr></table></figure><hr><h2 id="6-裁剪（Crop）"><a href="#6-裁剪（Crop）" class="headerlink" title="6. 裁剪（Crop）"></a>6. 裁剪（Crop）</h2><p>如果只想截取 <code>Bitmap</code> 的一部分，可以使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cropBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, x: <span class="type">Int</span>, y: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, x, y, width, height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：从 (50,50) 开始，裁剪 200x200 区域</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> croppedBitmap = cropBitmap(originalBitmap, <span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="7-综合变换：旋转-缩放-平移"><a href="#7-综合变换：旋转-缩放-平移" class="headerlink" title="7. 综合变换：旋转 + 缩放 + 平移"></a>7. 综合变换：旋转 + 缩放 + 平移</h2><p>可以组合多个变换，比如 <strong>先旋转 45°，再缩小 80%，然后平移</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transformBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">    matrix.postRotate(<span class="number">45f</span>)      <span class="comment">// 旋转 45 度</span></span><br><span class="line">    matrix.postScale(<span class="number">0.8f</span>, <span class="number">0.8f</span>) <span class="comment">// 缩小 80%</span></span><br><span class="line">    matrix.postTranslate(<span class="number">100f</span>, <span class="number">50f</span>) <span class="comment">// 右移 100，下移 50</span></span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height, matrix, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：应用组合变换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> transformedBitmap = transformBitmap(originalBitmap)</span><br></pre></td></tr></table></figure><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><table><thead><tr><th>操作</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td><strong>创建空白 Bitmap</strong></td><td><code>Bitmap.createBitmap(width, height, config)</code></td><td><code>Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888)</code></td></tr><tr><td><strong>旋转</strong></td><td><code>postRotate(degree)</code></td><td><code>postRotate(90f)</code></td></tr><tr><td><strong>缩放</strong></td><td><code>postScale(sx, sy)</code></td><td><code>postScale(0.5f, 0.5f)</code></td></tr><tr><td><strong>平移</strong></td><td><code>postTranslate(dx, dy)</code></td><td><code>postTranslate(50f, 100f)</code></td></tr><tr><td><strong>水平翻转</strong></td><td><code>postScale(-1f, 1f)</code></td><td><code>postScale(-1f, 1f)</code></td></tr><tr><td><strong>垂直翻转</strong></td><td><code>postScale(1f, -1f)</code></td><td><code>postScale(1f, -1f)</code></td></tr><tr><td><strong>裁剪</strong></td><td><code>Bitmap.createBitmap(bitmap, x, y, w, h)</code></td><td><code>Bitmap.createBitmap(bitmap, 50, 50, 200, 200)</code></td></tr></tbody></table><h3 id="📌-结论："><a href="#📌-结论：" class="headerlink" title="📌 结论："></a><strong>📌 结论：</strong></h3><p><code>Bitmap.createBitmap()</code> <strong>不仅能创建 Bitmap，还能旋转、缩放、平移、镜像翻转、裁剪，几乎所有图片变换都可以搞定！</strong> 🚀</p><p>希望这篇文章能帮你更好地理解 <code>Bitmap.createBitmap()</code> 的使用！ 😊</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通知的用法示例</title>
      <link href="/2025/03/24/%E9%80%9A%E7%9F%A5%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/24/%E9%80%9A%E7%9F%A5%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-通知（Notification）完全指南"><a href="#Android-通知（Notification）完全指南" class="headerlink" title="Android 通知（Notification）完全指南"></a><strong>Android 通知（Notification）完全指南</strong></h2><p><strong>记得在测试APP的通知功能时，要在手机上把关于通知的权限打开!!!</strong></p><h3 id="1-通知的作用"><a href="#1-通知的作用" class="headerlink" title="1. 通知的作用"></a><strong>1. 通知的作用</strong></h3><ul><li><strong>用户提示</strong>：告知用户重要事件，如新消息、下载进度等。</li><li><strong>交互入口</strong>：用户点击通知可跳转至应用的特定页面。</li><li><strong>持续展示</strong>：某些通知需要常驻状态栏，如后台任务提醒。</li></ul><hr><h3 id="2-关键组件"><a href="#2-关键组件" class="headerlink" title="2. 关键组件"></a><strong>2. 关键组件</strong></h3><ul><li><strong>NotificationManager</strong>：管理通知的发布、更新、取消。</li><li><strong>NotificationCompat.Builder</strong>：构建通知，确保兼容低版本 Android。</li><li><strong>NotificationChannel（Android 8.0+）</strong>：管理通知的重要性、声音、震动等。</li><li><strong>PendingIntent</strong>：设定用户点击通知后的操作。</li></ul><hr><h3 id="3-创建通知"><a href="#3-创建通知" class="headerlink" title="3. 创建通知"></a><strong>3. 创建通知</strong></h3><h4 id="3-0-权限"><a href="#3-0-权限" class="headerlink" title="3.0 权限"></a><strong>3.0 权限</strong></h4><p>在 <strong>AndroidManifest.xml</strong> 添加权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.POST_NOTIFICATIONS&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-创建通知频道（Android-8-0-必须）"><a href="#3-1-创建通知频道（Android-8-0-必须）" class="headerlink" title="3.1 创建通知频道（Android 8.0+ 必须）"></a><strong>3.1 创建通知频道（Android 8.0+ 必须）</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    <span class="keyword">val</span> channelId = <span class="string">&quot;channel_id_example&quot;</span></span><br><span class="line">    <span class="keyword">val</span> channelName = <span class="string">&quot;通知频道&quot;</span></span><br><span class="line">    <span class="keyword">val</span> importance = NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">    <span class="keyword">val</span> channel = NotificationChannel(channelId, channelName, importance).apply &#123;</span><br><span class="line">        description = <span class="string">&quot;这个频道用于普通通知&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager这个写法和下面一行本质一样的，下面的更简洁安全，上面的能兼容旧版本(适用API22以及更早版本)*/</span></span><br><span class="line">    <span class="keyword">val</span> notificationManager = getSystemService(NotificationManager::<span class="keyword">class</span>.java)</span><br><span class="line">    notificationManager.createNotificationChannel(channel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-发送基础通知"><a href="#3-2-发送基础通知" class="headerlink" title="3.2 发送基础通知"></a><strong>3.2 发送基础通知</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channelId = <span class="string">&quot;channel_id_example&quot;</span></span><br><span class="line"><span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">    .setSmallIcon(R.drawable.ic_notification)</span><br><span class="line">    .setContentTitle(<span class="string">&quot;通知标题&quot;</span>)</span><br><span class="line">    .setContentText(<span class="string">&quot;通知内容&quot;</span>)</span><br><span class="line">    .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">notificationManager.notify(<span class="number">1</span>, builder.build())<span class="comment">/*通过 NotificationManager 显示通知。1 作为通知的 唯一 ID，用于标识和更新/取消特定通知。builder.build() 构建通知对象 并发送。*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-添加交互（PendingIntent）"><a href="#4-添加交互（PendingIntent）" class="headerlink" title="4. 添加交互（PendingIntent）"></a><strong>4. 添加交互（PendingIntent）</strong></h3><h4 id="4-1-点击通知跳转到-Activity"><a href="#4-1-点击通知跳转到-Activity" class="headerlink" title="4.1 点击通知跳转到 Activity"></a><strong>4.1 点击通知跳转到 Activity</strong></h4><p>创建一个 <code>TargetActivity</code> 作为跳转目标：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TargetActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改通知代码，添加 <code>PendingIntent</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, TargetActivity::<span class="keyword">class</span>.java)</span><br><span class="line"><span class="keyword">val</span> pendingIntent = PendingIntent.getActivity(</span><br><span class="line">    <span class="keyword">this</span>, <span class="number">0</span>, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> builder = NotificationCompat.Builder(<span class="keyword">this</span>, channelId)</span><br><span class="line">    .setSmallIcon(R.drawable.ic_notification)</span><br><span class="line">    .setContentTitle(<span class="string">&quot;点击查看详情&quot;</span>)</span><br><span class="line">    .setContentText(<span class="string">&quot;点击此通知跳转到 TargetActivity&quot;</span>)</span><br><span class="line">    .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">    .setContentIntent(pendingIntent)</span><br><span class="line">    .setAutoCancel(<span class="literal">true</span>) <span class="comment">// 用户点击后自动清除通知</span></span><br><span class="line"></span><br><span class="line">notificationManager.notify(<span class="number">2</span>, builder.build())</span><br></pre></td></tr></table></figure><hr><h3 id="5-丰富通知内容（setStyle）"><a href="#5-丰富通知内容（setStyle）" class="headerlink" title="5. 丰富通知内容（setStyle）"></a><strong>5. 丰富通知内容（setStyle）</strong></h3><h4 id="5-1-长文本通知（BigTextStyle）"><a href="#5-1-长文本通知（BigTextStyle）" class="headerlink" title="5.1 长文本通知（BigTextStyle）"></a><strong>5.1 长文本通知（BigTextStyle）</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.setStyle(NotificationCompat.BigTextStyle()</span><br><span class="line">    .bigText(<span class="string">&quot;这里是详细的通知内容，适合展示更多的文字信息&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="5-2-大图通知（BigPictureStyle）"><a href="#5-2-大图通知（BigPictureStyle）" class="headerlink" title="5.2 大图通知（BigPictureStyle）"></a><strong>5.2 大图通知（BigPictureStyle）</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bigPicture = BitmapFactory.decodeResource(resources, R.drawable.big_image)</span><br><span class="line">builder.setStyle(NotificationCompat.BigPictureStyle()</span><br><span class="line">    .bigPicture(bigPicture)</span><br><span class="line">    .setBigContentTitle(<span class="string">&quot;大图通知&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="5-3-多条信息通知（InboxStyle）"><a href="#5-3-多条信息通知（InboxStyle）" class="headerlink" title="5.3 多条信息通知（InboxStyle）"></a><strong>5.3 多条信息通知（InboxStyle）</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.setStyle(NotificationCompat.InboxStyle()</span><br><span class="line">    .addLine(<span class="string">&quot;第一条信息&quot;</span>)</span><br><span class="line">    .addLine(<span class="string">&quot;第二条信息&quot;</span>)</span><br><span class="line">    .setSummaryText(<span class="string">&quot;共2条信息&quot;</span>))</span><br></pre></td></tr></table></figure><hr><h3 id="6-高级用法"><a href="#6-高级用法" class="headerlink" title="6. 高级用法"></a><strong>6. 高级用法</strong></h3><ul><li><strong>自定义通知布局</strong>：使用 <code>RemoteViews</code> 创建个性化界面。</li><li><strong>前台服务通知</strong>：后台任务运行时显示不可清除的通知。</li><li><strong>分组通知</strong>：合并多个相关通知，减少干扰。</li></ul><hr><h3 id="7-重要注意事项"><a href="#7-重要注意事项" class="headerlink" title="7. 重要注意事项"></a><strong>7. 重要注意事项</strong></h3><ul><li><strong>Android 8.0+ 必须使用 NotificationChannel，否则通知不会显示。</strong></li><li><strong>使用 NotificationCompat 确保低版本 Android 兼容性。</strong></li><li><strong>合理管理通知，避免频繁弹出影响用户体验。</strong></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过 <strong>NotificationManager</strong> 发送通知，使用 <strong>PendingIntent</strong> 响应点击操作，并通过 <strong>setStyle</strong> 增强通知的可读性和交互性。在 Android 8.0 及以上版本，必须创建 <strong>NotificationChannel</strong>，确保通知正常显示。结合这些技巧，可以打造更优雅、实用的通知系统。 🚀</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ContentProvider+ContentResolver+UriMatcher+SQLite的用法示例</title>
      <link href="/2025/03/19/ContentProvider-ContentResolver-UriMatcher%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/19/ContentProvider-ContentResolver-UriMatcher%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>在 Android 中，数据共享是应用开发中非常重要的一部分。为了在不同应用之间共享数据，Android 提供了 <strong>ContentProvider</strong> 机制，通过该机制，应用能够访问其他应用的数据或向其他应用提供自己的数据。结合 <strong>SQLite</strong> 数据库、<strong>ContentProvider</strong>、<strong>ContentResolver</strong> 和 <strong>UriMatcher</strong>，我们可以方便地实现数据的持久化存储、查询、插入、更新和删除操作，同时还能够保证数据访问的安全性。</p><p>本文将介绍如何结合 <strong>SQLite</strong> 数据库、<strong>ContentProvider</strong>、<strong>ContentResolver</strong> 和 <strong>UriMatcher</strong> 实现一个完整的应用数据共享系统，并通过一个具体的示例进行详细说明。</p><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><h3 id="2-1-SQLite-数据库"><a href="#2-1-SQLite-数据库" class="headerlink" title="2.1 SQLite 数据库"></a>2.1 SQLite 数据库</h3><p>SQLite 是 Android 中推荐的本地数据库，它是一个轻量级的关系型数据库管理系统。SQLite 可以嵌入到应用中，支持 SQL 查询、数据持久化存储。</p><ul><li><strong>优点</strong>：开销小、无需服务器，适合单机应用。</li><li><strong>缺点</strong>：功能相对较简单，适用于小型应用和中小规模的数据存储。</li></ul><h3 id="2-2-ContentProvider"><a href="#2-2-ContentProvider" class="headerlink" title="2.2 ContentProvider"></a>2.2 ContentProvider</h3><p>ContentProvider 是一个提供数据存取接口的组件。它允许不同的应用共享数据，支持跨进程调用和跨应用访问。ContentProvider 通过 URI（统一资源标识符）来标识数据资源，并通过 SQL 查询操作来处理数据。</p><ul><li><strong>方法</strong>：<code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code>、<code>getType()</code> 等。</li><li><strong>作用</strong>：提供统一的接口，允许不同应用之间共享数据，避免直接暴露内部数据库结构。</li></ul><h3 id="2-3-ContentResolver"><a href="#2-3-ContentResolver" class="headerlink" title="2.3 ContentResolver"></a>2.3 ContentResolver</h3><p>ContentResolver 是一个访问 ContentProvider 的接口。通过 ContentResolver，我们可以向 ContentProvider 发起查询、插入、更新和删除操作。</p><ul><li><strong>方法</strong>：<code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code> 等。</li><li><strong>作用</strong>：通过 ContentResolver，应用可以操作 ContentProvider 中的数据，不需要知道数据存储的具体实现细节。</li><li><a href="https://goshenc.github.io/2025/03/17/ContentResolver%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/">ContentResolver的增删改查方法示例 | GoshenC</a></li></ul><h3 id="2-4-UriMatcher"><a href="#2-4-UriMatcher" class="headerlink" title="2.4 UriMatcher"></a>2.4 UriMatcher</h3><p>UriMatcher 是一个帮助 ContentProvider 匹配 URI 的工具，它根据 URI 的路径来判断进行操作的数据表或者数据项。通过 UriMatcher，我们可以根据传入的 URI 判断用户请求的是整个数据表的数据，还是某一条特定的数据记录。</p><ul><li><strong>作用</strong>：根据 URI 匹配不同的数据处理操作，帮助 ContentProvider 做出正确的响应。</li></ul><h3 id="2-5-概念及它们之间的关系"><a href="#2-5-概念及它们之间的关系" class="headerlink" title="2.5 概念及它们之间的关系"></a>2.5 概念及它们之间的关系</h3><ul><li><p><strong>ContentProvider</strong></p><ul><li><strong>作用</strong>：用于对外暴露应用的数据（例如 SQLite 数据库、文件等），支持跨进程或跨应用数据共享。</li><li><strong>关键方法</strong>：<code>onCreate()</code>（初始化）、<code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code>、<code>getType()</code>。</li></ul></li><li><p><strong>UriMatcher</strong></p><ul><li><strong>作用</strong>：帮助 ContentProvider 根据传入的 URI 判断需要操作的数据类型或数据集合。</li><li><strong>工作原理</strong>：预先注册一系列 URI 模式，每个模式对应一个整数代码；在请求时根据 URI 返回相应代码，以便在代码中进行判断和分支处理。</li></ul></li><li><p><strong>ContentResolver</strong></p><ul><li><p><strong>作用</strong>：作为数据访问者，由外部（或本应用内其他组件）调用，用于向 ContentProvider 发送数据操作请求（如查询、插入等）。</p></li><li><p>使用方式</p><p>：直接在 Activity、Service 等继承了 Context 的组件中调用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>这三者一起工作，实现了应用间（或应用内）的数据共享：</p><ol><li><strong>ContentResolver</strong> 发起请求，传入一个 URI。</li><li><strong>ContentProvider</strong> 通过内部的 <strong>UriMatcher</strong> 匹配 URI，判断请求的数据类型。</li><li>根据匹配结果，<strong>ContentProvider</strong> 调用相应的数据库操作，并返回数据（Cursor、Uri、影响行数等）。</li></ol><h2 id="3-使用-SQLite-ContentProvider-ContentResolver-UriMatcher-实现数据共享"><a href="#3-使用-SQLite-ContentProvider-ContentResolver-UriMatcher-实现数据共享" class="headerlink" title="3. 使用 SQLite + ContentProvider + ContentResolver + UriMatcher 实现数据共享"></a>3. 使用 SQLite + ContentProvider + ContentResolver + UriMatcher 实现数据共享</h2><h3 id="3-1-数据库实现"><a href="#3-1-数据库实现" class="headerlink" title="3.1 数据库实现"></a>3.1 数据库实现</h3><p>首先，我们需要创建一个 SQLite 数据库并定义数据表。下面是一个简单的 SQLiteOpenHelper 类，它管理一个名为 <code>diary</code> 的表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DiaryDatabaseHelper(context: Context) : SQLiteOpenHelper(context, &quot;DiaryDB&quot;, null, 1) &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase) &#123;</span><br><span class="line">        val createTableSQL = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE diary (</span><br><span class="line">                id INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                title TEXT,</span><br><span class="line">                date INTEGER,</span><br><span class="line">                content TEXT</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;.trimIndent()</span><br><span class="line">        db.execSQL(createTableSQL)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        db.execSQL(&quot;DROP TABLE IF EXISTS diary&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个数据库中，<code>diary</code> 表包含 <code>id</code>（主键）、<code>title</code>（标题）、<code>date</code>（日期）和 <code>content</code>（内容）等字段。</p><h3 id="3-2-ContentProvider-实现"><a href="#3-2-ContentProvider-实现" class="headerlink" title="3.2 ContentProvider 实现"></a>3.2 ContentProvider 实现</h3><p>接下来，我们要实现一个 ContentProvider，它将使用我们刚刚定义的数据库。通过 ContentProvider，外部应用可以通过 URI 来访问我们提供的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class DiaryProvider : ContentProvider() &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val AUTHORITY = &quot;com.example.providerdemo.diaryprovider&quot;</span><br><span class="line">        const val TABLE_DIARY = &quot;diary&quot;</span><br><span class="line">        val CONTENT_URI: Uri = Uri.parse(&quot;content://$AUTHORITY/$TABLE_DIARY&quot;)</span><br><span class="line">        const val DIARY_DIR = 1</span><br><span class="line">        const val DIARY_ITEM = 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private lateinit var dbHelper: DiaryDatabaseHelper</span><br><span class="line">    private val uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply &#123;</span><br><span class="line">        addURI(AUTHORITY, TABLE_DIARY, DIARY_DIR)</span><br><span class="line">        </span><br><span class="line">  /*DIARY_Dir是一个整数值，用来标识这个 URI 模式对应的操作。在后面的 ContentProvider 中，我们会使用这个整数值来确定执行哪些操作（例如查询、插入、更新、删除等）。DIARY_1Dir 是你在代码中定义的常量。比如后面的return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt;...&#125;*/</span><br><span class="line">            </span><br><span class="line">        addURI(AUTHORITY, &quot;$TABLE_DIARY/#&quot;, DIARY_ITEM)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(): Boolean &#123;</span><br><span class="line">        dbHelper = DiaryDatabaseHelper(context!!)</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun query(uri: Uri, projection: Array&lt;String&gt;?, selection: String?, selectionArgs: Array&lt;String&gt;?, sortOrder: String?): Cursor? &#123;</span><br><span class="line">        val db = dbHelper.readableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; db.query(TABLE_DIARY, projection, selection, selectionArgs, null, null, sortOrder)</span><br><span class="line">            DIARY_ITEM -&gt; &#123;</span><br><span class="line">                val id = uri.lastPathSegment</span><br><span class="line">                db.query(TABLE_DIARY, projection, &quot;id=?&quot;, arrayOf(id), null, null, sortOrder)</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun insert(uri: Uri, values: ContentValues?): Uri? &#123;</span><br><span class="line">        val db = dbHelper.writableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; &#123;</span><br><span class="line">                val id = db.insert(TABLE_DIARY, null, values)</span><br><span class="line">                Uri.withAppendedPath(CONTENT_URI, id.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun update(uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array&lt;String&gt;?): Int &#123;</span><br><span class="line">        val db = dbHelper.writableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; db.update(TABLE_DIARY, values, selection, selectionArgs)</span><br><span class="line">            DIARY_ITEM -&gt; &#123;</span><br><span class="line">                val id = uri.lastPathSegment</span><br><span class="line">                db.update(TABLE_DIARY, values, &quot;id=?&quot;, arrayOf(id))</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun delete(uri: Uri, selection: String?, selectionArgs: Array&lt;String&gt;?): Int &#123;</span><br><span class="line">        val db = dbHelper.writableDatabase</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; db.delete(TABLE_DIARY, selection, selectionArgs)</span><br><span class="line">            DIARY_ITEM -&gt; &#123;</span><br><span class="line">                val id = uri.lastPathSegment</span><br><span class="line">                db.delete(TABLE_DIARY, &quot;id=?&quot;, arrayOf(id))</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getType(uri: Uri): String? &#123;</span><br><span class="line">        return when (uriMatcher.match(uri)) &#123;</span><br><span class="line">            DIARY_DIR -&gt; &quot;vnd.android.cursor.dir/vnd.$AUTHORITY.$TABLE_DIARY&quot;</span><br><span class="line">            DIARY_ITEM -&gt; &quot;vnd.android.cursor.item/vnd.$AUTHORITY.$TABLE_DIARY&quot;</span><br><span class="line">            else -&gt; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-UriMatcher-配置"><a href="#3-3-UriMatcher-配置" class="headerlink" title="3.3 UriMatcher 配置"></a>3.3 UriMatcher 配置</h3><p>在 ContentProvider 中，我们使用 UriMatcher 来判断传入的 URI 属于哪个类型。UriMatcher 会匹配表名（<code>diary</code>）或者某个具体的记录（通过 ID 来识别）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply &#123;</span><br><span class="line">    addURI(AUTHORITY, TABLE_DIARY, DIARY_DIR) // 匹配整个 diary 表</span><br><span class="line">    addURI(AUTHORITY, &quot;$TABLE_DIARY/#&quot;, DIARY_ITEM) // 匹配单条 diary 记录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>DIARY_DIR</strong>：匹配整个表的 URI。</li><li><strong>DIARY_ITEM</strong>：匹配单条数据记录的 URI，带有 <code>#</code> 通配符，表示记录的 ID。</li></ul><h3 id="3-4-ContentResolver-的使用"><a href="#3-4-ContentResolver-的使用" class="headerlink" title="3.4 ContentResolver 的使用"></a>3.4 ContentResolver 的使用</h3><p>ContentResolver 是外部应用用来访问 ContentProvider 的接口。在外部应用中，我们可以通过 ContentResolver 来执行查询、插入、更新和删除操作。例如，查询所有标题包含“心情”的日记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//构造 content:// 开头的 Uri，它用于标识数据库中的某条数据。</span><br><span class="line">val uri = Uri.parse(&quot;content://com.example.providerdemo.diaryprovider/diary&quot;)</span><br><span class="line">val projection = arrayOf(&quot;id&quot;, &quot;title&quot;, &quot;date&quot;, &quot;content&quot;)</span><br><span class="line">val selection = &quot;title LIKE ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;%心情%&quot;)</span><br><span class="line">val sortOrder = &quot;date DESC&quot;</span><br><span class="line"></span><br><span class="line">// 查询操作</span><br><span class="line">val cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)</span><br><span class="line">cursor?.use &#123;</span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val id = it.getInt(it.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val title = it.getString(it.getColumnIndexOrThrow(&quot;title&quot;))</span><br><span class="line">        val date = it.getLong(it.getColumnIndexOrThrow(&quot;date&quot;))</span><br><span class="line">        val content = it.getString(it.getColumnIndexOrThrow(&quot;content&quot;))</span><br><span class="line">        println(&quot;ID: $id, Title: $title, Date: $date, Content: $content&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>通过结合 <strong>SQLite</strong> 数据库、<strong>ContentProvider</strong>、<strong>ContentResolver</strong> 和 <strong>UriMatcher</strong>，我们可以实现一个完整的跨应用数据共享机制。ContentProvider 作为数据提供者，向外部应用提供访问接口，ContentResolver 则充当请求者的角色，发起查询、插入、更新和删除等操作，UriMatcher 则帮助我们根据 URI 匹配具体的数据操作。</p><p>这种架构不仅保证了数据共享的高效性和安全性，同时还使得应用内部数据管理变得更加清晰和规范。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecycleView使用示例</title>
      <link href="/2025/03/17/RecycleView%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/17/RecycleView%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="🚀-RecyclerView-进阶优化指南"><a href="#🚀-RecyclerView-进阶优化指南" class="headerlink" title="🚀 RecyclerView 进阶优化指南"></a><strong>🚀 RecyclerView 进阶优化指南</strong></h1><p>相比之前的版本，这次的改进包括：</p><ul><li>✅ <strong>使用 <code>DiffUtil</code> 优化数据更新</strong>（避免 <code>notifyDataSetChanged()</code>）</li><li>✅ <strong>使用 <code>ViewBinding</code> 简化 <code>ViewHolder</code> 代码</strong></li><li>✅ <strong>封装 <code>Adapter</code> 支持 <code>MutableList</code>（支持增删改查）</strong></li><li>✅ <strong>优化 <code>onClick</code> 事件，让 <code>RecyclerView</code> 更易扩展</strong></li><li>✅ <strong>支持 Grid&#x2F;瀑布流&#x2F;线性布局</strong></li></ul><hr><h2 id="1️⃣-添加-RecyclerView-依赖"><a href="#1️⃣-添加-RecyclerView-依赖" class="headerlink" title="1️⃣ 添加 RecyclerView 依赖"></a><strong>1️⃣ 添加 RecyclerView 依赖</strong></h2><p>确保你的 <code>build.gradle</code> 添加了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;androidx.recyclerview:recyclerview:1.3.2&#x27;</span><br><span class="line">    implementation &#x27;androidx.viewbinding:viewbinding:7.3.1&#x27; // 使用 ViewBinding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-在-activity-main-xml-中添加-RecyclerView"><a href="#2️⃣-在-activity-main-xml-中添加-RecyclerView" class="headerlink" title="2️⃣ 在 activity_main.xml 中添加 RecyclerView"></a><strong>2️⃣ 在 <code>activity_main.xml</code> 中添加 <code>RecyclerView</code></strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">    android:id=&quot;@+id/recyclerView&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;/&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="3️⃣-创建数据模型"><a href="#3️⃣-创建数据模型" class="headerlink" title="3️⃣ 创建数据模型"></a><strong>3️⃣ 创建数据模型</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data class Diary(</span><br><span class="line">    val id: Int,         // 方便更新和删除</span><br><span class="line">    val title: String,  </span><br><span class="line">    val content: String, </span><br><span class="line">    val date: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="4️⃣-使用-DiffUtil-优化-Adapter"><a href="#4️⃣-使用-DiffUtil-优化-Adapter" class="headerlink" title="4️⃣ 使用 DiffUtil 优化 Adapter"></a><strong>4️⃣ 使用 <code>DiffUtil</code> 优化 <code>Adapter</code></strong></h2><p>🚀 <code>DiffUtil</code> 可以高效更新 <code>RecyclerView</code>，避免全量刷新，提高性能。</p><h3 id="创建-DiaryDiffCallback"><a href="#创建-DiaryDiffCallback" class="headerlink" title="创建 DiaryDiffCallback"></a><strong>创建 <code>DiaryDiffCallback</code></strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class DiaryDiffCallback(</span><br><span class="line">    private val oldList: List&lt;Diary&gt;,</span><br><span class="line">    private val newList: List&lt;Diary&gt;</span><br><span class="line">) : DiffUtil.Callback() &#123;</span><br><span class="line">    </span><br><span class="line">    override fun getOldListSize(): Int = oldList.size</span><br><span class="line">    override fun getNewListSize(): Int = newList.size</span><br><span class="line"></span><br><span class="line">    // 判断是否是同一项（通常比较 ID）</span><br><span class="line">    override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean &#123;</span><br><span class="line">        return oldList[oldItemPosition].id == newList[newItemPosition].id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断内容是否相同（避免不必要的刷新）</span><br><span class="line">    override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean &#123;</span><br><span class="line">        return oldList[oldItemPosition] == newList[newItemPosition]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5️⃣-优化-Adapter（使用-ViewBinding）"><a href="#5️⃣-优化-Adapter（使用-ViewBinding）" class="headerlink" title="5️⃣ 优化 Adapter（使用 ViewBinding）"></a><strong>5️⃣ 优化 <code>Adapter</code>（使用 <code>ViewBinding</code>）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class DiaryAdapter(</span><br><span class="line">    private var diaryList: MutableList&lt;Diary&gt;, // 让数据可变</span><br><span class="line">    private val onItemClick: (Diary) -&gt; Unit</span><br><span class="line">) : RecyclerView.Adapter&lt;DiaryAdapter.DiaryViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    // 使用 ViewBinding 简化 ViewHolder</span><br><span class="line">    class DiaryViewHolder(val binding: ItemDiaryBinding) : RecyclerView.ViewHolder(binding.root)</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): DiaryViewHolder &#123;</span><br><span class="line">        val binding = ItemDiaryBinding.inflate(LayoutInflater.from(parent.context), parent, false)</span><br><span class="line">        return DiaryViewHolder(binding)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: DiaryViewHolder, position: Int) &#123;</span><br><span class="line">        val diary = diaryList[position]</span><br><span class="line">        with(holder.binding) &#123;</span><br><span class="line">            tvTitle.text = diary.title</span><br><span class="line">            tvContent.text = diary.content</span><br><span class="line">            tvDate.text = diary.date</span><br><span class="line">            root.setOnClickListener &#123; onItemClick(diary) &#125; // 处理点击事件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getItemCount(): Int = diaryList.size</span><br><span class="line"></span><br><span class="line">    // 🚀 使用 DiffUtil 刷新数据，避免全量刷新</span><br><span class="line">    fun updateData(newList: List&lt;Diary&gt;) &#123;</span><br><span class="line">        val diffResult = DiffUtil.calculateDiff(DiaryDiffCallback(diaryList, newList))</span><br><span class="line">        diaryList.clear()</span><br><span class="line">        diaryList.addAll(newList)</span><br><span class="line">        diffResult.dispatchUpdatesTo(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 增删改查方法</span><br><span class="line">    fun addDiary(diary: Diary) &#123;</span><br><span class="line">        diaryList.add(0, diary)  // 插入到第一个位置</span><br><span class="line">        notifyItemInserted(0)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun removeDiary(position: Int) &#123;</span><br><span class="line">        if (position in diaryList.indices) &#123;</span><br><span class="line">            diaryList.removeAt(position)</span><br><span class="line">            notifyItemRemoved(position)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6️⃣-创建-item-diary-xml"><a href="#6️⃣-创建-item-diary-xml" class="headerlink" title="6️⃣ 创建 item_diary.xml"></a><strong>6️⃣ 创建 <code>item_diary.xml</code></strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;</span><br><span class="line">    android:background=&quot;@android:color/white&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tvTitle&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;18sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/black&quot;</span><br><span class="line">        android:textStyle=&quot;bold&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tvContent&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;16sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/darker_gray&quot;</span><br><span class="line">        android:maxLines=&quot;2&quot;</span><br><span class="line">        android:ellipsize=&quot;end&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tvDate&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;14sp&quot;</span><br><span class="line">        android:textColor=&quot;@android:color/holo_blue_dark&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="7️⃣-在-MainActivity-绑定-RecyclerView"><a href="#7️⃣-在-MainActivity-绑定-RecyclerView" class="headerlink" title="7️⃣ 在 MainActivity 绑定 RecyclerView"></a><strong>7️⃣ 在 <code>MainActivity</code> 绑定 <code>RecyclerView</code></strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    </span><br><span class="line">    private lateinit var recyclerView: RecyclerView</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        recyclerView = findViewById(R.id.recyclerView)</span><br><span class="line">        recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line"></span><br><span class="line">        // 初始数据</span><br><span class="line">        val diaryList = mutableListOf(</span><br><span class="line">            Diary(1, &quot;今日心情&quot;, &quot;今天天气很好，心情愉快！&quot;, &quot;2025-03-17&quot;),</span><br><span class="line">            Diary(2, &quot;学习 Kotlin&quot;, &quot;RecyclerView 真的很好用！&quot;, &quot;2025-03-16&quot;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // 绑定 Adapter</span><br><span class="line">        diaryAdapter = DiaryAdapter(diaryList) &#123; diary -&gt;</span><br><span class="line">            Toast.makeText(this, &quot;点击了: $&#123;diary.title&#125;&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        recyclerView.adapter = diaryAdapter</span><br><span class="line"></span><br><span class="line">        // 模拟 3 秒后刷新数据</span><br><span class="line">        Handler(Looper.getMainLooper()).postDelayed(&#123;</span><br><span class="line">            val newData = diaryList + Diary(3, &quot;记账&quot;, &quot;今天吃了火锅，花了 120 元&quot;, &quot;2025-03-15&quot;)</span><br><span class="line">            diaryAdapter.updateData(newData)</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8️⃣-可选优化"><a href="#8️⃣-可选优化" class="headerlink" title="8️⃣ 可选优化"></a><strong>8️⃣ 可选优化</strong></h2><h3 id="（1）网格布局"><a href="#（1）网格布局" class="headerlink" title="（1）网格布局"></a><strong>（1）网格布局</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.layoutManager = GridLayoutManager(this, 2) // 2 列</span><br></pre></td></tr></table></figure><h3 id="（2）瀑布流布局"><a href="#（2）瀑布流布局" class="headerlink" title="（2）瀑布流布局"></a><strong>（2）瀑布流布局</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-总结"><a href="#🎯-总结" class="headerlink" title="🎯 总结"></a><strong>🎯 总结</strong></h2><table><thead><tr><th>改进点</th><th>说明</th></tr></thead><tbody><tr><td>✅ <strong>使用 <code>DiffUtil</code></strong></td><td><strong>优化数据更新</strong>，避免 <code>notifyDataSetChanged()</code></td></tr><tr><td>✅ <strong>使用 <code>ViewBinding</code></strong></td><td><strong>减少 <code>findViewById</code> 代码</strong>，提高可读性</td></tr><tr><td>✅ <strong>封装增删改查方法</strong></td><td><code>addDiary()</code> 和 <code>removeDiary()</code></td></tr><tr><td>✅ <strong>支持 <code>MutableList</code></strong></td><td><strong>让数据可变</strong>，更方便操作</td></tr><tr><td>✅ <strong>支持 Grid&#x2F;瀑布流布局</strong></td><td><strong>适配不同 UI 需求</strong></td></tr></tbody></table><hr><p>🚀 <strong>这样写的 <code>RecyclerView</code> 更高效、更易扩展！你可以直接用在 Kotlin 日记本 App 里。</strong> 🎉</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ContentResolver的增删改查方法示例</title>
      <link href="/2025/03/17/ContentResolver%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/17/ContentResolver%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-中-ContentResolver-的增删改查详解"><a href="#Android-中-ContentResolver-的增删改查详解" class="headerlink" title="Android 中 ContentResolver 的增删改查详解"></a><strong>Android 中 <code>ContentResolver</code> 的增删改查详解</strong></h2><p><code>ContentResolver</code> 是 Android 提供的 API，用于在不同应用程序之间访问和操作数据，通常与 <code>ContentProvider</code> 一起使用。它提供 <strong>增（insert）、删（delete）、改（update）、查（query）</strong> 操作，常见于访问系统数据库（如通讯录、媒体库等）或应用自定义的数据库（如日记本、笔记等）。</p><hr><h2 id="📌-使用-ContentResolver-的步骤"><a href="#📌-使用-ContentResolver-的步骤" class="headerlink" title="📌 使用 ContentResolver 的步骤"></a><strong>📌 使用 <code>ContentResolver</code> 的步骤</strong></h2><ol><li><strong>确定 <code>ContentProvider</code> 提供的数据 URI</strong>（<code>content://</code> 格式）</li><li><strong>获取 <code>ContentResolver</code></strong> 对象</li><li><strong>执行增、删、改、查操作</strong></li><li><strong>处理权限（如果是访问系统数据）</strong></li><li><strong>关闭 <code>Cursor</code> 以释放资源（仅 <code>query</code> 需要）</strong></li></ol><hr><h2 id="💡-1-获取-ContentResolver"><a href="#💡-1-获取-ContentResolver" class="headerlink" title="💡 1. 获取 ContentResolver"></a><strong>💡 1. 获取 <code>ContentResolver</code></strong></h2><p>在 <code>Activity</code> 或 <code>Fragment</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val contentResolver = context.contentResolver</span><br></pre></td></tr></table></figure><p>在 <code>Service</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val contentResolver = applicationContext.contentResolver</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-2-查询数据（query）"><a href="#🔍-2-查询数据（query）" class="headerlink" title="🔍 2. 查询数据（query）"></a><strong>🔍 2. 查询数据（query）</strong></h2><p>查询 <code>ContentProvider</code> 提供的数据，返回 <code>Cursor</code>，需手动遍历和关闭。</p><h3 id="示例：查询日记"><a href="#示例：查询日记" class="headerlink" title="示例：查询日记"></a><strong>示例：查询日记</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 1. 目标 ContentProvider 的 URI</span><br><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line">//构造 content:// 开头的 Uri，它用于标识数据库中的某条数据。</span><br><span class="line"></span><br><span class="line">// 2. 查询的字段（列）</span><br><span class="line">val projection = arrayOf(&quot;id&quot;, &quot;title&quot;, &quot;date&quot;)</span><br><span class="line"></span><br><span class="line">// 3. 查询条件（WHERE）</span><br><span class="line">val selection = &quot;title LIKE ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;%心情%&quot;) // 查询包含“心情”的日记</span><br><span class="line">//这表示查询 title 列，要求 title 的内容包含“心情”两个字。</span><br><span class="line">//LIKE 是 SQL 语法，用于进行模糊查询。</span><br><span class="line">//? 是占位符，用来防止 SQL 注入，具体值由 selectionArgs 提供。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 4. 排序方式</span><br><span class="line">val sortOrder = &quot;date DESC&quot;</span><br><span class="line"></span><br><span class="line">// 5. 执行查询</span><br><span class="line">val cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)</span><br><span class="line"></span><br><span class="line">cursor?.use &#123; </span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val id = it.getInt(it.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val title = it.getString(it.getColumnIndexOrThrow(&quot;title&quot;))</span><br><span class="line">        val date = it.getLong(it.getColumnIndexOrThrow(&quot;date&quot;))</span><br><span class="line">        println(&quot;ID: $id, Title: $title, Date: $date&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // `use` 语法确保 Cursor 关闭</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li>查询时使用 <code>LIKE</code> 支持模糊匹配，<code>?</code> 代表参数占位符</li><li>使用 <code>Cursor</code> 需要调用 <code>.moveToNext()</code> 逐行读取</li><li>关闭 <code>Cursor</code> 以释放资源</li></ul><hr><h2 id="📝-3-插入数据（insert）"><a href="#📝-3-插入数据（insert）" class="headerlink" title="📝 3. 插入数据（insert）"></a><strong>📝 3. 插入数据（insert）</strong></h2><p>用于新增数据，返回新数据的 <code>Uri</code>。</p><h3 id="示例：新增日记"><a href="#示例：新增日记" class="headerlink" title="示例：新增日记"></a><strong>示例：新增日记</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line"></span><br><span class="line">// 1. 创建 ContentValues，存储字段和值</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(&quot;title&quot;, &quot;今日心情&quot;)</span><br><span class="line">    put(&quot;content&quot;, &quot;今天是个好天气&quot;)</span><br><span class="line">    put(&quot;date&quot;, System.currentTimeMillis())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 调用 insert 方法</span><br><span class="line">val newUri = contentResolver.insert(uri, values)</span><br><span class="line"></span><br><span class="line">// 3. 判断插入结果</span><br><span class="line">if (newUri != null) &#123;</span><br><span class="line">    println(&quot;插入成功，URI: $newUri&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;插入失败&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li><code>ContentValues</code> 类似 <code>Map</code>，用于存储字段和值</li><li><code>insert()</code> 返回新数据的 <code>Uri</code>，失败时返回 <code>null</code></li><li>newUri:表示新插入的数据的 <strong>URI</strong>，用于后续操作。如果插入失败，返回 <code>null</code>。</li></ul><hr><h2 id="✏-4-更新数据（update）"><a href="#✏-4-更新数据（update）" class="headerlink" title="✏ 4. 更新数据（update）"></a><strong>✏ 4. 更新数据（update）</strong></h2><p>用于修改已有数据，返回影响的行数。</p><h3 id="示例：更新日记内容"><a href="#示例：更新日记内容" class="headerlink" title="示例：更新日记内容"></a><strong>示例：更新日记内容</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line"></span><br><span class="line">// 1. 创建 ContentValues，存储更新的字段和值</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(&quot;content&quot;, &quot;更新后的日记内容&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 更新条件</span><br><span class="line">val selection = &quot;id = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;) // 只更新 ID 为 1 的日记</span><br><span class="line"></span><br><span class="line">// 3. 执行 update</span><br><span class="line">val rowsUpdated = contentResolver.update(uri, values, selection, selectionArgs)</span><br><span class="line"></span><br><span class="line">println(&quot;更新了 $rowsUpdated 条数据&quot;)</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li><code>selection</code> 是 SQL 语法的 <code>WHERE</code> 子句</li><li><code>update()</code> 返回更新的行数，可能为 <code>0</code>（表示数据未找到）</li></ul><hr><h2 id="🗑-5-删除数据（delete）"><a href="#🗑-5-删除数据（delete）" class="headerlink" title="🗑 5. 删除数据（delete）"></a><strong>🗑 5. 删除数据（delete）</strong></h2><p>用于删除数据，返回删除的行数。</p><h3 id="示例：删除指定日记"><a href="#示例：删除指定日记" class="headerlink" title="示例：删除指定日记"></a><strong>示例：删除指定日记</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val uri = Uri.parse(&quot;content://com.example.provider/diary&quot;)</span><br><span class="line"></span><br><span class="line">// 1. 删除条件</span><br><span class="line">val selection = &quot;id = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;) // 只删除 ID 为 1 的日记</span><br><span class="line"></span><br><span class="line">// 2. 执行删除</span><br><span class="line">val rowsDeleted = contentResolver.delete(uri, selection, selectionArgs)</span><br><span class="line"></span><br><span class="line">println(&quot;删除了 $rowsDeleted 条数据&quot;)</span><br></pre></td></tr></table></figure><p>🔹 <strong>注意事项</strong>：</p><ul><li><code>delete()</code> 返回删除的行数</li><li>不提供 <code>selection</code> 则删除所有数据（谨慎）</li></ul><hr><h2 id="📖-6-访问系统-ContentProvider-示例"><a href="#📖-6-访问系统-ContentProvider-示例" class="headerlink" title="📖 6. 访问系统 ContentProvider 示例"></a><strong>📖 6. 访问系统 <code>ContentProvider</code> 示例</strong></h2><h3 id="📌-读取联系人"><a href="#📌-读取联系人" class="headerlink" title="📌 读取联系人"></a><strong>📌 读取联系人</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI</span><br><span class="line">val cursor = contentResolver.query(uri, null, null, null, null)</span><br><span class="line"></span><br><span class="line">cursor?.use &#123;</span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val name = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME))</span><br><span class="line">        val phone = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.NUMBER))</span><br><span class="line">        println(&quot;联系人: $name, 电话: $phone&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="📌-读取相册"><a href="#📌-读取相册" class="headerlink" title="📌 读取相册"></a><strong>📌 读取相册</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI</span><br><span class="line">val projection = arrayOf(MediaStore.Images.Media.DATA)</span><br><span class="line">val cursor = contentResolver.query(uri, projection, null, null, null)</span><br><span class="line"></span><br><span class="line">cursor?.use &#123;</span><br><span class="line">    while (it.moveToNext()) &#123;</span><br><span class="line">        val imagePath = it.getString(it.getColumnIndexOrThrow(MediaStore.Images.Media.DATA))</span><br><span class="line">        println(&quot;图片路径: $imagePath&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔒-7-处理权限"><a href="#🔒-7-处理权限" class="headerlink" title="🔒 7. 处理权限"></a><strong>🔒 7. 处理权限</strong></h2><p><strong>如果访问系统 <code>ContentProvider</code>（如通讯录、相册等），需申请权限</strong>：</p><h3 id="在-AndroidManifest-xml-申请权限"><a href="#在-AndroidManifest-xml-申请权限" class="headerlink" title="在 AndroidManifest.xml 申请权限"></a><strong>在 <code>AndroidManifest.xml</code> 申请权限</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="动态请求权限（Android-6-0-）"><a href="#动态请求权限（Android-6-0-）" class="headerlink" title="动态请求权限（Android 6.0+）"></a><strong>动态请求权限（Android 6.0+）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.READ_CONTACTS), 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a><strong>📌 总结</strong></h2><table><thead><tr><th>操作</th><th>方法名</th><th>主要参数</th></tr></thead><tbody><tr><td><strong>查询</strong></td><td><code>query(uri, projection, selection, selectionArgs, sortOrder)</code></td><td><code>Uri</code>，字段数组，查询条件，排序</td></tr><tr><td><strong>插入</strong></td><td><code>insert(uri, values)</code></td><td><code>Uri</code>，<code>ContentValues</code></td></tr><tr><td><strong>更新</strong></td><td><code>update(uri, values, selection, selectionArgs)</code></td><td><code>Uri</code>，<code>ContentValues</code>，条件</td></tr><tr><td><strong>删除</strong></td><td><code>delete(uri, selection, selectionArgs)</code></td><td><code>Uri</code>，条件</td></tr></tbody></table><p><strong>💡 你是要操作自己的 <code>ContentProvider</code> 还是访问系统数据？如果是日记本的 <code>ContentProvider</code>，可以一起设计 URI 和数据库结构。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite用法</title>
      <link href="/2025/03/15/SQLite%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/SQLite%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>SQLite 是一种轻量级的嵌入式数据库，在 Android 中用于存储结构化数据。你可以通过 <code>SQLiteOpenHelper</code> 来管理数据库的创建、升级、和版本管理。以下是使用 SQLite 的基本步骤：</p><h2 id="1-创建数据库和表"><a href="#1-创建数据库和表" class="headerlink" title="1. 创建数据库和表"></a><strong>1. 创建数据库和表</strong></h2><p>使用 <code>SQLiteOpenHelper</code> 创建数据库以及表结构。这个类会帮助你创建数据库、执行表的升级、降级等操作。</p><h3 id="创建-SQLiteOpenHelper-类"><a href="#创建-SQLiteOpenHelper-类" class="headerlink" title="创建 SQLiteOpenHelper 类"></a><strong>创建 SQLiteOpenHelper 类</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import android.database.sqlite.SQLiteDatabase</span><br><span class="line">import android.database.sqlite.SQLiteOpenHelper</span><br><span class="line"></span><br><span class="line">class MyDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private const val DATABASE_NAME = &quot;my_database.db&quot; // 数据库名称</span><br><span class="line">        private const val DATABASE_VERSION = 1 // 数据库版本号</span><br><span class="line">        private const val TABLE_NAME = &quot;users&quot; // 表名称</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase) &#123;</span><br><span class="line">        // 创建数据库表</span><br><span class="line">        val createTableQuery = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE $TABLE_NAME (</span><br><span class="line">                id INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                name TEXT NOT NULL,</span><br><span class="line">                age INTEGER</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;.trimIndent()</span><br><span class="line">        db.execSQL(createTableQuery)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        // 如果数据库版本变化时，删除旧表并创建新表</span><br><span class="line">        db.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NAME&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>onCreate</code></strong>：当数据库首次创建时执行。通常在这里创建表和初始化数据。</li><li><strong><code>onUpgrade</code></strong>：当数据库版本发生变化时执行。你可以在这里进行表的迁移或删除。</li></ul><h2 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2. 插入数据"></a><strong>2. 插入数据</strong></h2><p>插入数据需要通过 <code>SQLiteDatabase.insert()</code> 方法来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import android.content.ContentValues</span><br><span class="line"></span><br><span class="line">fun insertUser(context: Context, name: String, age: Int) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val values = ContentValues().apply &#123;</span><br><span class="line">        put(&quot;name&quot;, name)</span><br><span class="line">        put(&quot;age&quot;, age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    db.insert(&quot;users&quot;, null, values)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>ContentValues</code></strong>：是用于存储要插入的数据的容器。通过 <code>put</code> 方法将列名和值添加到 <code>ContentValues</code> 中。</li><li><strong><code>insert</code></strong>：插入数据的方法，第一个参数是表名，第二个参数是列为空时插入的默认值，第三个参数是 <code>ContentValues</code>。</li></ul><h2 id="3-查询数据"><a href="#3-查询数据" class="headerlink" title="3. 查询数据"></a><strong>3. 查询数据</strong></h2><p>查询数据使用 <code>SQLiteDatabase.query()</code> 或 <code>SQLiteDatabase.rawQuery()</code> 方法。</p><h3 id="使用-query-方法"><a href="#使用-query-方法" class="headerlink" title="使用 query() 方法"></a>使用 <code>query()</code> 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import android.database.Cursor</span><br><span class="line"></span><br><span class="line">fun queryUsers(context: Context): List&lt;User&gt; &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.readableDatabase</span><br><span class="line"></span><br><span class="line">    val cursor: Cursor = db.query(</span><br><span class="line">        &quot;users&quot;, // 表名</span><br><span class="line">        arrayOf(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;), // 列名</span><br><span class="line">        null, // WHERE 子句</span><br><span class="line">        null, // WHERE 子句的参数</span><br><span class="line">        null, // GROUP BY 子句</span><br><span class="line">        null, // HAVING 子句</span><br><span class="line">        null // ORDER BY 子句</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val users = mutableListOf&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    while (cursor.moveToNext()) &#123;</span><br><span class="line">        val id = cursor.getLong(cursor.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val name = cursor.getString(cursor.getColumnIndexOrThrow(&quot;name&quot;))</span><br><span class="line">        val age = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;age&quot;))</span><br><span class="line"></span><br><span class="line">        users.add(User(id, name, age))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    return users</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data class User(val id: Long, val name: String, val age: Int)</span><br></pre></td></tr></table></figure><ul><li><strong><code>query</code></strong>：用于查询数据库，返回一个 <code>Cursor</code> 对象。你可以通过 <code>Cursor</code> 遍历结果集。</li><li><strong><code>getColumnIndexOrThrow()</code></strong>：根据列名获取列的索引，<code>getString()</code>, <code>getInt()</code> 等方法用于提取数据。</li></ul><h3 id="使用-rawQuery-方法"><a href="#使用-rawQuery-方法" class="headerlink" title="使用 rawQuery() 方法"></a>使用 <code>rawQuery()</code> 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun queryUsersRaw(context: Context): List&lt;User&gt; &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.readableDatabase</span><br><span class="line"></span><br><span class="line">    val cursor: Cursor = db.rawQuery(&quot;SELECT * FROM users&quot;, null)</span><br><span class="line"></span><br><span class="line">    val users = mutableListOf&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    while (cursor.moveToNext()) &#123;</span><br><span class="line">        val id = cursor.getLong(cursor.getColumnIndex(&quot;id&quot;))</span><br><span class="line">        val name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;))</span><br><span class="line">        val age = cursor.getInt(cursor.getColumnIndex(&quot;age&quot;))</span><br><span class="line"></span><br><span class="line">        users.add(User(id, name, age))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    return users</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>rawQuery()</code></strong>：执行原始的 SQL 查询语句，返回一个 <code>Cursor</code>。</li></ul><h2 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4. 更新数据"></a><strong>4. 更新数据</strong></h2><p>更新数据使用 <code>SQLiteDatabase.update()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import android.content.ContentValues</span><br><span class="line"></span><br><span class="line">fun updateUser(context: Context, id: Long, name: String, age: Int) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val values = ContentValues().apply &#123;</span><br><span class="line">        put(&quot;name&quot;, name)</span><br><span class="line">        put(&quot;age&quot;, age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val selection = &quot;id = ?&quot;</span><br><span class="line">    val selectionArgs = arrayOf(id.toString())</span><br><span class="line"></span><br><span class="line">    db.update(&quot;users&quot;, values, selection, selectionArgs)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>update()</code></strong>：更新数据的方法。第一个参数是表名，第二个参数是更新的值，第三个参数是 <code>WHERE</code> 子句，第四个参数是 <code>WHERE</code> 子句的参数。</li></ul><h2 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5. 删除数据"></a><strong>5. 删除数据</strong></h2><p>删除数据使用 <code>SQLiteDatabase.delete()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun deleteUser(context: Context, id: Long) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val selection = &quot;id = ?&quot;</span><br><span class="line">    val selectionArgs = arrayOf(id.toString())</span><br><span class="line"></span><br><span class="line">    db.delete(&quot;users&quot;, selection, selectionArgs)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>delete()</code></strong>：删除数据的方法，类似于 <code>update()</code> 方法，传入 <code>WHERE</code> 子句来指定删除条件。</li></ul><h2 id="6-关闭数据库连接"><a href="#6-关闭数据库连接" class="headerlink" title="6. 关闭数据库连接"></a><strong>6. 关闭数据库连接</strong></h2><p>每次操作完数据库后，记得关闭数据库连接，防止内存泄漏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.close()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><strong>创建数据库和表</strong>：通过继承 <code>SQLiteOpenHelper</code> 类来创建数据库及表。</li><li><strong>插入数据</strong>：使用 <code>ContentValues</code> 结合 <code>insert()</code> 方法插入数据。</li><li><strong>查询数据</strong>：通过 <code>query()</code> 或 <code>rawQuery()</code> 查询数据，返回 <code>Cursor</code> 对象进行遍历。</li><li><strong>更新数据</strong>：使用 <code>update()</code> 方法更新数据。</li><li><strong>删除数据</strong>：使用 <code>delete()</code> 方法删除数据。</li><li><strong>关闭数据库连接</strong>：操作完成后记得关闭数据库。</li></ol><p>SQLite 提供了强大的本地数据存储能力，适合用于需要存储结构化数据的应用。</p><p><strong>完整示例</strong></p><p>假设我们有一个应用需要保存用户信息，每个用户包含 <code>id</code>、<code>name</code> 和 <code>email</code>。我们可以在数据库中创建一个表并对数据进行增删改查操作。</p><h4 id="1-数据库助手类"><a href="#1-数据库助手类" class="headerlink" title="1. 数据库助手类"></a>1. 数据库助手类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MyDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val DATABASE_NAME = &quot;my_database.db&quot;</span><br><span class="line">        const val DATABASE_VERSION = 1</span><br><span class="line">        const val TABLE_NAME = &quot;users&quot;</span><br><span class="line">        const val COLUMN_ID = &quot;id&quot;</span><br><span class="line">        const val COLUMN_NAME = &quot;name&quot;</span><br><span class="line">        const val COLUMN_EMAIL = &quot;email&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase?) &#123;</span><br><span class="line">        val createTableQuery = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE $TABLE_NAME (</span><br><span class="line">                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                $COLUMN_NAME TEXT,</span><br><span class="line">                $COLUMN_EMAIL TEXT</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        db?.execSQL(createTableQuery)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NAME&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-插入数据-1"><a href="#2-插入数据-1" class="headerlink" title="2. 插入数据"></a>2. 插入数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_NAME, &quot;John Doe&quot;)</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_EMAIL, &quot;john.doe@example.com&quot;)</span><br><span class="line">&#125;</span><br><span class="line">db.insert(MyDatabaseHelper.TABLE_NAME, null, values)</span><br></pre></td></tr></table></figure><h4 id="3-查询数据-1"><a href="#3-查询数据-1" class="headerlink" title="3. 查询数据"></a>3. 查询数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val db = dbHelper.readableDatabase</span><br><span class="line">val cursor = db.query(</span><br><span class="line">    MyDatabaseHelper.TABLE_NAME,</span><br><span class="line">    arrayOf(MyDatabaseHelper.COLUMN_ID, MyDatabaseHelper.COLUMN_NAME, MyDatabaseHelper.COLUMN_EMAIL),</span><br><span class="line">    null, null, null, null, null</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">while (cursor.moveToNext()) &#123;</span><br><span class="line">    val id = cursor.getLong(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_ID))</span><br><span class="line">    val name = cursor.getString(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_NAME))</span><br><span class="line">    val email = cursor.getString(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_EMAIL))</span><br><span class="line">    println(&quot;User: $id, $name, $email&quot;)</span><br><span class="line">&#125;</span><br><span class="line">cursor.close()</span><br></pre></td></tr></table></figure><h4 id="4-更新数据-1"><a href="#4-更新数据-1" class="headerlink" title="4. 更新数据"></a>4. 更新数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_NAME, &quot;John Smith&quot;)</span><br><span class="line">&#125;</span><br><span class="line">val selection = &quot;$&#123;MyDatabaseHelper.COLUMN_ID&#125; = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">db.update(MyDatabaseHelper.TABLE_NAME, values, selection, selectionArgs)</span><br></pre></td></tr></table></figure><h4 id="5-删除数据-1"><a href="#5-删除数据-1" class="headerlink" title="5. 删除数据"></a>5. 删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val selection = &quot;$&#123;MyDatabaseHelper.COLUMN_ID&#125; = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">db.delete(MyDatabaseHelper.TABLE_NAME, selection, selectionArgs)</span><br></pre></td></tr></table></figure><h4 id="6-关闭数据库"><a href="#6-关闭数据库" class="headerlink" title="6. 关闭数据库"></a>6. 关闭数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.close()</span><br></pre></td></tr></table></figure><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>SQLiteOpenHelper</strong>：管理数据库的创建、升级等操作。</li><li><strong>SQLiteDatabase</strong>：用于执行数据库操作，如插入、查询、更新、删除。</li><li><strong>ContentValues</strong>：用于存储要插入或更新的数据。</li><li><strong>Cursor</strong>：用于访问查询结果。</li></ul><p>SQLite 是一种非常有效的方式来在 Android 上进行本地数据存储，尤其适用于存储小型结构化数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Room+ViewModel+LiveData一起使用的用法</title>
      <link href="/2025/03/15/Room-ViewModel-LiveData%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/Room-ViewModel-LiveData%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 <code>Android</code> 开发中，<code>Room</code>、<code>ViewModel</code> 和 <code>LiveData</code> 经常一起使用，以实现 <strong>MVVM 架构</strong>，并提供持久化数据存储、生命周期感知的数据管理和自动更新 UI 的能力。</p><hr><h1 id="📌-1-主要作用"><a href="#📌-1-主要作用" class="headerlink" title="📌 1. 主要作用"></a><strong>📌 1. 主要作用</strong></h1><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>Room（数据库）</strong></td><td>提供 SQLite 的抽象层，管理本地数据存储</td></tr><tr><td><strong>ViewModel</strong></td><td>管理 UI 相关的数据，确保数据在配置变更（如旋转屏幕）时不会丢失</td></tr><tr><td><strong>LiveData</strong></td><td>观察数据变化，并在 UI 组件生命周期内自动更新</td></tr></tbody></table><hr><h1 id="🚀-2-使用-Room-ViewModel-LiveData-的完整示例"><a href="#🚀-2-使用-Room-ViewModel-LiveData-的完整示例" class="headerlink" title="🚀 2. 使用 Room + ViewModel + LiveData 的完整示例"></a><strong>🚀 2. 使用 <code>Room + ViewModel + LiveData</code> 的完整示例</strong></h1><h3 id="📌-功能："><a href="#📌-功能：" class="headerlink" title="📌 功能："></a><strong>📌 功能</strong>：</h3><p>我们实现一个<strong>简单的待办事项（ToDo List）应用</strong>，可以：</p><ul><li><strong>增删查改任务</strong>，数据存储在 <code>Room</code> 数据库中。</li><li><strong>使用 <code>LiveData</code></strong> 让 UI <strong>自动更新</strong>，而不需要手动刷新。</li><li><strong><code>ViewModel</code> 负责管理数据</strong>，避免 <code>Activity</code> 直接操作数据库。</li></ul><hr><h2 id="📌-3-创建-Room-数据库"><a href="#📌-3-创建-Room-数据库" class="headerlink" title="📌 3. 创建 Room 数据库"></a><strong>📌 3. 创建 Room 数据库</strong></h2><h3 id="（1）定义-Entity（数据库表）"><a href="#（1）定义-Entity（数据库表）" class="headerlink" title="（1）定义 Entity（数据库表）"></a><strong>（1）定义 <code>Entity</code>（数据库表）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.Entity</span><br><span class="line">import androidx.room.PrimaryKey</span><br><span class="line"></span><br><span class="line">@Entity(tableName = &quot;todo_table&quot;)</span><br><span class="line">data class Todo(</span><br><span class="line">    @PrimaryKey(autoGenerate = true) val id: Int = 0,</span><br><span class="line">    val task: String,</span><br><span class="line">    val isCompleted: Boolean</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>@Entity</code>：表示这是一个数据库表，表名是 <code>todo_table</code>。</li><li><code>@PrimaryKey(autoGenerate = true)</code>：<code>id</code> 是主键，<code>Room</code> 会自动生成。</li></ul><hr><h3 id="（2）创建-DAO（数据访问对象）"><a href="#（2）创建-DAO（数据访问对象）" class="headerlink" title="（2）创建 DAO（数据访问对象）"></a><strong>（2）创建 DAO（数据访问对象）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line">import androidx.room.*</span><br><span class="line"></span><br><span class="line">@Dao</span><br><span class="line">interface TodoDao &#123;</span><br><span class="line">    @Insert(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    suspend fun insert(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    suspend fun update(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    suspend fun delete(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM todo_table ORDER BY id DESC&quot;)</span><br><span class="line">    fun getAllTodos(): LiveData&lt;List&lt;Todo&gt;&gt; // 使用 LiveData 让 UI 自动更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Dao</code>：数据访问对象，定义数据库操作。</li><li><code>@Insert</code> &#x2F; <code>@Update</code> &#x2F; <code>@Delete</code>：操作数据库的基本增、删、改。</li><li><code>getAllTodos()</code> 返回 <code>LiveData&lt;List&lt;Todo&gt;&gt;</code>，<strong>Room 会自动监听数据变化，并更新 UI</strong>。</li></ul><hr><h3 id="（3）创建-Room-数据库"><a href="#（3）创建-Room-数据库" class="headerlink" title="（3）创建 Room 数据库"></a><strong>（3）创建 Room 数据库</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import androidx.room.Database</span><br><span class="line">import androidx.room.Room</span><br><span class="line">import androidx.room.RoomDatabase</span><br><span class="line"></span><br><span class="line">@Database(entities = [Todo::class], version = 1, exportSchema = false)</span><br><span class="line">abstract class TodoDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun todoDao(): TodoDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile</span><br><span class="line">        private var INSTANCE: TodoDatabase? = null</span><br><span class="line"></span><br><span class="line">        fun getDatabase(context: Context): TodoDatabase &#123;</span><br><span class="line">            return INSTANCE ?: synchronized(this) &#123;</span><br><span class="line">                val instance = Room.databaseBuilder(</span><br><span class="line">                    context.applicationContext,</span><br><span class="line">                    TodoDatabase::class.java,</span><br><span class="line">                    &quot;todo_database&quot;</span><br><span class="line">                ).build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Database(entities = [Todo::class], version = 1)</code>：定义数据库，包含 <code>Todo</code> 表。</li><li><code>synchronized(this)</code>：保证数据库实例的线程安全。</li><li><code>Room.databaseBuilder()</code>：构建 <code>Room</code> 数据库实例。</li></ul><hr><h2 id="📌-4-创建-Repository"><a href="#📌-4-创建-Repository" class="headerlink" title="📌 4. 创建 Repository"></a><strong>📌 4. 创建 Repository</strong></h2><p><code>Repository</code> 负责处理 <code>DAO</code> 操作，避免 <code>ViewModel</code> 直接操作数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line"></span><br><span class="line">class TodoRepository(private val todoDao: TodoDao) &#123;</span><br><span class="line">    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt; = todoDao.getAllTodos()</span><br><span class="line"></span><br><span class="line">    suspend fun insert(todo: Todo) &#123;</span><br><span class="line">        todoDao.insert(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun update(todo: Todo) &#123;</span><br><span class="line">        todoDao.update(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun delete(todo: Todo) &#123;</span><br><span class="line">        todoDao.delete(todo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Repository</code> 封装 <code>DAO</code>，<strong>ViewModel 只需要调用 <code>Repository</code>，而不直接操作 <code>Room</code></strong>。</li></ul><hr><h2 id="📌-5-创建-ViewModel"><a href="#📌-5-创建-ViewModel" class="headerlink" title="📌 5. 创建 ViewModel"></a><strong>📌 5. 创建 ViewModel</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.*</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">class TodoViewModel(private val repository: TodoRepository) : ViewModel() &#123;</span><br><span class="line">    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt; = repository.allTodos</span><br><span class="line"></span><br><span class="line">    fun insert(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.insert(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun update(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.update(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun delete(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.delete(todo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>viewModelScope.launch &#123;&#125;</code> 让数据库操作在 <strong>后台线程执行</strong>（<code>suspend</code> 需要 <code>Coroutine</code>）。</li><li><code>LiveData&lt;List&lt;Todo&gt;&gt;</code> 确保 UI 自动更新。</li></ul><hr><h2 id="📌-6-创建-ViewModelFactory"><a href="#📌-6-创建-ViewModelFactory" class="headerlink" title="📌 6. 创建 ViewModelFactory"></a><strong>📌 6. 创建 ViewModelFactory</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import androidx.lifecycle.ViewModelProvider</span><br><span class="line"></span><br><span class="line">class TodoViewModelFactory(private val repository: TodoRepository) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(TodoViewModel::class.java)) &#123;</span><br><span class="line">            @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">            return TodoViewModel(repository) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ViewModelFactory</code> 用于 <strong>传递 <code>Repository</code></strong>，让 <code>ViewModel</code> 使用 <code>Room</code>。</li></ul><hr><h2 id="📌-7-在-Activity-里使用"><a href="#📌-7-在-Activity-里使用" class="headerlink" title="📌 7. 在 Activity 里使用"></a><strong>📌 7. 在 <code>Activity</code> 里使用</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var todoViewModel: TodoViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        // 获取数据库实例和 DAO</span><br><span class="line">        val database = TodoDatabase.getDatabase(this)</span><br><span class="line">        val repository = TodoRepository(database.todoDao())</span><br><span class="line"></span><br><span class="line">        // 创建 ViewModel</span><br><span class="line">        val factory = TodoViewModelFactory(repository)</span><br><span class="line">        todoViewModel = ViewModelProvider(this, factory).get(TodoViewModel::class.java)</span><br><span class="line"></span><br><span class="line">        // 监听 LiveData，更新 UI</span><br><span class="line">        todoViewModel.allTodos.observe(this) &#123; todos -&gt;</span><br><span class="line">            // 更新 RecyclerView 或 UI</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 添加任务</span><br><span class="line">        buttonAdd.setOnClickListener &#123;</span><br><span class="line">            val newTodo = Todo(task = &quot;New Task&quot;, isCompleted = false)</span><br><span class="line">            todoViewModel.insert(newTodo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getDatabase(this)</code> 获取数据库实例。</li><li><code>ViewModelProvider(this, factory)</code> 创建 <code>ViewModel</code>。</li><li><code>LiveData.observe()</code> 监听数据变化，<strong>UI 自动更新</strong>。</li></ul><hr><h1 id="📌-8-总结"><a href="#📌-8-总结" class="headerlink" title="📌 8. 总结"></a><strong>📌 8. 总结</strong></h1><p>✅ <strong>Room 负责存储数据</strong>，<code>DAO</code> 负责数据库操作。<br> ✅ <strong>ViewModel 负责持久化数据</strong>，避免因屏幕旋转导致数据丢失。<br> ✅ <strong>LiveData 让 UI 自动更新</strong>，不需要手动刷新数据。<br> ✅ <strong>Repository 作为数据中介</strong>，避免 <code>ViewModel</code> 直接操作 <code>Room</code>。</p><p>📌 <strong>最终效果</strong>：</p><ol><li><strong>数据库变更时，UI 自动更新</strong>（<code>LiveData</code>）。</li><li><strong>ViewModel 让数据在 Activity&#x2F;Fragment 生命周期内持久化</strong>。</li><li><strong>Repository 让数据管理更清晰</strong>，避免 <code>ViewModel</code> 直接访问数据库。</li></ol><p>💡 <strong>这样，我们的 <code>MVVM + Room</code> 架构更加清晰，可维护性更强！</strong> 🚀</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewModel用法</title>
      <link href="/2025/03/15/ViewModel%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/ViewModel%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>ViewModel</code> 是 Android 架构组件之一，<strong>用于管理 UI 相关的数据</strong>，并在 <strong>配置更改（如屏幕旋转）时保持数据不丢失</strong>。</p><hr><h2 id="🔹-1-添加-ViewModel-依赖"><a href="#🔹-1-添加-ViewModel-依赖" class="headerlink" title="🔹 1. 添加 ViewModel 依赖"></a><strong>🔹 1. 添加 ViewModel 依赖</strong></h2><p>在 <code>build.gradle.kts</code>（模块级）中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-2-创建-ViewModel"><a href="#🔹-2-创建-ViewModel" class="headerlink" title="🔹 2. 创建 ViewModel"></a><strong>🔹 2. 创建 ViewModel</strong></h2><h3 id="（1）基础-ViewModel"><a href="#（1）基础-ViewModel" class="headerlink" title="（1）基础 ViewModel"></a><strong>（1）基础 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line">class CounterViewModel : ViewModel() &#123;</span><br><span class="line">    var count = 0 // ViewModel 变量（Activity 重建后不会丢失）</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-3-在-Activity-Fragment-中使用"><a href="#🔹-3-在-Activity-Fragment-中使用" class="headerlink" title="🔹 3. 在 Activity&#x2F;Fragment 中使用"></a><strong>🔹 3. 在 Activity&#x2F;Fragment 中使用</strong></h2><h3 id="（1）Activity-获取-ViewModel"><a href="#（1）Activity-获取-ViewModel" class="headerlink" title="（1）Activity 获取 ViewModel"></a><strong>（1）Activity 获取 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import android.widget.TextView</span><br><span class="line">import androidx.activity.viewModels</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels() // 通过 viewModels() 获取 ViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        // 显示当前计数</span><br><span class="line">        textView.text = counterViewModel.count.toString()</span><br><span class="line"></span><br><span class="line">        // 点击按钮增加计数</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">            textView.text = counterViewModel.count.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>即使旋转屏幕，<code>count</code> 也不会重置</strong>。</p><hr><h2 id="🔹-4-ViewModel-LiveData-监听数据变化"><a href="#🔹-4-ViewModel-LiveData-监听数据变化" class="headerlink" title="🔹 4. ViewModel + LiveData 监听数据变化"></a><strong>🔹 4. ViewModel + LiveData 监听数据变化</strong></h2><p>使用 <code>LiveData</code>，<strong>UI 会自动更新</strong>：</p><h3 id="（1）ViewModel（使用-LiveData）"><a href="#（1）ViewModel（使用-LiveData）" class="headerlink" title="（1）ViewModel（使用 LiveData）"></a><strong>（1）ViewModel（使用 <code>LiveData</code>）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line">import androidx.lifecycle.MutableLiveData</span><br><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line">class CounterViewModel : ViewModel() &#123;</span><br><span class="line">    private val _count = MutableLiveData(0) // 可变 LiveData</span><br><span class="line">    val count: LiveData&lt;Int&gt; = _count // 只暴露不可变 LiveData</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        _count.value = (_count.value ?: 0) + 1 // 更新数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）Activity-观察-LiveData"><a href="#（2）Activity-观察-LiveData" class="headerlink" title="（2）Activity 观察 LiveData"></a><strong>（2）Activity 观察 LiveData</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels()</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        // 观察 LiveData，自动更新 UI</span><br><span class="line">        counterViewModel.count.observe(this) &#123; newCount -&gt;</span><br><span class="line">            textView.text = newCount.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong><code>LiveData</code> 确保数据变化时，UI 会自动更新</strong>。</p><hr><h2 id="🔹-5-处理-ViewModel-依赖（带参数的-ViewModel）"><a href="#🔹-5-处理-ViewModel-依赖（带参数的-ViewModel）" class="headerlink" title="🔹 5. 处理 ViewModel 依赖（带参数的 ViewModel）"></a><strong>🔹 5. 处理 ViewModel 依赖（带参数的 ViewModel）</strong></h2><h3 id="（1）ViewModel-需要参数"><a href="#（1）ViewModel-需要参数" class="headerlink" title="（1）ViewModel 需要参数"></a><strong>（1）ViewModel 需要参数</strong></h3><p>如果 <code>ViewModel</code> 需要参数（如 <code>Repository</code>），需要创建 <code>ViewModelProvider.Factory</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class CounterViewModel(private val startValue: Int) : ViewModel() &#123;</span><br><span class="line">    private val _count = MutableLiveData(startValue)</span><br><span class="line">    val count: LiveData&lt;Int&gt; = _count</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        _count.value = (_count.value ?: 0) + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义 ViewModelFactory</span><br><span class="line">class CounterViewModelFactory(private val startValue: Int) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(CounterViewModel::class.java)) &#123;</span><br><span class="line">            @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">            return CounterViewModel(startValue) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）Activity-获取带参数的-ViewModel"><a href="#（2）Activity-获取带参数的-ViewModel" class="headerlink" title="（2）Activity 获取带参数的 ViewModel"></a><strong>（2）Activity 获取带参数的 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels &#123;</span><br><span class="line">        CounterViewModelFactory(5) // 传入初始值 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        counterViewModel.count.observe(this) &#123; newCount -&gt;</span><br><span class="line">            textView.text = newCount.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>支持带参数的 ViewModel（如从数据库或网络获取初始数据）</strong>。</p><hr><h2 id="🔹-6-ViewModel-Room-持久化数据库数据"><a href="#🔹-6-ViewModel-Room-持久化数据库数据" class="headerlink" title="🔹 6. ViewModel + Room 持久化数据库数据"></a><strong>🔹 6. ViewModel + Room 持久化数据库数据</strong></h2><p>如果你使用 <code>Room</code> 存储数据，<code>ViewModel</code> 可以直接从 <code>Room</code> 获取 <code>LiveData</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface DiaryDao &#123;</span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">    fun getAllDiaries(): LiveData&lt;List&lt;DiaryEntry&gt;&gt; // LiveData 监听数据库</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val diaryList: LiveData&lt;List&lt;DiaryEntry&gt;&gt; = diaryDao.getAllDiaries()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Fragment</code> 观察数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diaryViewModel.diaryList.observe(viewLifecycleOwner) &#123; diaryList -&gt;</span><br><span class="line">    diaryAdapter.submitList(diaryList) // 更新 UI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>Room + ViewModel + LiveData 确保数据持久化，并自动更新 UI</strong>。</p><hr><h2 id="🔹-7-ViewModel-Kotlin-Flow（协程）"><a href="#🔹-7-ViewModel-Kotlin-Flow（协程）" class="headerlink" title="🔹 7. ViewModel + Kotlin Flow（协程）"></a><strong>🔹 7. ViewModel + Kotlin Flow（协程）</strong></h2><p>如果你用 <code>Flow</code>，可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val diaryListFlow = diaryDao.getAllDiariesFlow()</span><br><span class="line">        .stateIn(viewModelScope, SharingStarted.Lazily, emptyList()) // 转为 StateFlow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Fragment</code> 中 <code>collect</code> 数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    viewModel.diaryListFlow.collect &#123; diaryList -&gt;</span><br><span class="line">        diaryAdapter.submitList(diaryList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong><code>Flow</code> 更适合复杂数据流（如数据库、网络请求）</strong>。</p><hr><h2 id="🔹-8-ViewModel-生命周期"><a href="#🔹-8-ViewModel-生命周期" class="headerlink" title="🔹 8. ViewModel 生命周期"></a><strong>🔹 8. ViewModel 生命周期</strong></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>ViewModel 作用</strong></th></tr></thead><tbody><tr><td>旋转屏幕</td><td>保持数据不丢失</td></tr><tr><td>App 进后台</td><td>ViewModel 可能被销毁（可用 <code>SavedStateHandle</code> 处理）</td></tr><tr><td>Fragment 切换</td><td>共享 <code>ViewModel</code> 以保留数据</td></tr></tbody></table><hr><h2 id="🔹-总结"><a href="#🔹-总结" class="headerlink" title="🔹 总结"></a><strong>🔹 总结</strong></h2><p>✅ <code>ViewModel</code> <strong>用于管理 UI 相关数据，避免因屏幕旋转导致数据丢失</strong>。<br> ✅ 搭配 <code>LiveData</code> <strong>自动通知 UI 变化</strong>。<br> ✅ <code>ViewModel</code> + <code>Room</code> <strong>可以自动监听数据库变化</strong>。<br> ✅ <code>ViewModel</code> + <code>Flow</code> <strong>适合复杂数据流处理</strong>。<br> ✅ <code>ViewModelFactory</code> <strong>用于创建带参数的 ViewModel</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Room用法</title>
      <link href="/2025/03/15/Room%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/Room%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Room 是 Android 官方推荐的数据库框架，它是 SQLite 的抽象封装，提供了更便捷的数据库操作方式，支持 Kotlin 协程和 LiveData。以下是 Room 的基本使用方法：</p><hr><h2 id="1-添加-Room-依赖"><a href="#1-添加-Room-依赖" class="headerlink" title="1. 添加 Room 依赖"></a><strong>1. 添加 Room 依赖</strong></h2><p>在 <code>build.gradle.kts</code>（模块级）中添加 Room 相关依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    val room_version = &quot;2.6.1&quot; // 确保使用最新版本</span><br><span class="line"></span><br><span class="line">    implementation(&quot;androidx.room:room-runtime:$room_version&quot;)</span><br><span class="line">    kapt(&quot;androidx.room:room-compiler:$room_version&quot;) // 用于注解处理器</span><br><span class="line"></span><br><span class="line">    implementation(&quot;androidx.room:room-ktx:$room_version&quot;) // 支持 Kotlin 协程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果项目使用 Kotlin Symbol Processing (KSP) 代替 kapt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ksp(&quot;androidx.room:room-compiler:$room_version&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="2-创建数据库实体（Entity）"><a href="#2-创建数据库实体（Entity）" class="headerlink" title="2. 创建数据库实体（Entity）"></a><strong>2. 创建数据库实体（Entity）</strong></h2><p>使用 <code>@Entity</code> 注解定义数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.Entity</span><br><span class="line">import androidx.room.PrimaryKey</span><br><span class="line"></span><br><span class="line">@Entity(tableName = &quot;diary_entries&quot;) // 指定表名</span><br><span class="line">data class DiaryEntry(</span><br><span class="line">    @PrimaryKey(autoGenerate = true) val id: Int = 0, // 主键，自动生成</span><br><span class="line">    val title: String,</span><br><span class="line">    val content: String,</span><br><span class="line">    val date: Long, // 以时间戳形式存储日期</span><br><span class="line">    val weather: String? = null</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="3-创建-DAO（数据访问对象）"><a href="#3-创建-DAO（数据访问对象）" class="headerlink" title="3. 创建 DAO（数据访问对象）"></a><strong>3. 创建 DAO（数据访问对象）</strong></h2><p>DAO 负责数据库的 CRUD 操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.*</span><br><span class="line"></span><br><span class="line">@Dao</span><br><span class="line">interface DiaryDao &#123;</span><br><span class="line">    @Insert(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    suspend fun insertDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    suspend fun updateDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    suspend fun deleteDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">    fun getAllDiaries(): List&lt;DiaryEntry&gt; // 直接返回列表（不推荐，建议使用 Flow）</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries WHERE id = :id&quot;)</span><br><span class="line">    suspend fun getDiaryById(id: Int): DiaryEntry?</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries WHERE title LIKE &#x27;%&#x27; || :query || &#x27;%&#x27;&quot;)</span><br><span class="line">    fun searchDiaries(query: String): List&lt;DiaryEntry&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要监听数据变化，可以用 <code>Flow</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">fun getAllDiariesFlow(): Flow&lt;List&lt;DiaryEntry&gt;&gt; // 使用 Flow 以支持实时监听</span><br></pre></td></tr></table></figure><hr><h2 id="4-创建数据库（Database）"><a href="#4-创建数据库（Database）" class="headerlink" title="4. 创建数据库（Database）"></a><strong>4. 创建数据库（Database）</strong></h2><p>使用 <code>@Database</code> 注解创建 Room 数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import androidx.room.Database</span><br><span class="line">import androidx.room.Room</span><br><span class="line">import androidx.room.RoomDatabase</span><br><span class="line"></span><br><span class="line">@Database(entities = [DiaryEntry::class], version = 1, exportSchema = false)</span><br><span class="line">abstract class DiaryDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun diaryDao(): DiaryDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile</span><br><span class="line">        private var INSTANCE: DiaryDatabase? = null</span><br><span class="line"></span><br><span class="line">        fun getDatabase(context: Context): DiaryDatabase &#123;</span><br><span class="line">            return INSTANCE ?: synchronized(this) &#123;</span><br><span class="line">                val instance = Room.databaseBuilder(</span><br><span class="line">                    context.applicationContext,</span><br><span class="line">                    DiaryDatabase::class.java,</span><br><span class="line">                    &quot;diary_database&quot;</span><br><span class="line">                ).build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：</p><ul><li><code>@Volatile</code> 确保多个线程能正确访问 <code>INSTANCE</code>。</li><li><code>synchronized(this)</code> 确保数据库实例的单例模式。</li></ul></blockquote><hr><h2 id="5-在-ViewModel-中使用"><a href="#5-在-ViewModel-中使用" class="headerlink" title="5. 在 ViewModel 中使用"></a><strong>5. 在 ViewModel 中使用</strong></h2><p>在 <code>ViewModel</code> 里封装数据库操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import kotlinx.coroutines.flow.Flow</span><br><span class="line"></span><br><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val allDiaries: Flow&lt;List&lt;DiaryEntry&gt;&gt; = diaryDao.getAllDiariesFlow()</span><br><span class="line"></span><br><span class="line">    suspend fun addDiary(entry: DiaryEntry) &#123;</span><br><span class="line">        diaryDao.insertDiary(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun deleteDiary(entry: DiaryEntry) &#123;</span><br><span class="line">        diaryDao.deleteDiary(entry)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>viewmodel</code> 目录下新建 <code>DiaryViewModelFactory.kt</code> 文件，并写入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import androidx.lifecycle.ViewModelProvider</span><br><span class="line">import com.example.uibestpractice.data.DiaryDao // 替换为你的包名</span><br><span class="line"></span><br><span class="line">class DiaryViewModelFactory(private val diaryDao: DiaryDao) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(DiaryViewModel::class.java)) &#123;</span><br><span class="line">            return DiaryViewModel(diaryDao) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-在-Activity-Fragment-中使用"><a href="#6-在-Activity-Fragment-中使用" class="headerlink" title="6. 在 Activity&#x2F;Fragment 中使用"></a><strong>6. 在 Activity&#x2F;Fragment 中使用</strong></h2><p>在 <code>Activity</code> 或 <code>Fragment</code> 里使用 ViewModel：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.activity.viewModels</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val diaryViewModel: DiaryViewModel by viewModels &#123;</span><br><span class="line">        DiaryViewModelFactory(DiaryDatabase.getDatabase(this).diaryDao())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        // 监听数据库变化</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            diaryViewModel.allDiaries.collect &#123; diaryList -&gt;</span><br><span class="line">                // 更新 UI</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun addDiaryEntry() &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            val newEntry = DiaryEntry(title = &quot;新日记&quot;, content = &quot;今天很开心！&quot;, date = System.currentTimeMillis())</span><br><span class="line">            diaryViewModel.addDiary(newEntry)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="7-线程调度（协程）"><a href="#7-线程调度（协程）" class="headerlink" title="7. 线程调度（协程）"></a><strong>7. 线程调度（协程）</strong></h2><p>Room 允许在 <code>suspend</code> 函数中调用数据库操作，Kotlin 协程会自动切换到 IO 线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun insertDiary(entry: DiaryEntry) &#123;</span><br><span class="line">    diaryDao.insertDiary(entry) // Room 在 IO 线程执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <strong>不支持协程的函数</strong>（如 <code>getAllDiaries()</code>），应使用 <code>withContext(Dispatchers.IO)</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun getAllDiariesBlocking(): List&lt;DiaryEntry&gt; &#123;</span><br><span class="line">    return runBlocking &#123; withContext(Dispatchers.IO) &#123; diaryDao.getAllDiaries() &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Room 提供了 <strong>简单、安全、高效</strong> 的数据库管理：</p><ol><li><strong>Entity</strong>（表） → <code>@Entity</code></li><li><strong>DAO</strong>（数据操作） → <code>@Dao</code></li><li><strong>Database</strong>（数据库实例） → <code>@Database</code></li><li><strong>ViewModel</strong>（封装业务逻辑）</li><li><strong>Activity&#x2F;Fragment</strong>（UI 层使用数据库）</li></ol><p>你可以结合 <code>Flow</code> 进行 <strong>实时监听</strong>，结合 <strong>Kotlin 协程</strong> 进行 <strong>异步处理</strong>，使数据库操作更加流畅高效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>startActivity和registerForActivityResult的用法</title>
      <link href="/2025/03/14/startActivity%E5%92%8CregisterForActivityResult%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/14/startActivity%E5%92%8CregisterForActivityResult%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 Android Kotlin 开发中，<code>startActivity</code> 和 <code>registerForActivityResult</code> 是启动新 Activity 并处理返回结果的两种方式。</p><hr><h2 id="1-使用-startActivity"><a href="#1-使用-startActivity" class="headerlink" title="1. 使用 startActivity"></a>1. 使用 <code>startActivity</code></h2><p><code>startActivity</code> 适用于 <strong>不需要获取返回值</strong> 的情况，例如从 <code>MainActivity</code> 跳转到 <code>SecondActivity</code>：</p><h3 id="示例：启动新-Activity"><a href="#示例：启动新-Activity" class="headerlink" title="示例：启动新 Activity"></a><strong>示例：启动新 Activity</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>如果你需要传递数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java).apply &#123;</span><br><span class="line">    putExtra(&quot;key&quot;, &quot;Hello, SecondActivity!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>在 <code>SecondActivity</code> 中获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val data = intent.getStringExtra(&quot;key&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="2-使用-registerForActivityResult"><a href="#2-使用-registerForActivityResult" class="headerlink" title="2. 使用 registerForActivityResult"></a>2. 使用 <code>registerForActivityResult</code></h2><p><code>registerForActivityResult</code> 适用于 <strong>需要从子 Activity 返回数据</strong> 的情况，比如用户选择了一个文件或拍照后返回图片。</p><h3 id="示例：启动-Activity-并获取返回值"><a href="#示例：启动-Activity-并获取返回值" class="headerlink" title="示例：启动 Activity 并获取返回值"></a><strong>示例：启动 Activity 并获取返回值</strong></h3><p>先在主 Activity 中注册一个 <code>ActivityResultLauncher</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private val launcher=registerForActivityResult(ActivityResultContracts.StartActivityForResult())&#123; result -&gt;</span><br><span class="line">    if (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        val data = result.data?.getStringExtra(&quot;result_key&quot;)</span><br><span class="line">        Toast.makeText(this, &quot;收到返回值: $data&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 <code>launcher.launch(intent)</code> 启动新 Activity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java)</span><br><span class="line">launcher.launch(intent)</span><br></pre></td></tr></table></figure><h3 id="在-SecondActivity-处理返回数据"><a href="#在-SecondActivity-处理返回数据" class="headerlink" title="在 SecondActivity 处理返回数据"></a><strong>在 SecondActivity 处理返回数据</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val resultIntent = Intent().apply &#123;</span><br><span class="line">    putExtra(&quot;result_key&quot;, &quot;返回的数据&quot;)</span><br><span class="line">&#125;</span><br><span class="line">setResult(Activity.RESULT_OK, resultIntent)</span><br><span class="line">finish()</span><br></pre></td></tr></table></figure><hr><h2 id="3-startActivityForResult-已废弃"><a href="#3-startActivityForResult-已废弃" class="headerlink" title="3. startActivityForResult 已废弃"></a>3. <code>startActivityForResult</code> 已废弃</h2><p><code>startActivityForResult</code> 在 API 30（Android 11）开始被 <strong>弃用</strong>，官方推荐使用 <code>registerForActivityResult</code> 代替。</p><p>如果你的代码仍然使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">startActivityForResult(intent, REQUEST_CODE)</span><br></pre></td></tr></table></figure><p>则应改用 <code>registerForActivityResult</code>。</p><hr><h2 id="4-其他-ActivityResultContracts"><a href="#4-其他-ActivityResultContracts" class="headerlink" title="4. 其他 ActivityResultContracts"></a>4. 其他 <code>ActivityResultContracts</code></h2><p><code>registerForActivityResult</code> 还支持多种 <code>ActivityResultContracts</code>，如：</p><ul><li><code>ActivityResultContracts.RequestPermission()</code>（请求单个权限）</li><li><code>ActivityResultContracts.GetContent()</code>（选择文件）</li><li><code>ActivityResultContracts.TakePicture()</code>（拍照）</li></ul><h3 id="示例：获取图片"><a href="#示例：获取图片" class="headerlink" title="示例：获取图片"></a><strong>示例：获取图片</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private val getImage = registerForActivityResult(ActivityResultContracts.GetContent()) &#123; uri: Uri? -&gt;</span><br><span class="line">    uri?.let &#123;</span><br><span class="line">        imageView.setImageURI(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    getImage.launch(&quot;image/*&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>总结：</strong></p><ul><li><code>startActivity()</code> 适用于无返回值的跳转。</li><li><code>registerForActivityResult()</code> 适用于需要获取返回值的情况，并且比 <code>startActivityForResult()</code> 更推荐。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit用法示例</title>
      <link href="/2025/03/14/Retrofit%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/14/Retrofit%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>Retrofit 使用指南</strong></p><p><code>Retrofit</code> 是 Android 上最常用的网络请求库之一，它简化了 HTTP 请求的处理，支持 <strong>GET、POST、PUT、DELETE</strong> 等请求方式，并且可以配合 <code>Gson</code>、<code>Moshi</code> 等解析 JSON 数据。</p><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a><strong>1. 添加依赖</strong></h2><p>在 <code>build.gradle</code> (Module 级) 中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span><br><span class="line">    implementation &#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27; // Gson 解析 JSON</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-创建-API-接口"><a href="#2-创建-API-接口" class="headerlink" title="2. 创建 API 接口"></a><strong>2. 创建 API 接口</strong></h2><p>定义 API 接口，例如获取用户信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import retrofit2.Call</span><br><span class="line">import retrofit2.http.GET</span><br><span class="line">import retrofit2.http.POST</span><br><span class="line">import retrofit2.http.PUT</span><br><span class="line">import retrofit2.http.DELETE</span><br><span class="line">import retrofit2.http.Body</span><br><span class="line">import retrofit2.http.Path</span><br><span class="line">import retrofit2.http.Header</span><br><span class="line"></span><br><span class="line">interface ApiService &#123;</span><br><span class="line">    @GET(&quot;users/&#123;id&#125;&quot;)  // GET 请求</span><br><span class="line">    fun getUser(@Path(&quot;id&quot;) userId: Int): Call&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    @POST(&quot;users&quot;)  // POST 请求</span><br><span class="line">    fun createUser(@Body user: User): Call&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    @PUT(&quot;users/&#123;id&#125;&quot;)  // PUT 请求</span><br><span class="line">    fun updateUser(@Path(&quot;id&quot;) userId: Int, @Body user: User): Call&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    @DELETE(&quot;users/&#123;id&#125;&quot;)  // DELETE 请求</span><br><span class="line">    fun deleteUser(@Path(&quot;id&quot;) userId: Int): Call&lt;Void&gt;</span><br><span class="line"></span><br><span class="line">    @GET(&quot;users/&#123;id&#125;&quot;)  // 添加自定义 Header</span><br><span class="line">    fun getUserWithHeader(@Path(&quot;id&quot;) userId: Int, @Header(&quot;Authorization&quot;) token: String): Call&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-定义数据模型"><a href="#3-定义数据模型" class="headerlink" title="3. 定义数据模型"></a><strong>3. 定义数据模型</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class User(</span><br><span class="line">    val id: Int,</span><br><span class="line">    val name: String,</span><br><span class="line">    val email: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="4-创建-Retrofit-实例"><a href="#4-创建-Retrofit-实例" class="headerlink" title="4. 创建 Retrofit 实例"></a><strong>4. 创建 Retrofit 实例</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import retrofit2.Retrofit</span><br><span class="line">import retrofit2.converter.gson.GsonConverterFactory</span><br><span class="line"></span><br><span class="line">object RetrofitClient &#123;</span><br><span class="line">    private const val BASE_URL = &quot;https://api.example.com/&quot;</span><br><span class="line"></span><br><span class="line">    val instance: ApiService by lazy &#123;</span><br><span class="line">        Retrofit.Builder()</span><br><span class="line">            .baseUrl(BASE_URL)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line">            .create(ApiService::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-发起网络请求"><a href="#5-发起网络请求" class="headerlink" title="5. 发起网络请求"></a><strong>5. 发起网络请求</strong></h2><h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a><strong>GET 请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val call = RetrofitClient.instance.getUser(1)</span><br><span class="line">call.enqueue(object : retrofit2.Callback&lt;User&gt; &#123;</span><br><span class="line">    override fun onResponse(call: Call&lt;User&gt;, response: retrofit2.Response&lt;User&gt;) &#123;</span><br><span class="line">        if (response.isSuccessful) &#123;</span><br><span class="line">            val user = response.body()</span><br><span class="line">            println(&quot;用户信息: $&#123;user?.name&#125;, $&#123;user?.email&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onFailure(call: Call&lt;User&gt;, t: Throwable) &#123;</span><br><span class="line">        println(&quot;请求失败: $&#123;t.message&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a><strong>POST 请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val newUser = User(0, &quot;John Doe&quot;, &quot;john@example.com&quot;)</span><br><span class="line">val call = RetrofitClient.instance.createUser(newUser)</span><br></pre></td></tr></table></figure><h4 id="PUT-请求"><a href="#PUT-请求" class="headerlink" title="PUT 请求"></a><strong>PUT 请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val updatedUser = User(1, &quot;Updated Name&quot;, &quot;updated@example.com&quot;)</span><br><span class="line">val call = RetrofitClient.instance.updateUser(1, updatedUser)</span><br></pre></td></tr></table></figure><h4 id="DELETE-请求"><a href="#DELETE-请求" class="headerlink" title="DELETE 请求"></a><strong>DELETE 请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val call = RetrofitClient.instance.deleteUser(1)</span><br></pre></td></tr></table></figure><h4 id="添加-Header-请求"><a href="#添加-Header-请求" class="headerlink" title="添加 Header 请求"></a><strong>添加 Header 请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val token = &quot;Bearer your_token_here&quot;</span><br><span class="line">val call = RetrofitClient.instance.getUserWithHeader(1, token)</span><br></pre></td></tr></table></figure><h2 id="6-使用协程-Coroutine-优化请求"><a href="#6-使用协程-Coroutine-优化请求" class="headerlink" title="6. 使用协程 (Coroutine) 优化请求"></a><strong>6. 使用协程 (Coroutine) 优化请求</strong></h2><p>将 API 接口修改为使用 suspend 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ApiService &#123;</span><br><span class="line">    @GET(&quot;users/&#123;id&#125;&quot;)</span><br><span class="line">    suspend fun getUser(@Path(&quot;id&quot;) userId: Int): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ViewModel 中调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import androidx.lifecycle.viewModelScope</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">class UserViewModel : ViewModel() &#123;</span><br><span class="line">    fun fetchUser() &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                val user = RetrofitClient.instance.getUser(1)</span><br><span class="line">                println(&quot;用户信息: $&#123;user.name&#125;, $&#123;user.email&#125;&quot;)</span><br><span class="line">            &#125; catch (e: Exception) &#123;</span><br><span class="line">                println(&quot;请求失败: $&#123;e.message&#125;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h2><ul><li><strong>GET、POST、PUT、DELETE 基本请求</strong></li><li><strong>添加 Header 请求</strong></li><li><strong>使用 suspend + Coroutine 优化请求</strong></li></ul><p><strong>最后我想说想了解更多更全关于Rotrofit的知识去看书P451吧！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD命令大全</title>
      <link href="/2025/03/13/CMD%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2025/03/13/CMD%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CMD-命令大全：从入门到精通"><a href="#CMD-命令大全：从入门到精通" class="headerlink" title="CMD 命令大全：从入门到精通"></a>CMD 命令大全：从入门到精通</h1><p>命令提示符（CMD）是 Windows 操作系统中的命令行界面，允许用户通过输入命令来执行各种任务。它是一个强大的工具，适用于系统管理、网络配置、文件操作等多种场景。本文详细介绍了常用的 CMD 命令，帮助你从入门到精通 CMD。<strong>不过也可以直接打help寻找命令的。</strong></p><p>[参考来源](<a href="https://blog.csdn.net/m0_70474954/article/details/143496800">CMD 命令大全：从入门到精通_cmd命令-CSDN博客</a>)</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#cmd-%E5%9F%BA%E7%A1%80">CMD 基础</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">文件和目录操作命令</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4">系统信息获取命令</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4">网络配置命令</a></li><li><a href="#%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">磁盘和文件系统操作命令</a></li><li><a href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6">批处理文件</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li><li><a href="#cmd-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7">CMD 高级技巧</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">常见问题与解决方案</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ol><hr><h2 id="CMD-基础"><a href="#CMD-基础" class="headerlink" title="CMD 基础"></a>CMD 基础</h2><h3 id="1-1-打开-CMD"><a href="#1-1-打开-CMD" class="headerlink" title="1.1 打开 CMD"></a>1.1 打开 CMD</h3><p>在 Windows 中，可通过以下方式打开命令提示符：</p><ul><li>按 <code>Win + R</code>，输入 <code>cmd</code>，然后按 <code>Enter</code>。</li><li>在开始菜单中搜索 “cmd” 或 “命令提示符”。</li></ul><h3 id="1-2-常用命令格式"><a href="#1-2-常用命令格式" class="headerlink" title="1.2 常用命令格式"></a>1.2 常用命令格式</h3><p>CMD 命令通常遵循以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 [参数]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /w</span><br></pre></td></tr></table></figure><p>其中 <code>dir</code> 是命令，<code>/w</code> 是参数。</p><hr><h2 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h2><h3 id="2-1-查看当前目录"><a href="#2-1-查看当前目录" class="headerlink" title="2.1 查看当前目录"></a>2.1 查看当前目录</h3><p>使用 <code>cd</code> 命令显示当前工作目录的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure><h3 id="2-2-列出目录中的文件"><a href="#2-2-列出目录中的文件" class="headerlink" title="2.2 列出目录中的文件"></a>2.2 列出目录中的文件</h3><p>使用 <code>dir</code> 命令列出当前目录中的所有文件和子目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><h3 id="2-3-进入目录"><a href="#2-3-进入目录" class="headerlink" title="2.3 进入目录"></a>2.3 进入目录</h3><p>使用 <code>cd [目录路径]</code> 进入指定目录。例如，进入 <code>D:\Documents</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd D:\Documents</span><br></pre></td></tr></table></figure><h3 id="2-4-返回上一级目录"><a href="#2-4-返回上一级目录" class="headerlink" title="2.4 返回上一级目录"></a>2.4 返回上一级目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><h3 id="2-5-创建新目录"><a href="#2-5-创建新目录" class="headerlink" title="2.5 创建新目录"></a>2.5 创建新目录</h3><p>使用 <code>mkdir [目录名]</code> 创建新目录。例如，创建一个名为 <code>NewFolder</code> 的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir NewFolder</span><br></pre></td></tr></table></figure><h3 id="2-6-删除目录"><a href="#2-6-删除目录" class="headerlink" title="2.6 删除目录"></a>2.6 删除目录</h3><p>使用 <code>rmdir [目录名]</code> 删除空目录。如果要删除非空目录，请使用 <code>/s</code> 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /s [目录名]</span><br></pre></td></tr></table></figure><h3 id="2-7-复制文件"><a href="#2-7-复制文件" class="headerlink" title="2.7 复制文件"></a>2.7 复制文件</h3><p>使用 <code>copy [源文件路径] [目标路径]</code> 复制文件。例如，将 <code>file.txt</code> 复制到 <code>D:\Backup</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy file.txt D:\Backup</span><br></pre></td></tr></table></figure><h3 id="2-8-移动文件"><a href="#2-8-移动文件" class="headerlink" title="2.8 移动文件"></a>2.8 移动文件</h3><p>使用 <code>move [源文件路径] [目标路径]</code> 移动文件。例如，将 <code>file.txt</code> 移动到 <code>D:\Documents</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move file.txt D:\Documents</span><br></pre></td></tr></table></figure><h3 id="2-9-删除文件"><a href="#2-9-删除文件" class="headerlink" title="2.9 删除文件"></a>2.9 删除文件</h3><p>使用 <code>del [文件名]</code> 删除文件。例如，删除 <code>file.txt</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del file.txt</span><br></pre></td></tr></table></figure><h3 id="2-10-重命名文件"><a href="#2-10-重命名文件" class="headerlink" title="2.10 重命名文件"></a>2.10 重命名文件</h3><p>使用 <code>ren [旧文件名] [新文件名]</code> 重命名文件。例如，将 <code>oldfile.txt</code> 重命名为 <code>newfile.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren oldfile.txt newfile.txt</span><br></pre></td></tr></table></figure><hr><h2 id="系统信息获取命令"><a href="#系统信息获取命令" class="headerlink" title="系统信息获取命令"></a>系统信息获取命令</h2><h3 id="3-1-查看系统信息"><a href="#3-1-查看系统信息" class="headerlink" title="3.1 查看系统信息"></a>3.1 查看系统信息</h3><p>使用 <code>systeminfo</code> 显示计算机的详细信息（操作系统版本、内存、网络适配器等）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><h3 id="3-2-查看当前用户"><a href="#3-2-查看当前用户" class="headerlink" title="3.2 查看当前用户"></a>3.2 查看当前用户</h3><p>使用 <code>whoami</code> 显示当前登录的用户名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><h3 id="3-3-查看计算机名"><a href="#3-3-查看计算机名" class="headerlink" title="3.3 查看计算机名"></a>3.3 查看计算机名</h3><p>使用 <code>hostname</code> 显示计算机的主机名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure><h3 id="3-4-查看进程列表"><a href="#3-4-查看进程列表" class="headerlink" title="3.4 查看进程列表"></a>3.4 查看进程列表</h3><p>使用 <code>tasklist</code> 列出当前运行的所有进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><h3 id="3-5-结束进程"><a href="#3-5-结束进程" class="headerlink" title="3.5 结束进程"></a>3.5 结束进程</h3><p>使用 <code>taskkill /IM [进程名] /F</code> 强制结束指定进程。例如，结束 <code>notepad.exe</code> 进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /IM notepad.exe /F</span><br></pre></td></tr></table></figure><hr><h2 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h2><h3 id="4-1-查看-IP-配置"><a href="#4-1-查看-IP-配置" class="headerlink" title="4.1 查看 IP 配置"></a>4.1 查看 IP 配置</h3><p>使用 <code>ipconfig</code> 显示计算机的 IP 地址、子网掩码和默认网关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><h3 id="4-2-刷新-IP-地址"><a href="#4-2-刷新-IP-地址" class="headerlink" title="4.2 刷新 IP 地址"></a>4.2 刷新 IP 地址</h3><p>使用以下命令释放并更新 DHCP 分配的 IP 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /release</span><br><span class="line">ipconfig /renew</span><br></pre></td></tr></table></figure><h3 id="4-3-查看网络连接"><a href="#4-3-查看网络连接" class="headerlink" title="4.3 查看网络连接"></a>4.3 查看网络连接</h3><p>使用 <code>netstat</code> 显示当前所有网络连接和监听端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br></pre></td></tr></table></figure><h3 id="4-4-测试网络连接"><a href="#4-4-测试网络连接" class="headerlink" title="4.4 测试网络连接"></a>4.4 测试网络连接</h3><p>使用 <code>ping [IP 地址或域名]</code> 测试网络连接。例如，测试与 Google 的连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.google.com</span><br></pre></td></tr></table></figure><h3 id="4-5-追踪路由"><a href="#4-5-追踪路由" class="headerlink" title="4.5 追踪路由"></a>4.5 追踪路由</h3><p>使用 <code>tracert [IP 地址或域名]</code> 追踪网络路由。例如，追踪到 Google 的路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert www.google.com</span><br></pre></td></tr></table></figure><hr><h2 id="磁盘和文件系统操作命令"><a href="#磁盘和文件系统操作命令" class="headerlink" title="磁盘和文件系统操作命令"></a>磁盘和文件系统操作命令</h2><h3 id="5-1-查看磁盘使用情况"><a href="#5-1-查看磁盘使用情况" class="headerlink" title="5.1 查看磁盘使用情况"></a>5.1 查看磁盘使用情况</h3><p>使用以下命令显示每个逻辑磁盘的总大小和可用空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic logicaldisk get size,freespace,caption</span><br></pre></td></tr></table></figure><h3 id="5-2-格式化磁盘"><a href="#5-2-格式化磁盘" class="headerlink" title="5.2 格式化磁盘"></a>5.2 格式化磁盘</h3><p>使用 <code>format [驱动器:] /FS:[文件系统]</code> 格式化磁盘。例如，将 D 盘格式化为 NTFS 文件系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format D: /FS:NTFS</span><br></pre></td></tr></table></figure><h3 id="5-3-检查磁盘错误"><a href="#5-3-检查磁盘错误" class="headerlink" title="5.3 检查磁盘错误"></a>5.3 检查磁盘错误</h3><p>使用 <code>chkdsk [驱动器:]</code> 检查磁盘错误。例如，检查 C 盘错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkdsk C:</span><br></pre></td></tr></table></figure><h3 id="5-4-显示磁盘分区信息"><a href="#5-4-显示磁盘分区信息" class="headerlink" title="5.4 显示磁盘分区信息"></a>5.4 显示磁盘分区信息</h3><p>使用 <code>diskpart</code> 进入 DiskPart 工具，然后在提示符下输入 <code>list disk</code> 查看所有磁盘信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskpart</span><br></pre></td></tr></table></figure><hr><h2 id="批处理文件"><a href="#批处理文件" class="headerlink" title="批处理文件"></a>批处理文件</h2><p>批处理文件是包含多个 CMD 命令的文本文件，便于一次性执行一系列命令。</p><h3 id="6-1-创建批处理文件"><a href="#6-1-创建批处理文件" class="headerlink" title="6.1 创建批处理文件"></a>6.1 创建批处理文件</h3><p>使用文本编辑器（如 Notepad）创建一个 <code>.bat</code> 文件，并输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo Hello, World!</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="6-2-运行批处理文件"><a href="#6-2-运行批处理文件" class="headerlink" title="6.2 运行批处理文件"></a>6.2 运行批处理文件</h3><p>双击 <code>.bat</code> 文件，或在 CMD 中输入文件路径来运行该文件。</p><hr><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="7-1-查看环境变量"><a href="#7-1-查看环境变量" class="headerlink" title="7.1 查看环境变量"></a>7.1 查看环境变量</h3><p>使用 <code>set</code> 命令显示所有环境变量及其值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure><h3 id="7-2-设置环境变量"><a href="#7-2-设置环境变量" class="headerlink" title="7.2 设置环境变量"></a>7.2 设置环境变量</h3><p>使用 <code>set [变量名]=[值]</code> 设置环境变量。例如，设置名为 <code>MY_VAR</code> 的环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MY_VAR=Hello</span><br></pre></td></tr></table></figure><h3 id="7-3-删除环境变量"><a href="#7-3-删除环境变量" class="headerlink" title="7.3 删除环境变量"></a>7.3 删除环境变量</h3><p>将环境变量值设为空即可删除。例如，删除 <code>MY_VAR</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MY_VAR=</span><br></pre></td></tr></table></figure><hr><h2 id="CMD-高级技巧"><a href="#CMD-高级技巧" class="headerlink" title="CMD 高级技巧"></a>CMD 高级技巧</h2><h3 id="8-1-使用管道"><a href="#8-1-使用管道" class="headerlink" title="8.1 使用管道"></a>8.1 使用管道</h3><p>管道符号 <code>|</code> 可将一个命令的输出传递给另一个命令。例如，查找进程列表中包含 “chrome” 的进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | find &quot;chrome&quot;</span><br></pre></td></tr></table></figure><h3 id="8-2-使用重定向"><a href="#8-2-使用重定向" class="headerlink" title="8.2 使用重定向"></a>8.2 使用重定向</h3><p>重定向符 <code>&gt;</code> 可将命令的输出保存到文件中。例如，将 <code>dir</code> 命令的输出保存到 <code>output.txt</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir &gt; output.txt</span><br></pre></td></tr></table></figure><h3 id="8-3-批量重命名文件"><a href="#8-3-批量重命名文件" class="headerlink" title="8.3 批量重命名文件"></a>8.3 批量重命名文件</h3><p>使用 <code>for</code> 循环批量重命名文件。例如，将当前目录下的所有 <code>.txt</code> 文件重命名为 <code>.bak</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for %f in (*.txt) do ren &quot;%f&quot; &quot;*.bak&quot;</span><br></pre></td></tr></table></figure><p><em>注：在批处理文件中使用 for 循环时，需将 <code>%f</code> 替换为 <code>%%f</code>。</em></p><hr><h2 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h2><h3 id="9-1-CMD-无法识别命令"><a href="#9-1-CMD-无法识别命令" class="headerlink" title="9.1 CMD 无法识别命令"></a>9.1 CMD 无法识别命令</h3><ul><li>如果 CMD 提示 “不是内部或外部命令”，可能是因为命令输入错误或相应程序未安装。</li></ul><h3 id="9-2-权限不足"><a href="#9-2-权限不足" class="headerlink" title="9.2 权限不足"></a>9.2 权限不足</h3><ul><li>某些命令需要管理员权限。请右键点击 CMD 图标，选择“以管理员身份运行”。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了 CMD 的基本命令、文件和目录操作、系统信息获取、网络配置等内容。通过具体示例和操作说明，帮助你更好地理解和掌握 CMD 的使用。希望这份 CMD 命令大全能帮助你提高工作效率，成为 CMD 使用的高手！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task3 Android Diary</title>
      <link href="/2025/03/05/Task3-Diary/"/>
      <url>/2025/03/05/Task3-Diary/</url>
      
        <content type="html"><![CDATA[<h1 id="MY-API-KEY-和风"><a href="#MY-API-KEY-和风" class="headerlink" title="MY API KEY(和风)"></a>MY API KEY(和风)</h1><p>670ca929136a456992608cd2e794df24</p><h1 id="Mainactivity"><a href="#Mainactivity" class="headerlink" title="Mainactivity"></a>Mainactivity</h1><h2 id="超级好的Mainactivity"><a href="#超级好的Mainactivity" class="headerlink" title="超级好的Mainactivity"></a>超级好的Mainactivity</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line"></span><br><span class="line">import androidx.core.widget.addTextChangedListener</span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.BroadcastReceiver</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.IntentFilter</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line">import androidx.appcompat.app.AlertDialog</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.Observer</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import com.example.diary_3.adapter.DiaryAdapter</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityMainBinding</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var binding: ActivityMainBinding</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line">    private val addDiaryLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">        when (result.resultCode) &#123;</span><br><span class="line">            Activity.RESULT_OK -&gt; loadAllDiaries()</span><br><span class="line">            Activity.RESULT_CANCELED -&gt; &#123;&#125;</span><br><span class="line">            else -&gt; Log.d(&quot;MainActivity&quot;, &quot;未知的返回结果: $&#123;result.resultCode&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private val diarySavedReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            if (intent?.action == &quot;SAVED&quot;) &#123;</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        binding.recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line">        diaryAdapter = DiaryAdapter(this, emptyList())</span><br><span class="line">        binding.recyclerView.adapter = diaryAdapter</span><br><span class="line"></span><br><span class="line">        val filter = IntentFilter(&quot;SAVED&quot;)</span><br><span class="line">        registerReceiver(diarySavedReceiver, filter)</span><br><span class="line"></span><br><span class="line">        loadAllDiaries()</span><br><span class="line"></span><br><span class="line">        // 监听搜索框</span><br><span class="line">        binding.searchBox.addTextChangedListener &#123; text -&gt;</span><br><span class="line">            searchDiaries(text.toString())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 启动添加日记页面</span><br><span class="line">        binding.addDiaryButton.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this, AddDiaryActivity::class.java)</span><br><span class="line">            addDiaryLauncher.launch(intent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 绑定删除按钮</span><br><span class="line">        binding.deleteDiaryButton.setOnClickListener &#123;</span><br><span class="line">            deleteDiary()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除日记的方法</span><br><span class="line">    private fun deleteDiary() &#123;</span><br><span class="line">        val diaries = diaryAdapter.getCurrentDiaries()</span><br><span class="line">        if (diaries.isEmpty()) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;当前没有日记可删除&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val diaryTitles = diaries.map &#123; it.title &#125;.toTypedArray()</span><br><span class="line">        var selectedIndex = 0</span><br><span class="line"></span><br><span class="line">        AlertDialog.Builder(this)</span><br><span class="line">            .setTitle(&quot;选择要删除的日记&quot;)</span><br><span class="line">            .setSingleChoiceItems(diaryTitles, 0) &#123; _, which -&gt;</span><br><span class="line">                selectedIndex = which</span><br><span class="line">            &#125;</span><br><span class="line">            .setPositiveButton(&quot;删除&quot;) &#123; _, _ -&gt;</span><br><span class="line">                val diaryToDelete = diaries[selectedIndex]</span><br><span class="line">                lifecycleScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">                    diaryDatabase.diaryDao().deleteDiary(diaryToDelete)</span><br><span class="line">                    withContext(Dispatchers.Main) &#123;</span><br><span class="line">                        loadAllDiaries()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .setNegativeButton(&quot;取消&quot;, null)</span><br><span class="line">            .show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加载所有日记</span><br><span class="line">    private fun loadAllDiaries() &#123;</span><br><span class="line">        diaryDatabase.diaryDao().getDiaries().observe(this, Observer &#123; diaries -&gt;</span><br><span class="line">            diaryAdapter.updateData(diaries) // 更新数据</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 搜索日记</span><br><span class="line">    private fun searchDiaries(query: String) &#123;</span><br><span class="line">        diaryDatabase.diaryDao().searchDiaries(&quot;%$query%&quot;)</span><br><span class="line">            .observe(this, Observer &#123; diaries -&gt;</span><br><span class="line">                diaryAdapter.updateData(diaries)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        unregisterReceiver(diarySavedReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line">import androidx.core.widget.addTextChangedListener</span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.BroadcastReceiver</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.IntentFilter</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.text.Editable</span><br><span class="line">import android.text.TextWatcher</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line">import androidx.annotation.RequiresApi</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import androidx.room.InvalidationTracker</span><br><span class="line">import com.example.diary_3.adapter.DiaryAdapter</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityMainBinding</span><br><span class="line">import java.util.concurrent.Executors</span><br><span class="line">import kotlinx.coroutines.CoroutineScope</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line">import androidx.lifecycle.Observer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var binding: ActivityMainBinding</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private val addDiaryLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">        when (result.resultCode) &#123;</span><br><span class="line">            Activity.RESULT_OK -&gt; &#123;</span><br><span class="line">                // 如果有返回结果，刷新数据</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">            Activity.RESULT_CANCELED -&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; &#123;</span><br><span class="line">                // 处理其他可能的返回情况</span><br><span class="line">                Log.d(&quot;MainActivity&quot;, &quot;未知的返回结果: $&#123;result.resultCode&#125;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private val diarySavedReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            if (intent?.action == &quot;SAVED&quot;) &#123;</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//gl gd</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        binding.recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line">        diaryAdapter = DiaryAdapter(this, emptyList())</span><br><span class="line">        binding.recyclerView.adapter = diaryAdapter</span><br><span class="line">        val filter = IntentFilter(&quot;SAVED&quot;)</span><br><span class="line">        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) &#123;</span><br><span class="line">            registerReceiver(diarySavedReceiver, filter, Context.RECEIVER_NOT_EXPORTED)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            registerReceiver(diarySavedReceiver, filter, RECEIVER_NOT_EXPORTED)</span><br><span class="line">        &#125;//ys5 gd</span><br><span class="line">        loadAllDiaries()</span><br><span class="line">        binding.searchBox.addTextChangedListener &#123; text -&gt;</span><br><span class="line">            searchDiaries(text.toString())</span><br><span class="line">        &#125;//ys3 gd</span><br><span class="line">        // 使用 ActivityResultLauncher 启动 AddDiaryActivity</span><br><span class="line">        binding.addDiaryButton.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this, AddDiaryActivity::class.java)</span><br><span class="line">            addDiaryLauncher.launch(intent)</span><br><span class="line">        &#125;//ys4 gd</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun loadAllDiaries() &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            val diaries = withContext(Dispatchers.IO) &#123;</span><br><span class="line">                diaryDatabase.diaryDao().getAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">            diaryAdapter.updateData(diaries) // 更新数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//ys8 gd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun searchDiaries(query: String) &#123;</span><br><span class="line">        diaryDatabase.diaryDao().searchDiaries(&quot;%$query%&quot;)</span><br><span class="line">            .observe(this, object : Observer&lt;List&lt;Diary&gt;&gt; &#123;</span><br><span class="line">                override fun onChanged(diaries: List&lt;Diary&gt;) &#123;</span><br><span class="line">                    diaryAdapter = DiaryAdapter(this@MainActivity, diaries)</span><br><span class="line">                    binding.recyclerView.adapter = diaryAdapter</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;//ys9 gd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        unregisterReceiver(diarySavedReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="AddDiaryActivity"><a href="#AddDiaryActivity" class="headerlink" title="AddDiaryActivity"></a>AddDiaryActivity</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line">import androidx.appcompat.app.AlertDialog</span><br><span class="line">import android.view.View</span><br><span class="line">import android.widget.EditText</span><br><span class="line">import com.example.diary_3.utils.DateUtils</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.pm.PackageManager</span><br><span class="line">import android.net.Uri</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.os.Looper</span><br><span class="line">import android.provider.MediaStore</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.core.app.ActivityCompat</span><br><span class="line">import androidx.core.content.ContextCompat</span><br><span class="line">import com.bumptech.glide.Glide</span><br><span class="line">import com.bumptech.glide.request.RequestOptions</span><br><span class="line">import com.example.diary_3.R</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityAddDiaryBinding</span><br><span class="line">import com.example.diary_3.model.CityResponse</span><br><span class="line">import com.example.diary_3.model.WeatherResponse</span><br><span class="line">import com.example.diary_3.network.RetrofitClient</span><br><span class="line">import com.example.diary_3.network.WeatherApi</span><br><span class="line">import com.example.diary_3.utils.LocationUtils</span><br><span class="line">import retrofit2.Call</span><br><span class="line">import retrofit2.Callback</span><br><span class="line">import retrofit2.Response</span><br><span class="line">import java.util.Calendar</span><br><span class="line">import java.util.concurrent.Executors</span><br><span class="line"></span><br><span class="line">class AddDiaryActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val selectedLocalImageUris = mutableListOf&lt;Uri&gt;()</span><br><span class="line">    private val networkImageUrls = mutableListOf&lt;String&gt;()</span><br><span class="line">    private val API_KEY = &quot;670ca929136a456992608cd2e794df24&quot;</span><br><span class="line">    private lateinit var binding: ActivityAddDiaryBinding</span><br><span class="line">    private var selectedDate: Calendar = Calendar.getInstance()</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var locationUtils: LocationUtils</span><br><span class="line">    private val PERMISSION_REQUEST_CODE = 1</span><br><span class="line">    private var selectedLocalImageUri: Uri? = null</span><br><span class="line">    private var networkImageUrl: String? = null</span><br><span class="line"></span><br><span class="line">    private fun hasPermission(permission: String): Boolean &#123;</span><br><span class="line">        return ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityAddDiaryBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        locationUtils = LocationUtils(this)</span><br><span class="line"></span><br><span class="line">        binding.selectImageButton.setOnClickListener &#123;</span><br><span class="line">            pickLocalImage()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binding.addNetworkImageButton.setOnClickListener &#123;</span><br><span class="line">            // 创建一个输入框</span><br><span class="line">            val input = EditText(this)</span><br><span class="line">            input.hint = &quot;请输入有效的图片链接&quot;</span><br><span class="line"></span><br><span class="line">            // 构建对话框</span><br><span class="line">            AlertDialog.Builder(this)</span><br><span class="line">                .setTitle(&quot;输入图片URL&quot;)</span><br><span class="line">                .setView(input)</span><br><span class="line">                .setPositiveButton(&quot;确定&quot;) &#123; dialog, which -&gt;</span><br><span class="line">                    val url = input.text.toString().trim()</span><br><span class="line">                    if (url.isNotBlank()) &#123;</span><br><span class="line">                        networkImageUrl = url</span><br><span class="line">                        Glide.with(this)</span><br><span class="line">                            .load(url)</span><br><span class="line">                            .placeholder(R.drawable.loading_placeholder) // 加载过程中的占位符图片</span><br><span class="line">                            .apply(RequestOptions.circleCropTransform())</span><br><span class="line">                            .error(R.drawable.no) // 加载失败时显示的图片</span><br><span class="line">                            .into(binding.selectedImageView)</span><br><span class="line">                        binding.selectedImageView.visibility = View.VISIBLE</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Toast.makeText(this, &quot;请输入有效的图片链接&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                        binding.selectedImageView.visibility = View.GONE</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .setNegativeButton(&quot;取消&quot;) &#123; dialog, which -&gt;</span><br><span class="line">                    dialog.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">                .show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binding.saveDiaryButton.setOnClickListener &#123;</span><br><span class="line">            saveDiary()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 新增按钮：点击刷新地点和天气</span><br><span class="line">        binding.refreshWeatherLocationButton.setOnClickListener &#123;</span><br><span class="line">            getLocation()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val permissionsToRequest = mutableListOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        if (!hasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION)) &#123;</span><br><span class="line">            permissionsToRequest.add(android.Manifest.permission.ACCESS_FINE_LOCATION)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!hasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">            permissionsToRequest.add(android.Manifest.permission.READ_EXTERNAL_STORAGE)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (permissionsToRequest.isNotEmpty()) &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(</span><br><span class="line">                this,</span><br><span class="line">                permissionsToRequest.toTypedArray(),</span><br><span class="line">                PERMISSION_REQUEST_CODE</span><br><span class="line">            )</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            getLocation()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun pickLocalImage() &#123;</span><br><span class="line">        val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)</span><br><span class="line">        startActivityForResult(intent, 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123;</span><br><span class="line">        super.onActivityResult(requestCode, resultCode, data)</span><br><span class="line"></span><br><span class="line">        if (requestCode == 1 &amp;&amp; resultCode == RESULT_OK &amp;&amp; data != null) &#123;</span><br><span class="line">            selectedLocalImageUri = data.data</span><br><span class="line">            Glide.with(this)</span><br><span class="line">                .load(selectedLocalImageUri)</span><br><span class="line">                .into(binding.selectedImageView)</span><br><span class="line">            binding.selectedImageView.visibility = android.view.View.VISIBLE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getLocation() &#123;</span><br><span class="line">        locationUtils.getLocation &#123; location -&gt;</span><br><span class="line">            if (location != null) &#123;</span><br><span class="line">                val latitude = location.latitude</span><br><span class="line">                val longitude = location.longitude</span><br><span class="line">                Log.d(&quot;AddDiaryActivity&quot;, &quot;获取到的经纬度: 纬度 $latitude, 经度 $longitude&quot;)</span><br><span class="line">                // 格式化经纬度字符串，注意这里 longitude 和 latitude 的顺序可以根据接口要求调整</span><br><span class="line">                val loc = String.format(&quot;%.2f,%.2f&quot;, location.longitude, location.latitude)</span><br><span class="line">                Executors.newSingleThreadExecutor().execute &#123;</span><br><span class="line">                    runOnUiThread &#123;</span><br><span class="line">                        binding.locationTextView.text = loc</span><br><span class="line">                        getCityId(loc)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                runOnUiThread &#123;</span><br><span class="line">                    Toast.makeText(this, &quot;无法获取当前位置&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun showToastOnUiThread(message: String) &#123;</span><br><span class="line">        if (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                Toast.makeText(this, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getCityId(cityName: String) &#123;</span><br><span class="line">        val weatherApi = RetrofitClient.geoInstance.create(WeatherApi::class.java)</span><br><span class="line">        weatherApi.getCityInfo(API_KEY, cityName).enqueue(object : Callback&lt;CityResponse&gt; &#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;CityResponse&gt;, response: Response&lt;CityResponse&gt;) &#123;</span><br><span class="line">                if (response.isSuccessful &amp;&amp; response.body()?.code == &quot;200&quot;) &#123;</span><br><span class="line">                    val cityLocation = response.body()?.location?.firstOrNull()</span><br><span class="line">                    if (cityLocation != null) &#123;</span><br><span class="line">                        binding.locationTextView.text = cityLocation.name</span><br><span class="line">                        getWeatherInfo(cityLocation.id)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.e(&quot;AddDiaryActivity&quot;, &quot;获取城市 ID 失败: $&#123;response.message()&#125;, 响应代码: $&#123;response.code()&#125;, 响应体: $&#123;response.errorBody()?.string()&#125;&quot;)</span><br><span class="line">                    showToastOnUiThread(&quot;获取城市 ID 失败&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;CityResponse&gt;, t: Throwable) &#123;</span><br><span class="line">                Log.e(&quot;AddDiaryActivity&quot;, &quot;获取城市 ID 网络请求失败: $&#123;t.message&#125;&quot;, t)</span><br><span class="line">                showToastOnUiThread(&quot;获取城市 ID 网络请求失败&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getWeatherInfo(cityId: String) &#123;</span><br><span class="line">        val weatherApi = RetrofitClient.weatherInstance.create(WeatherApi::class.java)</span><br><span class="line">        weatherApi.getWeatherInfo(API_KEY, cityId).enqueue(object : Callback&lt;WeatherResponse&gt; &#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;WeatherResponse&gt;, response: Response&lt;WeatherResponse&gt;) &#123;</span><br><span class="line">                if (response.isSuccessful &amp;&amp; response.body()?.code == &quot;200&quot;) &#123;</span><br><span class="line">                    val today = DateUtils.formatDate(Calendar.getInstance().time)</span><br><span class="line">                    val todayWeather = response.body()?.daily?.firstOrNull &#123; it.fxDate == today &#125;</span><br><span class="line">                    if (todayWeather != null) &#123;</span><br><span class="line">                        val weatherText = todayWeather.textDay</span><br><span class="line">                        binding.weatherTextView.text = weatherText</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.e(&quot;AddDiaryActivity&quot;, &quot;获取天气信息失败: $&#123;response.message()&#125;, 响应代码: $&#123;response.code()&#125;, 响应体: $&#123;response.errorBody()?.string()&#125;&quot;)</span><br><span class="line">                    showToastOnUiThread(&quot;获取天气信息失败&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;WeatherResponse&gt;, t: Throwable) &#123;</span><br><span class="line">                Log.e(&quot;AddDiaryActivity&quot;, &quot;获取天气信息网络请求失败: $&#123;t.message&#125;&quot;, t)</span><br><span class="line">                showToastOnUiThread(&quot;获取天气信息网络请求失败&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun saveDiary() &#123;</span><br><span class="line">        Executors.newSingleThreadExecutor().execute &#123;</span><br><span class="line">            val title = binding.titleEditText.text.toString()</span><br><span class="line">            val content = binding.contentEditText.text.toString()</span><br><span class="line">            val localImagePath = selectedLocalImageUri?.toString()</span><br><span class="line">            val date = DateUtils.formatDate(Calendar.getInstance().time)</span><br><span class="line">            val weather = binding.weatherTextView.text.toString()</span><br><span class="line">            val location = binding.locationTextView.text.toString()</span><br><span class="line"></span><br><span class="line">            val diary = Diary(</span><br><span class="line">                title = title,</span><br><span class="line">                content = content,</span><br><span class="line">                localImagePath = localImagePath,</span><br><span class="line">                networkImageUrl = networkImageUrl,</span><br><span class="line">                date = date,</span><br><span class="line">                weather = weather,</span><br><span class="line">                location = location</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            diaryDatabase.diaryDao().insertDiary(diary)</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                Toast.makeText(this, &quot;日记保存成功&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                val intent = Intent(&quot;SAVED&quot;) // 或者 &quot;com.example.app.DIARY_SAVED&quot;</span><br><span class="line">                sendBroadcast(intent)</span><br><span class="line">                finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="DetailUtils"><a href="#DetailUtils" class="headerlink" title="DetailUtils"></a>DetailUtils</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final.utils</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Date</span><br><span class="line">import java.util.Locale</span><br><span class="line"></span><br><span class="line">object DateUtils &#123;</span><br><span class="line">    private const val DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;</span><br><span class="line"></span><br><span class="line">    // 线程安全的 SimpleDateFormat 生成</span><br><span class="line">    private fun getDateFormat(pattern: String): SimpleDateFormat &#123;</span><br><span class="line">        return SimpleDateFormat(pattern, Locale.getDefault())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 格式化日期（默认格式 &quot;yyyy-MM-dd&quot;）</span><br><span class="line">    fun formatDate(date: Date, pattern: String = DEFAULT_DATE_FORMAT): String &#123;</span><br><span class="line">        return getDateFormat(pattern).format(date)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取当前日期的格式化字符串</span><br><span class="line">    fun getCurrentDate(pattern: String = DEFAULT_DATE_FORMAT): String &#123;</span><br><span class="line">        return formatDate(Date(), pattern)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LocationUtils"><a href="#LocationUtils" class="headerlink" title="LocationUtils"></a>LocationUtils</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final.utils</span><br><span class="line"></span><br><span class="line">import android.Manifest</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.pm.PackageManager</span><br><span class="line">import android.location.Location</span><br><span class="line">import android.location.LocationListener</span><br><span class="line">import android.location.LocationManager</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.core.app.ActivityCompat</span><br><span class="line"></span><br><span class="line">class LocationUtils(private val context: Context) &#123;</span><br><span class="line"></span><br><span class="line">    private val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager</span><br><span class="line">    private var locationListener: LocationListener? = null</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前位置</span><br><span class="line">     */</span><br><span class="line">    fun getLocation(onLocationReceived: (Location) -&gt; Unit) &#123;</span><br><span class="line">        // 权限检查</span><br><span class="line">        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;</span><br><span class="line">            ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">        ) &#123;</span><br><span class="line">            return // 没有权限，直接返回</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取上次已知位置（可能会加快首次获取速度）</span><br><span class="line">        val lastKnownLocation: Location? = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER)</span><br><span class="line">            ?: locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)</span><br><span class="line">        if (lastKnownLocation != null) &#123;</span><br><span class="line">            onLocationReceived(lastKnownLocation)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 监听实时位置更新</span><br><span class="line">        locationListener = object : LocationListener &#123;</span><br><span class="line">            override fun onLocationChanged(location: Location) &#123;</span><br><span class="line">                onLocationReceived(location)</span><br><span class="line">                removeLocationUpdates() // 获取到位置后移除监听</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) &#123;&#125;</span><br><span class="line">            override fun onProviderEnabled(provider: String) &#123;&#125;</span><br><span class="line">            override fun onProviderDisabled(provider: String) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 请求位置更新（优先使用 GPS，网络作为备用）</span><br><span class="line">        try &#123;</span><br><span class="line">            locationManager.requestLocationUpdates(</span><br><span class="line">                LocationManager.GPS_PROVIDER,</span><br><span class="line">                5000L, // 5秒更新一次</span><br><span class="line">                10f,   // 10米变化更新</span><br><span class="line">                locationListener!!</span><br><span class="line">            )</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            locationManager.requestLocationUpdates(</span><br><span class="line">                LocationManager.NETWORK_PROVIDER,</span><br><span class="line">                5000L,</span><br><span class="line">                10f,</span><br><span class="line">                locationListener!!</span><br><span class="line">            )</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除位置更新监听，防止内存泄漏</span><br><span class="line">     */</span><br><span class="line">    fun removeLocationUpdates() &#123;</span><br><span class="line">        locationListener?.let &#123;</span><br><span class="line">            locationManager.removeUpdates(it)</span><br><span class="line">            locationListener = null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin语法</title>
      <link href="/2025/03/03/Kotlin%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/03/Kotlin%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-作用域函数"><a href="#1-作用域函数" class="headerlink" title="1. 作用域函数"></a>1. 作用域函数</h2><p>Kotlin 提供了一系列作用域函数，它们可以让你在对象的特定作用域内执行代码，从而避免重复引用对象（如 <code>this</code> 或 <code>it</code>），提高代码简洁性与可读性。</p><h3 id="1-1-apply-在对象自身作用域内修改对象"><a href="#1-1-apply-在对象自身作用域内修改对象" class="headerlink" title="1.1 apply - 在对象自身作用域内修改对象"></a>1.1 apply - 在对象自身作用域内修改对象</h3><ul><li><strong>返回值</strong>：调用者本身（this）</li><li><strong>使用场景</strong>：<ul><li>用于初始化对象，避免多次调用 set 方法</li><li>支持链式调用</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val person = Person().apply &#123;</span><br><span class="line">    name = &quot;Alice&quot;</span><br><span class="line">    age = 20</span><br><span class="line">&#125;</span><br><span class="line">println(person.name) // Alice</span><br><span class="line">println(person.age)  // 20</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br> 在 <code>apply</code> 的代码块中，<code>this</code> 代表当前对象，通过直接修改属性，最后返回修改后的对象本身。</p><hr><h3 id="1-2-let-适用于非空值的操作"><a href="#1-2-let-适用于非空值的操作" class="headerlink" title="1.2 let - 适用于非空值的操作"></a>1.2 let - 适用于非空值的操作</h3><ul><li><strong>返回值</strong>：Lambda 表达式的最后一行结果</li><li><strong>使用场景</strong>：<ul><li>针对可空对象进行操作，避免 NullPointerException</li><li>控制变量的作用域</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val name: String? = &quot;Kotlin&quot;</span><br><span class="line">name?.let &#123;</span><br><span class="line">    println(it.uppercase())  // KOTLIN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另一示例（变量作用域控制）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val number = 5</span><br><span class="line">val square = number.let &#123;</span><br><span class="line">    val result = it * it</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line">println(square) // 25</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-run-在对象作用域内执行代码并返回计算结果"><a href="#1-3-run-在对象作用域内执行代码并返回计算结果" class="headerlink" title="1.3 run - 在对象作用域内执行代码并返回计算结果"></a>1.3 run - 在对象作用域内执行代码并返回计算结果</h3><ul><li><strong>返回值</strong>：Lambda 表达式的最后一行结果</li><li><strong>使用场景</strong>：<ul><li>需要在对象上执行多个操作并返回一个结果</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val personInfo = Person().run &#123;</span><br><span class="line">    name = &quot;Bob&quot;</span><br><span class="line">    age = 25</span><br><span class="line">    &quot;名字是 $name, 年龄是 $age&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(personInfo)  // 名字是 Bob, 年龄是 25</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br> <code>run</code> 在对象作用域内执行操作，返回最后一行表达式的结果，而不是对象本身。</p><hr><h3 id="1-4-also-适用于对象的额外操作"><a href="#1-4-also-适用于对象的额外操作" class="headerlink" title="1.4 also - 适用于对象的额外操作"></a>1.4 also - 适用于对象的额外操作</h3><ul><li><strong>返回值</strong>：调用者本身（this）</li><li><strong>使用场景</strong>：<ul><li>记录日志、调试等额外操作，不改变对象本身</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = mutableListOf(1, 2, 3).also &#123;</span><br><span class="line">    println(&quot;原始列表: $it&quot;) // 输出：原始列表: [1, 2, 3]</span><br><span class="line">&#125;.apply &#123;</span><br><span class="line">    add(4)</span><br><span class="line">&#125;</span><br><span class="line">println(numbers) // 输出：[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br> <code>also</code> 用于执行副作用（如日志打印），返回原对象，而后续的 <code>apply</code> 则对对象进行修改。</p><hr><h3 id="1-5-with-用于非扩展对象的作用域调用"><a href="#1-5-with-用于非扩展对象的作用域调用" class="headerlink" title="1.5 with - 用于非扩展对象的作用域调用"></a>1.5 with - 用于非扩展对象的作用域调用</h3><ul><li><strong>返回值</strong>：Lambda 表达式的最后一行结果</li><li><strong>使用场景</strong>：<ul><li>对非扩展对象执行一系列操作，并返回计算结果</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val person = Person()</span><br><span class="line">val result = with(person) &#123;</span><br><span class="line">    name = &quot;Charlie&quot;</span><br><span class="line">    age = 30</span><br><span class="line">    &quot;名字: $name, 年龄: $age&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(result)  // 输出：名字: Charlie, 年龄: 30</span><br></pre></td></tr></table></figure><hr><h3 id="1-6-作用域函数对比总结"><a href="#1-6-作用域函数对比总结" class="headerlink" title="1.6 作用域函数对比总结"></a>1.6 作用域函数对比总结</h3><table><thead><tr><th>函数</th><th>使用场景</th><th>作用域内对象引用</th><th>返回值</th></tr></thead><tbody><tr><td><strong>apply</strong></td><td>修改对象本身</td><td><code>this</code></td><td>对象本身</td></tr><tr><td><strong>let</strong></td><td>针对可空对象或局部变量</td><td><code>it</code></td><td>Lambda 最后一行结果</td></tr><tr><td><strong>run</strong></td><td>执行操作并返回计算结果</td><td><code>this</code></td><td>Lambda 最后一行结果</td></tr><tr><td><strong>also</strong></td><td>执行额外操作（日志、调试等）</td><td><code>it</code></td><td>对象本身</td></tr><tr><td><strong>with</strong></td><td>对普通对象执行操作并返回结果</td><td><code>this</code></td><td>Lambda 最后一行结果</td></tr></tbody></table><p><strong>最佳实践提示：</strong></p><ul><li>修改对象并返回对象本身时，选择 <code>apply</code></li><li>针对可空对象操作时，选择 <code>let</code></li><li>需要返回计算结果时，选择 <code>run</code> 或 <code>with</code></li><li>仅执行副作用操作时，选择 <code>also</code></li></ul><hr><h2 id="2-时间输出"><a href="#2-时间输出" class="headerlink" title="2. 时间输出"></a>2. 时间输出</h2><p>下面的代码展示了如何在 Kotlin 中获取当前时间、格式化时间、解析字符串为日期，以及通过 Calendar 获取时间组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final</span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Calendar</span><br><span class="line">import java.util.Date</span><br><span class="line">import java.util.Locale</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    // 获取当前时间，并格式化为字符串</span><br><span class="line">    val date = Date() // 当前时间</span><br><span class="line">    val sdf = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())</span><br><span class="line">    val formattedDate = sdf.format(date)</span><br><span class="line">    println(formattedDate)  // 输出格式化日期，例如：2025-03-15 14:08:23</span><br><span class="line">    </span><br><span class="line">    // 将字符串解析为 Date 类型</span><br><span class="line">    val dateString = &quot;2025-03-09 14:45:30&quot;</span><br><span class="line">    val sdfp = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())</span><br><span class="line">    val datep = sdfp.parse(dateString)</span><br><span class="line">    println(datep)  // 输出: Sun Mar 09 14:45:30 GMT 2025</span><br><span class="line">    </span><br><span class="line">    // 使用 Calendar 获取当前时间的时、分、秒</span><br><span class="line">    val calendar = Calendar.getInstance()</span><br><span class="line">    val hour = calendar.get(Calendar.HOUR_OF_DAY)</span><br><span class="line">    val minute = calendar.get(Calendar.MINUTE)</span><br><span class="line">    val second = calendar.get(Calendar.SECOND)</span><br><span class="line">    println(&quot;当前时间: $hour:$minute:$second&quot;)</span><br><span class="line">    </span><br><span class="line">    // 格式化输出时间（24小时制）</span><br><span class="line">    val formattedTime = String.format(&quot;%02d:%02d:%02d&quot;, hour, minute, second)</span><br><span class="line">    println(&quot;当前时间: $formattedTime&quot;)</span><br><span class="line">    println(&quot;当前时间: $&#123;String.format(&quot;%02d:%02d:%02d&quot;, hour, minute, second)&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>使用 <code>SimpleDateFormat</code> 格式化和解析日期</li><li><code>Calendar</code> 用于提取当前时间的各个字段</li></ul><hr><h2 id="3-回调机制"><a href="#3-回调机制" class="headerlink" title="3. 回调机制"></a>3. 回调机制</h2><h3 id="3-1-什么是回调？"><a href="#3-1-什么是回调？" class="headerlink" title="3.1 什么是回调？"></a>3.1 什么是回调？</h3><p>回调类似于“任务完成后通知我”。例如，让朋友去买咖啡，买完后打电话告诉你。在编程中，回调指的是任务完成后自动调用的函数。</p><h3 id="3-2-示例：不使用回调（同步等待）"><a href="#3-2-示例：不使用回调（同步等待）" class="headerlink" title="3.2 示例：不使用回调（同步等待）"></a>3.2 示例：不使用回调（同步等待）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun buyGroceries() &#123;</span><br><span class="line">    Thread.sleep(2000) // 模拟买东西耗时2秒</span><br><span class="line">    println(&quot;买完了！&quot;) // 买完后通知</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;请帮我去买东西...&quot;)</span><br><span class="line">    buyGroceries()</span><br><span class="line">    println(&quot;我收到通知了&quot;) // 等待任务完成后执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：主线程会被阻塞，无法同时处理其他任务。</p><hr><h3 id="3-3-示例：使用回调（异步通知）"><a href="#3-3-示例：使用回调（异步通知）" class="headerlink" title="3.3 示例：使用回调（异步通知）"></a>3.3 示例：使用回调（异步通知）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun buyGroceries(callback: () -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        Thread.sleep(2000) // 模拟买东西耗时2秒</span><br><span class="line">        println(&quot;买完了！&quot;)</span><br><span class="line">        callback() // 任务完成后执行回调</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;请帮我去买东西...&quot;)</span><br><span class="line">    buyGroceries &#123;</span><br><span class="line">        println(&quot;我收到通知了！&quot;) // 任务完成后调用回调</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;我可以做别的事情，不用等&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br> 使用回调后，任务在后台执行，主线程可继续执行其他操作，待任务完成后自动调用回调函数。</p><hr><h3 id="3-4-回调在-Android-开发中的应用"><a href="#3-4-回调在-Android-开发中的应用" class="headerlink" title="3.4 回调在 Android 开发中的应用"></a>3.4 回调在 Android 开发中的应用</h3><ul><li><p><strong>按钮点击事件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    println(&quot;按钮被点击了！&quot;) // 按钮点击后的回调</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>网络请求：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun fetchData(callback: (String) -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        Thread.sleep(2000) // 模拟网络请求耗时</span><br><span class="line">        callback(&quot;数据加载成功了哈哈哈！&quot;)</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;开始请求数据...&quot;)</span><br><span class="line">    fetchData &#123; result -&gt;</span><br><span class="line">        println(result) // 数据返回后的回调</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;请求已经发送，我先做别的事情&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="4-Lambda-表达式"><a href="#4-Lambda-表达式" class="headerlink" title="4. Lambda 表达式"></a>4. Lambda 表达式</h2><h3 id="4-1-什么是-Lambda-表达式？"><a href="#4-1-什么是-Lambda-表达式？" class="headerlink" title="4.1 什么是 Lambda 表达式？"></a>4.1 什么是 Lambda 表达式？</h3><p>Lambda 表达式是匿名函数的一种写法，用于简化代码。其基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; 参数 -&gt; 表达式 &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-示例：基本用法"><a href="#4-2-示例：基本用法" class="headerlink" title="4.2 示例：基本用法"></a>4.2 示例：基本用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 Lambda 表达式，接受两个 Int 参数并返回它们的和</span><br><span class="line">val add: (Int, Int) -&gt; Int = &#123; a, b -&gt; a + b &#125;</span><br><span class="line">println(add(2, 3))  // 输出：5</span><br></pre></td></tr></table></figure><h3 id="4-3-Lambda-在高阶函数中的应用"><a href="#4-3-Lambda-在高阶函数中的应用" class="headerlink" title="4.3 Lambda 在高阶函数中的应用"></a>4.3 Lambda 在高阶函数中的应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个高阶函数，接受一个操作函数作为参数</span><br><span class="line">fun calculate(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;</span><br><span class="line">    return operation(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    // 使用尾随 Lambda 语法</span><br><span class="line">    val result = calculate(10, 5) &#123; x, y -&gt; x + y &#125;</span><br><span class="line">    println(result)  // 输出：15</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-单参数-Lambda-示例"><a href="#4-4-单参数-Lambda-示例" class="headerlink" title="4.4 单参数 Lambda 示例"></a>4.4 单参数 Lambda 示例</h3><p>当 Lambda 只有一个参数时，可以使用默认变量 <code>it</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val doubled = numbers.map &#123; it * 2 &#125;</span><br><span class="line">println(doubled)  // 输出：[2, 4, 6, 8]</span><br></pre></td></tr></table></figure><hr><h2 id="5-泛型与委托"><a href="#5-泛型与委托" class="headerlink" title="5. 泛型与委托"></a>5. 泛型与委托</h2><h3 id="5-1-泛型"><a href="#5-1-泛型" class="headerlink" title="5.1 泛型"></a>5.1 泛型</h3><p>泛型允许你编写适用于任意数据类型的通用代码，从而提高代码复用性和类型安全性。</p><h4 id="5-1-1-泛型类示例"><a href="#5-1-1-泛型类示例" class="headerlink" title="5.1.1 泛型类示例"></a>5.1.1 泛型类示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个泛型类 Box，可以存放任意类型的数据</span><br><span class="line">class Box&lt;T&gt;(var value: T)</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val intBox = Box(123)      // T 被推断为 Int</span><br><span class="line">    val strBox = Box(&quot;Hello&quot;)  // T 被推断为 String</span><br><span class="line">    println(intBox.value)      // 输出：123</span><br><span class="line">    println(strBox.value)      // 输出：Hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-泛型函数示例"><a href="#5-1-2-泛型函数示例" class="headerlink" title="5.1.2 泛型函数示例"></a>5.1.2 泛型函数示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个泛型函数，返回一个只包含一个元素的列表</span><br><span class="line">fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123;</span><br><span class="line">    return listOf(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val numbers = singletonList(42)      // T 被推断为 Int</span><br><span class="line">    val words = singletonList(&quot;Kotlin&quot;)    // T 被推断为 String</span><br><span class="line">    println(numbers) // 输出：[42]</span><br><span class="line">    println(words)   // 输出：[Kotlin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-3-类型参数的限定"><a href="#5-1-3-类型参数的限定" class="headerlink" title="5.1.3 类型参数的限定"></a>5.1.3 类型参数的限定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 泛型 T 限制为 Number 或其子类</span><br><span class="line">fun &lt;T : Number&gt; add(a: T, b: T): Double &#123;</span><br><span class="line">    return a.toDouble() + b.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(add(10, 20))      // 输出：30.0</span><br><span class="line">    // println(add(&quot;a&quot;, &quot;b&quot;)) // 错误，String 不是 Number 的子类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-4-协变与逆变"><a href="#5-1-4-协变与逆变" class="headerlink" title="5.1.4 协变与逆变"></a>5.1.4 协变与逆变</h4><h4 id="感觉不如书上P418讲得好"><a href="#感觉不如书上P418讲得好" class="headerlink" title="(感觉不如书上P418讲得好)"></a>(感觉不如书上P418讲得好)</h4><p><strong>1. 什么是协变和逆变？</strong></p><p>它们解决的是<strong>泛型的子类型关系</strong>，也就是<strong>泛型类 <code>A&lt;T&gt;</code> 和 <code>A&lt;U&gt;</code> 之间是否可以互相赋值</strong>。</p><p>先看普通的子类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑open class Parent</span><br><span class="line">class Child : Parent()</span><br><span class="line"></span><br><span class="line">val parent: Parent = Child() // ✅ 子类可以赋值给父类</span><br></pre></td></tr></table></figure><p>这个没问题，<code>Child</code> 是 <code>Parent</code> 的子类。但如果是<strong>泛型</strong>呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val childList: List&lt;Child&gt; = listOf(Child())</span><br><span class="line">// val parentList: List&lt;Parent&gt; = childList // ❌ 报错！</span><br></pre></td></tr></table></figure><p>Kotlin <strong>不允许</strong> <code>List&lt;Child&gt;</code> 赋值给 <code>List&lt;Parent&gt;</code>，因为泛型默认是**不变（Invariant）**的，即 <code>List&lt;Child&gt;</code> 和 <code>List&lt;Parent&gt;</code> 没有任何继承关系。</p><hr><h5 id="协变（Covariance）——-out-T"><a href="#协变（Covariance）——-out-T" class="headerlink" title="协变（Covariance）—— out T"></a><strong>协变（Covariance）—— <code>out T</code></strong></h5><p> <strong>让 <code>List&lt;Child&gt;</code> 赋值给 <code>List&lt;Parent&gt;</code></strong></p><p>如果我们想让 <code>List&lt;Child&gt;</code> 赋值给 <code>List&lt;Parent&gt;</code>，就要用<strong>协变</strong>（<code>out</code> 关键字）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> interface Producer&lt;out T&gt; &#123; // T 只能“生产”，不能“消费”</span><br><span class="line">    fun produce(): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val childProducer: Producer&lt;Child&gt; = object : Producer&lt;Child&gt; &#123;</span><br><span class="line">    override fun produce(): Child = Child()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 可以把 Producer&lt;Child&gt; 赋值给 Producer&lt;Parent&gt;</span><br><span class="line">val parentProducer: Producer&lt;Parent&gt; = childProducer</span><br></pre></td></tr></table></figure><p> <strong>为什么 <code>out</code> 只允许读取（生产）？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Producer&lt;out T&gt; &#123;</span><br><span class="line">    fun produce(): T // ✅ 只能提供 T</span><br><span class="line">    // fun consume(item: T) // ❌ 错误，不能接收 T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>out T</code> <strong>只能作为返回值（生产者）</strong>，不能作为参数（消费者）。</li><li>因为 <code>Producer&lt;Child&gt;</code> 赋值给 <code>Producer&lt;Parent&gt;</code> 后，如果允许 <code>consume(item: T)</code>，那就可能往 <code>Producer&lt;Child&gt;</code> 里面放 <code>Parent</code>，导致类型错误。</li></ul><p> <strong>示例：生产者</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Book</span><br><span class="line">class ScienceBook : Book()</span><br><span class="line"></span><br><span class="line">fun getScienceBooks(): List&lt;ScienceBook&gt; &#123;</span><br><span class="line">    return listOf(ScienceBook())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 使用 `out T` 让子类泛型可以赋值给父类泛型</span><br><span class="line">fun readBooks(books: List&lt;out Book&gt;) &#123;</span><br><span class="line">    for (book in books) &#123;</span><br><span class="line">        println(book)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val scienceBooks = getScienceBooks()</span><br><span class="line">readBooks(scienceBooks) // ✅ OK，因为 List&lt;ScienceBook&gt; 可以赋值给 List&lt;out Book&gt;</span><br></pre></td></tr></table></figure><p><strong>口诀：</strong></p><blockquote><p><strong>Producer Out（生产者用 <code>out</code>，只能读，不能写）</strong></p></blockquote><hr><h5 id="逆变（Contravariance）——-in-T"><a href="#逆变（Contravariance）——-in-T" class="headerlink" title="逆变（Contravariance）—— in T"></a><strong>逆变（Contravariance）—— <code>in T</code></strong></h5><p> <strong>让 <code>Consumer&lt;Parent&gt;</code> 赋值给 <code>Consumer&lt;Child&gt;</code></strong></p><p>如果我们想让 <code>Consumer&lt;Parent&gt;</code> 赋值给 <code>Consumer&lt;Child&gt;</code>，就要用<strong>逆变</strong>（<code>in</code> 关键字）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Consumer&lt;in T&gt; &#123; // T 只能“消费”，不能“生产”</span><br><span class="line">    fun consume(item: T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val parentConsumer: Consumer&lt;Parent&gt; = object : Consumer&lt;Parent&gt; &#123;</span><br><span class="line">    override fun consume(item: Parent) &#123;</span><br><span class="line">        println(&quot;Consumed a Parent&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 可以把 Consumer&lt;Parent&gt; 赋值给 Consumer&lt;Child&gt;</span><br><span class="line">val childConsumer: Consumer&lt;Child&gt; = parentConsumer</span><br></pre></td></tr></table></figure><p> <strong>为什么 <code>in</code> 只允许写入（消费）？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Consumer&lt;in T&gt; &#123;</span><br><span class="line">    fun consume(item: T) // ✅ 只能消费 T</span><br><span class="line">    // fun produce(): T // ❌ 错误，不能返回 T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>in T</code> <strong>只能作为参数（消费者）</strong>，不能作为返回值（生产者）。</li><li>因为 <code>Consumer&lt;Parent&gt;</code> 赋值给 <code>Consumer&lt;Child&gt;</code> 后，如果允许 <code>produce()</code>，就可能返回 <code>Parent</code>，但 <code>Consumer&lt;Child&gt;</code> 只能处理 <code>Child</code>，导致类型错误。</li></ul><p> <strong>示例：消费者</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">class Dog : Animal()</span><br><span class="line"></span><br><span class="line">fun trainDogs(trainers: MutableList&lt;in Dog&gt;) &#123;</span><br><span class="line">    trainers.add(Dog()) // ✅ 可以添加 Dog</span><br><span class="line">    // val dog: Dog = trainers[0] // ❌ 不能安全地读取</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val animals = mutableListOf&lt;Animal&gt;()</span><br><span class="line">trainDogs(animals) // ✅ OK，因为 `MutableList&lt;in Dog&gt;` 允许 `MutableList&lt;Animal&gt;` 作为参数</span><br></pre></td></tr></table></figure><p><strong>口诀：</strong></p><blockquote><p><strong>Consumer In（消费者用 <code>in</code>，只能写，不能读）</strong></p></blockquote><hr><h5 id="记住这两个原则"><a href="#记住这两个原则" class="headerlink" title="记住这两个原则"></a><strong>记住这两个原则</strong></h5><table><thead><tr><th>泛型类型</th><th>关键字</th><th>读取</th><th>写入</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>协变</strong></td><td><code>out T</code></td><td>✅ 允许</td><td>❌ 禁止</td><td><strong>生产者</strong>（只读）</td></tr><tr><td><strong>逆变</strong></td><td><code>in T</code></td><td>❌ 只能用 <code>Any?</code> 读取</td><td>✅ 允许</td><td><strong>消费者</strong>（只写）</td></tr></tbody></table><p> <strong>最简单的记忆口诀</strong></p><ul><li><strong>“生产者用 out”</strong>（Producer Out） → 只能读，不能写。</li><li><strong>“消费者用 in”</strong>（Consumer In） → 只能写，不能安全地读。</li></ul><hr><h5 id="生活中的例子"><a href="#生活中的例子" class="headerlink" title="生活中的例子"></a><strong>生活中的例子</strong></h5><p> <strong>🔵 协变（<code>out</code>）：只读，不写</strong></p><p>假设你去<strong>看书</strong> 📖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kotlin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">val books: List&lt;out Book&gt; = listOf(ScienceBook())</span><br></pre></td></tr></table></figure><ul><li>你可以<strong>拿起一本书来看</strong>（<code>val book: Book = books[0]</code> ✅）。</li><li>但你<strong>不能往书架上随便放书</strong>（<code>books.add(Book())</code> ❌），因为这可能是科学书架，只能放《科学书》。</li></ul><p> <strong>🔴 逆变（<code>in</code>）：只写，不读</strong></p><p>假设你有一个<strong>捐书箱</strong> 📦：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kotlin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">val donateBox: MutableList&lt;in ScienceBook&gt; = mutableListOf&lt;Book&gt;()</span><br></pre></td></tr></table></figure><ul><li>你可以<strong>往里面放一本科学书</strong>（<code>donateBox.add(ScienceBook())</code> ✅）。</li><li>但你<strong>取出来的书不一定是科学书</strong>（<code>val sb: ScienceBook = donateBox[0]</code> ❌），可能是一本普通书，甚至是一本字典 📚。</li></ul><hr><p> <strong>6. 协变逆变总结</strong></p><ol><li><strong><code>out</code>（协变） → 只读</strong><br> ✅ <code>List&lt;ScienceBook&gt;</code> 可以赋值给 <code>List&lt;out Book&gt;</code>，但不能 <code>add()</code>。</li><li><strong><code>in</code>（逆变） → 只写</strong><br> ✅ <code>MutableList&lt;Book&gt;</code> 可以赋值给 <code>MutableList&lt;in ScienceBook&gt;</code>，但不能安全 <code>get()</code>。</li><li><strong><code>in</code> + <code>out</code> 不能混用</strong>（同时 <code>in</code> 和 <code>out</code> 会报错）。</li></ol><h4 id="5-1-5-泛型实化（reified）"><a href="#5-1-5-泛型实化（reified）" class="headerlink" title="5.1.5 泛型实化（reified）"></a>5.1.5 泛型实化（reified）</h4><p>由于泛型在运行时会被擦除，使用 <code>reified</code> 可以保留类型信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 错误示例：无法在运行时获取 T 的类型信息</span><br><span class="line">fun &lt;T&gt; getType(): String &#123;</span><br><span class="line">    return T::class.java.name  // ❌</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确示例：使用 reified 保留类型信息</span><br><span class="line">inline fun &lt;reified T&gt; getType(): String &#123;</span><br><span class="line">    return T::class.java.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(getType&lt;String&gt;())  // 输出: java.lang.String</span><br><span class="line">    println(getType&lt;Int&gt;())     // 输出: int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-委托"><a href="#5-2-委托" class="headerlink" title="5.2 委托"></a>5.2 委托</h3><p>委托是一种设计模式，可以将部分工作交由其他对象来处理，使代码更简洁和灵活。</p><h4 id="5-2-1-属性委托"><a href="#5-2-1-属性委托" class="headerlink" title="5.2.1 属性委托"></a>5.2.1 属性委托</h4><p><strong>lazy 委托</strong>：延迟计算，首次访问时计算结果并缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 lazy 委托属性，只有首次访问时计算值</span><br><span class="line">val lazyValue: String by lazy &#123;</span><br><span class="line">    println(&quot;开始计算&quot;)</span><br><span class="line">    &quot;Hello, Kotlin&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;程序开始&quot;)</span><br><span class="line">    println(lazyValue) // 第一次调用时输出计算过程和结果</span><br><span class="line">    println(lazyValue) // 第二次调用时直接输出结果，无重复计算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>observable 委托</strong>：监听属性变化，每次属性改变时触发回调。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line">var name: String by Delegates.observable(&quot;初始值11&quot;) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">    println(&quot;属性 $&#123;property.name&#125; 从 $oldValue 变成了 $newValue&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    name = &quot;Kotlin22&quot;  // 输出：属性 name 从 初始值11 变成了 Kotlin22</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-类委托"><a href="#5-2-2-类委托" class="headerlink" title="5.2.2 类委托"></a>5.2.2 类委托</h4><p>通过类委托，可以将接口的实现任务交由其他类处理，避免重复实现相同的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个接口</span><br><span class="line">interface Printer &#123;</span><br><span class="line">    fun print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义接口实现类</span><br><span class="line">class PrinterImpl(val message: String) : Printer &#123;</span><br><span class="line">    override fun print() &#123;</span><br><span class="line">        println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类委托：DelegatingPrinter 将 Printer 接口的实现委托给传入的 printer 对象</span><br><span class="line">class DelegatingPrinter(printer: Printer) : Printer by printer</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val printerImpl = PrinterImpl(&quot;Hello from PrinterImpl&quot;)</span><br><span class="line">    val delegatingPrinter = DelegatingPrinter(printerImpl)</span><br><span class="line">    delegatingPrinter.print() // 实际调用 PrinterImpl 的 print() 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>作用域函数</strong>：通过 <code>apply</code>、<code>let</code>、<code>run</code>、<code>also</code> 和 <code>with</code> 简化对象操作，选择合适的函数可提高代码简洁性和可读性。</li><li><strong>时间输出</strong>：使用 <code>SimpleDateFormat</code> 和 <code>Calendar</code> 实现日期格式化、解析和时间组件获取。</li><li><strong>回调机制</strong>：回调可以在任务完成时通知你，避免阻塞主线程，常用于 UI 事件、网络请求等场景。</li><li><strong>Lambda 表达式</strong>：用于编写匿名函数，简化代码，尤其在高阶函数中应用广泛。</li><li><strong>泛型与委托</strong>：泛型提高代码通用性和类型安全；委托（属性委托和类委托）使代码更加简洁灵活，避免重复实现。</li></ul><h2 id="inline-函数是什么"><a href="#inline-函数是什么" class="headerlink" title="inline 函数是什么"></a>inline 函数是什么</h2><p>在 Kotlin 中，<strong>inline 函数</strong> 是一种优化手段，其核心思想是在编译期将函数体直接替换到调用处，从而避免函数调用的开销，特别适用于高阶函数（即接受 lambda 参数的函数）。</p><hr><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li><strong>目的</strong>：减少函数调用带来的性能开销，尤其在使用 lambda 表达式时，避免创建额外的对象。</li><li><strong>工作原理</strong>：编译器在编译时将 inline 函数的代码“内联”（inline）到调用该函数的位置，而不是在运行时调用。</li></ul><hr><h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h3><ul><li><strong>高阶函数</strong>：当函数接受 lambda 参数时，使用 inline 可以减少 lambda 对象的创建，提高性能。</li><li><strong>小型函数</strong>：适用于那些频繁调用的小函数，可以提高效率。</li><li><strong>泛型实化</strong>：与 <code>reified</code> 关键字结合使用，可以在运行时获取泛型参数的具体类型。</li></ul><hr><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><h4 id="3-1-基本示例"><a href="#3-1-基本示例" class="headerlink" title="3.1 基本示例"></a>3.1 基本示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 inline 函数</span><br><span class="line">inline fun performOperation(operation: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;操作开始&quot;)</span><br><span class="line">    operation()</span><br><span class="line">    println(&quot;操作结束&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    performOperation &#123;</span><br><span class="line">        println(&quot;执行具体操作&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：在编译时，<code>performOperation</code> 的代码会直接内联到调用处，从而减少了函数调用的额外开销。</p><hr><h4 id="3-2-与-reified-结合"><a href="#3-2-与-reified-结合" class="headerlink" title="3.2 与 reified 结合"></a>3.2 与 reified 结合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用 inline 和 reified 实现一个泛型函数，获取类型名称</span><br><span class="line">inline fun &lt;reified T&gt; getTypeName(): String &#123;</span><br><span class="line">    return T::class.java.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(getTypeName&lt;String&gt;()) // 输出: java.lang.String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>使用 <code>reified</code> 后，泛型参数在运行时不会被擦除，可以直接获取类型信息。</li><li><code>reified</code> 关键字必须和 <code>inline</code> 函数一起使用。</li></ul><hr><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul><li><strong>代码膨胀</strong>：由于 inline 函数会将函数体复制到每个调用处，如果函数体过大或者调用次数很多，可能会导致生成的字节码变大。</li><li><strong>适用限制</strong>：某些情况下（例如递归调用）不适合使用 inline 函数。</li></ul><hr><h3 id="inline函数总结"><a href="#inline函数总结" class="headerlink" title="inline函数总结"></a>inline函数总结</h3><p>inline 函数主要用于优化高阶函数，通过在编译期内联函数体来减少运行时的函数调用开销。同时，它可以与 <code>reified</code> 结合使用，以在运行时保留泛型类型信息。虽然 inline 函数能够提高性能，但在使用时也需注意避免代码膨胀问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2025/02/24/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/02/24/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h1><p>使用#</p><h1 id="二-字体"><a href="#二-字体" class="headerlink" title="二.字体"></a>二.字体</h1><h2 id="1-粗体"><a href="#1-粗体" class="headerlink" title="1.粗体"></a>1.粗体</h2><p>两个*</p><p><strong>M</strong></p><p><strong>M</strong></p><h2 id="2-斜体"><a href="#2-斜体" class="headerlink" title="2.斜体"></a>2.斜体</h2><p>一个*</p><p><em>M</em></p><p><em>M</em></p><h2 id="3-粗体加斜体"><a href="#3-粗体加斜体" class="headerlink" title="3.粗体加斜体"></a>3.粗体加斜体</h2><p>三个*</p><p><em><strong>M</strong></em></p><p><em><strong>M</strong></em></p><h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h2><p>使用两个波浪线</p><p><del>M</del></p><p><del>M</del></p><h1 id="三-引用"><a href="#三-引用" class="headerlink" title="三.引用"></a>三.引用</h1><p>使用大于号</p><blockquote><p>M</p></blockquote><blockquote><p>M</p></blockquote><h1 id="四-分割线"><a href="#四-分割线" class="headerlink" title="四.分割线"></a>四.分割线</h1><p>三个*或者三个-</p><h1 id="五-图片"><a href="#五-图片" class="headerlink" title="五.图片"></a>五.图片</h1><p>!+[]+()，其中[]内填写名字，()内填写图片地址</p><p><img src="/"></p><h1 id="六-超链接"><a href="#六-超链接" class="headerlink" title="六.超链接"></a>六.超链接</h1><p>[]+()，其中[]内填写名字，()内填写网址</p><p><a href="www.baidu.com">hh</a></p><h1 id="七-列表"><a href="#七-列表" class="headerlink" title="七.列表"></a>七.列表</h1><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>数字加”.”,再加空格，即生成有序列表</p><ol><li>A</li><li>B</li></ol><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>-加空格</p><ul><li>1</li><li>2</li></ul><h1 id="八-表格"><a href="#八-表格" class="headerlink" title="八.表格"></a>八.表格</h1><p>1.右键，选择插入，选择表格</p><p>2.Ctrl+T</p><p>3.原始人模式</p><p>先写好格式如下</p><p>X|Y|Z</p><p>–|–|–</p><p>1|2|3</p><p>然后点击左下角图案&lt;&#x2F;&gt;，开启源代码模式，把各行之间的空行删除，即可生成表格。</p><h1 id="九-插入代码块"><a href="#九-插入代码块" class="headerlink" title="九.插入代码块"></a>九.插入代码块</h1><p>使用三个&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据库</title>
      <link href="/2025/02/24/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2025/02/24/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>进度1:32:06</p><h1 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一.数据类型"></a>一.数据类型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INT                    --整数</span><br><span class="line">DECIMAL(3,2)   --有小数点的数</span><br><span class="line">VARCHAR(10)            --字串</span><br><span class="line">BLOB                   --(Binary Large Object) 图片 影片 档案...</span><br><span class="line">DATA                   --&#x27;YYYY-MM-DD&#x27; 日期</span><br><span class="line">TIMESTAMP              --&#x27;YYYY-MM-DD HH:MM:SS&#x27; 记录时间</span><br></pre></td></tr></table></figure><h1 id="二-简单例子"><a href="#二-简单例子" class="headerlink" title="二.简单例子"></a>二.简单例子</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> dATABASE `sql_tutorial`;</span><br><span class="line"><span class="keyword">SHOW</span> DAtABaSES;</span><br><span class="line">USE `sql_tutorial`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `student`(</span><br><span class="line">`student_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> auto_increment,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> ,  <span class="comment">-- 这是一个注释，记得是减减加空格</span></span><br><span class="line">`major` <span class="type">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">default</span> <span class="string">&#x27;历史&#x27;</span>,</span><br><span class="line">`score` <span class="type">INT</span> <span class="keyword">default</span> <span class="number">100</span> <span class="comment">-- 最后一个属性不用加逗号</span></span><br><span class="line">);      <span class="comment">/*最后有;相当于一句话的结束？*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dESCriBe</span> `student`;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">TABLE</span> `student`;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">ADD</span> gpa <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.00</span>; <span class="comment">-- 新增属性</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> gpa; <span class="comment">-- 删除属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `student`;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;历史&#x27;</span>,<span class="number">100</span>); <span class="comment">-- 插入数据，注意是用单引号’而不是`</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;小绿&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`major`,`student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小蓝&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="number">4</span>); </span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`major`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="keyword">NULL</span>); <span class="comment">-- 不写id是因为auto_increment自动生成id</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `student` <span class="keyword">WHERE</span> `student_id` <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">-- 删除id为4的那一行</span></span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES<span class="operator">=</span><span class="number">0</span> ;<span class="comment">-- 用于关闭安全更新模式，允许你执行 UPDATE 或 DELETE 语句，即使没有 WHERE 条件或没有主键索引。</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` </span><br><span class="line"><span class="keyword">SET</span> `major` <span class="operator">=</span><span class="string">&#x27;英语文学&#x27;</span> <span class="comment">-- 不是行列名等，要使用&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> `major` <span class="operator">=</span><span class="string">&#x27;英语&#x27;</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;小1&#x27;</span> <span class="keyword">WHERE</span> `name`<span class="operator">=</span><span class="string">&#x27;小绿&#x27;</span> <span class="keyword">or</span> `name`<span class="operator">=</span> <span class="string">&#x27;小白&#x27;</span>;  <span class="comment">-- 更新表格</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;小灰&#x27;</span>,`major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span> <span class="keyword">WHERE</span> `student_id`<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `name`<span class="operator">=</span><span class="string">&#x27;小灰&#x27;</span> <span class="keyword">and</span> `major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span>; <span class="comment">-- where用and连接</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `score`<span class="operator">&lt;</span><span class="number">60</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` ;<span class="comment">-- 把student内数据全部删除</span></span><br><span class="line"><span class="comment">-- 取得资料</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student`;</span><br><span class="line"><span class="keyword">Select</span> `name` <span class="keyword">from</span> `student` ;</span><br><span class="line"><span class="keyword">select</span> `name` , `major` <span class="keyword">from</span> `student`; <span class="comment">-- 中间用,而不是and</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score` ; <span class="comment">-- 从低到高，或者在order by后面加上ASC</span></span><br><span class="line"><span class="keyword">selecT</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score` <span class="keyword">DESC</span>;<span class="comment">-- 从高到低</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score`<span class="keyword">DESC</span>,`student_id`  Limit <span class="number">3</span>; <span class="comment">-- 先根据score降序排序，若是score一样，则按student_id升序排序，只返回前三个</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `major`<span class="operator">=</span><span class="string">&#x27;英语&#x27;</span> <span class="keyword">and</span> `student_id`<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- where用and连接</span></span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>1.<em><strong>注释</strong></em>有– 和&#x2F;**&#x2F;两种–后面要跟空格</p><p>2.一个引号是一句，比如虽然CREATE TABLE <code>student</code> 有那么多行，其实只有一句，所以cursor指向容易一行就可以执行整个语句</p><p>3.闪电只会闪电一句话，比如你没有执行USE sql_tutorial 这一句话，去执行dESCriBe <code>student</code>;就会报错，记住<em><strong>一定要先执行USE sql_tutorial这句话</strong></em></p><p>4.关键字的大小写是无所谓的，但建议关键字全用大写，上面例子只是为了体现大小写任意的特征，实际上一个全部大写，自己定义的字建议使用&#96;&#96;包括起来，并使用小写</p><p>5.&gt;大于   &lt;小于   &gt;&#x3D;大于等于   &#x3D;等于    &lt;&gt;不等于</p><p>6.where用and，or连接？</p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用AS的准备</title>
      <link href="/2025/02/16/%E4%BD%BF%E7%94%A8AS%E7%9A%84%E5%87%86%E5%A4%87/"/>
      <url>/2025/02/16/%E4%BD%BF%E7%94%A8AS%E7%9A%84%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="1-viewbinding"><a href="#1-viewbinding" class="headerlink" title="1.viewbinding"></a>1.viewbinding</h1><p>build.gradle.kts中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">...</span><br><span class="line">buildFeatures &#123;</span><br><span class="line">    viewBinding = true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-compileSdk"><a href="#2-compileSdk" class="headerlink" title="2.compileSdk"></a>2.compileSdk</h1><p>build.gradle.kts中compileSdk&#x3D;34改成compileSdk&#x3D;35</p><h1 id="3-dependencies"><a href="#3-dependencies" class="headerlink" title="3.dependencies"></a>3.dependencies</h1><p>在dependencies中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">implementation(&quot;androidx.fragment:fragment:1.6.2&quot;)</span><br><span class="line">implementation(&quot;com.squareup.okhttp3:okhttp:4.10.0&quot;)</span><br><span class="line">implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1&quot;)</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&quot;)</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.4.0&quot;)</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0&quot;)</span><br><span class="line">implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)</span><br><span class="line">kapt(&quot;androidx.room:room-compiler:2.6.1&quot;)</span><br><span class="line">implementation(&quot;androidx.work:work-runtime:2.10.0&quot;)</span><br><span class="line">implementation(&quot;com.github.bumptech.glide:glide:4.15.1&quot;)</span><br><span class="line">implementation (&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.3.1&quot;)</span><br><span class="line">implementation (&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1&quot;)</span><br><span class="line">implementation (&quot;com.github.bumptech.glide:glide:4.13.0&quot;)</span><br><span class="line">annotationProcessor (&quot;com.github.bumptech.glide:compiler:4.13.0&quot;)</span><br><span class="line">implementation(&quot;androidx.room:room-runtime:2.5.2&quot;)</span><br><span class="line">kapt(&quot;androidx.room:room-compiler:2.5.2&quot;)</span><br><span class="line">implementation(&quot;androidx.room:room-ktx:2.5.2&quot;)</span><br><span class="line">implementation(&quot;com.google.android.material:material:1.12.0&quot;)</span><br><span class="line">implementation(&quot;de.hdodenhof:circleimageview:3.1.0&quot;)</span><br><span class="line">implementation(&quot;androidx.swiperefreshlayout:swiperefreshlayout:1.1.0&quot;)</span><br></pre></td></tr></table></figure><p>解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">implementation(&quot;androidx.fragment:fragment-ktx:1.6.2&quot;)</span><br><span class="line">implementation(&quot;com.squareup.okhttp3:okhttp:4.10.0&quot;)//引用OkHttp库</span><br><span class="line">implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)//使用gson</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)//使用Retrofit,会自动将Retrofit、OkHttp、和Okio这几个库一起下载，不用再手动引入OkHttp库。</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)//使用Retrofit，这是一个Retrofit的转换库，它是借助GSON来解析JSON数据的，所以会自动将GSON库下载下来，所以不用手动引入GSON库了</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1&quot;)//协程</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&quot;)//协程</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.4.0&quot;)//使用ViewModel组件</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)//使用ViewModel、livedata组件</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0&quot;)//使用ViewModel组件</span><br><span class="line">implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)//room</span><br><span class="line">kapt(&quot;androidx.room:room-compiler:2.6.1&quot;)//room</span><br><span class="line">implementation(&quot;androidx.work:work-runtime:2.10.0&quot;)//WorkManager</span><br><span class="line">implementation(&quot;com.github.bumptech.glide:glide:4.15.1&quot;)/*Glide,另外，Glide中需要用到网络功能，因此你还得在AndroidManifest.xml中声明一下网络权限才行：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;*/</span><br><span class="line">annotationProcessor (&quot;com.github.bumptech.glide:compiler:4.13.0&quot;)</span><br><span class="line">implementation(&quot;androidx.room:room-runtime:2.5.2&quot;)</span><br><span class="line">kapt(&quot;androidx.room:room-compiler:2.5.2&quot;)</span><br><span class="line">implementation(&quot;androidx.room:room-ktx:2.5.2&quot;)</span><br><span class="line">implementation(&quot;com.google.android.material:material:1.12.0&quot;)</span><br><span class="line">implementation(&quot;de.hdodenhof:circleimageview:3.1.0&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-plugins"><a href="#4-plugins" class="headerlink" title="4.plugins"></a>4.plugins</h1><p>添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(&quot;kotlin-kapt&quot;)</span><br></pre></td></tr></table></figure><p>解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(&quot;kotlin-kapt&quot;)//为了dependencies中能使用kapt(&quot;...&quot;)这样的语法</span><br></pre></td></tr></table></figure><h1 id="5-binding"><a href="#5-binding" class="headerlink" title="5.binding"></a>5.binding</h1><p>改用binding.root</p><h1 id="6-声明网络权限"><a href="#6-声明网络权限" class="headerlink" title="6.声明网络权限"></a>6.声明网络权限</h1><p>在AndroidManifest.xml开头添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如下面例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><h1 id="7-使用HTTP"><a href="#7-使用HTTP" class="headerlink" title="7.使用HTTP"></a>7.使用HTTP</h1><p>在res-&gt;xml文件夹下，新建network_config.xml文件，然后修改文件中内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">    &lt;base-config cleartextTrafficPermitted=&quot;true&quot;&gt;</span><br><span class="line">        &lt;trust-anchors&gt;</span><br><span class="line">            &lt;certificates src=&quot;system&quot;/&gt;</span><br><span class="line">        &lt;/trust-anchors&gt;</span><br><span class="line">    &lt;/base-config&gt;</span><br><span class="line">&lt;/network-security-config&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段配置文件的意思是允许我们以明文的方式在网络上传输数据，而HTTP使用的就是明文传输方式。</p><p>接下来修改AndroidManifest.xml中的代码来启用我们刚才创建的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        android:allowBackup=&quot;true&quot;</span><br><span class="line">        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;</span><br><span class="line">        android:fullBackupContent=&quot;@xml/backup_rules&quot;</span><br><span class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;</span><br><span class="line">        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:supportsRtl=&quot;true&quot;</span><br><span class="line">        android:theme=&quot;@style/Theme.NetworkTest&quot;</span><br><span class="line">        tools:targetApi=&quot;31&quot;</span><br><span class="line">        android:networkSecurityConfig=&quot;@xml/network_config&quot;//就是添加这一行哦</span><br><span class="line">        &gt;</span><br></pre></td></tr></table></figure><h1 id="AndroidManifest-xml的权限声明"><a href="#AndroidManifest-xml的权限声明" class="headerlink" title="AndroidManifest.xml的权限声明"></a>AndroidManifest.xml的权限声明</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; </span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;</span><br><span class="line">&lt;!-- 普通前台服务权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot;/&gt;</span><br><span class="line">&lt;!-- MediaPlayback 类型的前台服务需要额外的权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK&quot;/&gt;</span><br></pre></td></tr></table></figure><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><p>1.删enableEdgeToEdge()，其实还是别删了</p><p>2.删ViewCompat.setOnApplyWindowInsetsListener，其实还是别删了，但是ViewCompat.setOnApplyWindowInsetsListener和fitsSystemWindows&#x3D;”true”有冲突，所以不得已的时候只能删了，但是其实ViewCompat.setOnApplyWindowInsetsListener比fitsSystemWindows好用多了，还不如保留ViewCompat.setOnApplyWindowInsetsListener，删除fitsSystemWindows。</p><p>3.初始化binding和改setContentView(binding.root)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task-4</title>
      <link href="/2025/02/10/Task-4/"/>
      <url>/2025/02/10/Task-4/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第四讲"><a href="#寒假第四讲" class="headerlink" title="寒假第四讲"></a>寒假第四讲</h1><h2 id="一-有理数取余"><a href="#一-有理数取余" class="headerlink" title="一.有理数取余"></a>一.有理数取余</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该问题要求计算有理数 c&#x3D;ab<em>c</em>&#x3D;<em>b**a</em> 对19260817取模的值。根据模运算的性质，这相当于求解方程 bx≡amod  19260817<em>b**x</em>≡<em>a</em>mod19260817。解的存在性取决于 b<em>b</em> 是否存在模19260817的逆元。具体步骤如下：</p><ol><li><strong>大数取模</strong>：由于输入的 a<em>a</em> 和 b<em>b</em> 可能非常大（最多10001位），需要将这两个数转换为模19260817后的值。这可以通过逐位处理字符串并取模来实现。</li><li><strong>判断逆元存在性</strong>：若 b<em>b</em> 模19260817的结果为0，则方程无解，直接输出“Angry!”。否则，利用费马小定理计算 b<em>b</em> 的逆元，因为19260817是质数。</li><li><strong>计算最终结果</strong>：将 a<em>a</em> 的模值与逆元相乘后再次取模，得到最终结果。</li></ol><h3 id="2-对应代码"><a href="#2-对应代码" class="headerlink" title="2.对应代码"></a>2.对应代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MOD = 19260817;</span><br><span class="line"></span><br><span class="line">int mod(const string&amp; s, int m) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (char c : s) &#123;</span><br><span class="line">        res = (res * 10LL + (c - &#x27;0&#x27;)) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long pow_mod(long long a, long long b, int mod) &#123;</span><br><span class="line">    long long res = 1;</span><br><span class="line">    a %= mod;</span><br><span class="line">    while (b &gt; 0) &#123;</span><br><span class="line">        if (b % 2 == 1) res = (res * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string a_str, b_str;</span><br><span class="line">    cin &gt;&gt; a_str &gt;&gt; b_str;</span><br><span class="line"></span><br><span class="line">    int a_mod = mod(a_str, MOD);</span><br><span class="line">    int b_mod = mod(b_str, MOD);</span><br><span class="line"></span><br><span class="line">    if (b_mod == 0) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Angry!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        long long inv_b = pow_mod(b_mod, MOD - 2, MOD);</span><br><span class="line">        long long ans = (a_mod * inv_b) % MOD;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li><strong>大数取模技巧</strong>：处理超大数时，可以通过逐位取模的方式避免数值溢出。例如，将字符串的每一位依次转换为当前结果的10倍加上该位数字，然后立即取模。</li><li><strong>逆元计算</strong>：当模数为质数时，可以利用费马小定理快速计算逆元（即 ap−2mod  p<em>a**p</em>−2mod<em>p</em>），时间复杂度为 O(log⁡p)<em>O</em>(log<em>p</em>)。</li><li><strong>输入处理</strong>：注意输入的数值范围，使用字符串处理大数，并确保处理过程中不会溢出。</li><li><strong>边界条件</strong>：题目保证输入的 a<em>a</em> 和 b<em>b</em> 不同时是模数的倍数，因此当 b<em>b</em> 的模为0时，直接判定无解。</li></ol><p>该问题结合了数论中的模运算和逆元知识，同时考察了处理大数的技巧，综合应用了多种算法和编程技术。</p><h2 id="二-Minimal-Coprime"><a href="#二-Minimal-Coprime" class="headerlink" title="二.Minimal Coprime"></a>二.Minimal Coprime</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>对于每一个测试用例，我们需要找出区间 [l, r] 内所有的最小互质区间。由于我们要判断区间是否是最小互质，实际操作时可以考虑以下几点：</p><ol><li>如果 l &#x3D;&#x3D; r，那么只有一个单一的数，需要检查该数是否与自身互质，显然，对于任意数 a，<code>gcd(a, a) ≠ 1</code>，因此这类区间无法构成互质区间。</li><li>如果 l !&#x3D; r，则要判断区间 [l, r] 内每一个单元素子区间是否互质，同时对于更大的区间是否是最小互质区间。</li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">const int N = 1e6 + 10,mod = 19260817,INT = 1e17,M = 5e6;</span><br><span class="line"> </span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"> </span><br><span class="line">int qmi(int a,int k)&#123;</span><br><span class="line">int res = 1;</span><br><span class="line">while(k)&#123;</span><br><span class="line">if(k&amp;1) res = res * a % mod;</span><br><span class="line">a = a * a % mod; </span><br><span class="line">k &gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void slove()&#123;</span><br><span class="line">string a,b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">int na = 0,nb = 0;</span><br><span class="line">for(auto c:a)&#123;</span><br><span class="line">na = (na * 10 + c - &#x27;0&#x27;) % mod;</span><br><span class="line">&#125;</span><br><span class="line">for(auto c:b) nb = (nb * 10 + c - &#x27;0&#x27;) % mod;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; na * qmi(nb,mod - 2) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);cin.tie(nullptr);</span><br><span class="line">int T = 1;</span><br><span class="line">while(T--) slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>最大公约数 (gcd)</strong>：在这道题中，我们频繁使用 <code>gcd</code> 来判断两个数是否互质。通过辗转相除法，可以有效地求出两个数的最大公约数，进而判断它们是否互质。</p><p><strong>区间内互质判断</strong>：对于每一个子区间，需要检查它们是否互质，并且判断是否包含更小的互质子区间。这要求我们在求解时要小心处理每个区间，避免遗漏。</p><p><strong>最小互质区间的判定</strong>：最小互质区间需要满足不包含任何其他互质区间，这一点是解题的关键。通过遍历区间的所有子区间，并确保它们不含更小的互质区间，可以确保找到所有最小互质区间。</p><p><strong>优化</strong>：虽然本解法直接暴力枚举所有区间，但考虑到题目中区间范围较大，应该在实际使用中进行一些优化，如剪枝等策略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task 3</title>
      <link href="/2025/02/06/Task-3/"/>
      <url>/2025/02/06/Task-3/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第三讲"><a href="#寒假第三讲" class="headerlink" title="寒假第三讲"></a>寒假第三讲</h1><h2 id="一-priority-queue"><a href="#一-priority-queue" class="headerlink" title="一.priority queue"></a>一.priority queue</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求实现一个优先队列，支持插入操作 <code>insert(k)</code> 和提取最大元素操作 <code>extractMax</code>。在 C++ 中，我们可以使用 <code>priority_queue</code> 来实现这一结构。<code>priority_queue</code> 默认是最大堆，插入操作将元素添加到堆中，而提取操作返回并删除堆顶的元素。</p><p>首先，输入包含多个操作，每个操作可能是 <code>insert k</code>（插入整数 k）、<code>extract</code>（提取最大元素）或 <code>end</code>（结束输入）。对于每个 <code>insert k</code> 操作，我们将元素插入到优先队列中。对于每个 <code>extract</code> 操作，我们从堆中提取并输出当前最大值。</p><p>C++ 的 <code>priority_queue</code> 数据结构默认按降序排列（即最大堆），因此无需额外处理即可满足题目要求。程序通过循环读取操作，针对 <code>insert</code> 进行堆插入，针对 <code>extract</code> 进行堆顶元素提取并输出，直到遇到 <code>end</code> 操作停止。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Compare &#123;</span><br><span class="line">    bool operator()(int a, int b) &#123;</span><br><span class="line">        return a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, Compare&gt; pq; </span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    while (getline(cin, line)) &#123;</span><br><span class="line">        if (line.empty()) continue;</span><br><span class="line"></span><br><span class="line">        stringstream ss(line);</span><br><span class="line">        string command;</span><br><span class="line">        ss &gt;&gt; command;</span><br><span class="line"></span><br><span class="line">        if (command == &quot;insert&quot;) &#123;</span><br><span class="line">            int k;</span><br><span class="line">            ss &gt;&gt; k;</span><br><span class="line">            pq.push(k);</span><br><span class="line">        &#125; else if (command == &quot;extract&quot;) &#123;</span><br><span class="line">            if (!pq.empty()) &#123;</span><br><span class="line">                cout &lt;&lt; pq.top() &lt;&lt; endl; </span><br><span class="line">                pq.pop(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (command == &quot;end&quot;) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>通过实现这个优先队列，了解了 C++ 中 <code>priority_queue</code> 的基本使用方法。<code>priority_queue</code> 使用最大堆结构，自动保证每次提取的都是当前最大元素，因此插入和提取操作的时间复杂度为 <code>O(log n)</code>，非常高效。此外，使用 <code>priority_queue</code> 还可以避免手动维护堆结构，从而减少了程序复杂度。通过输入和输出流的处理，我也更深入地理解了如何高效处理大规模数据输入。特别是对于题目中限制的 200 万次操作，我们需要确保程序的输入输出效率，因此应该尽量减少不必要的操作，使用合适的输入输出方法提高程序性能。</p><h2 id="ST表-RMQ问题"><a href="#ST表-RMQ问题" class="headerlink" title="ST表&amp;&amp;RMQ问题"></a>ST表&amp;&amp;RMQ问题</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该程序利用 ST 表进行静态区间最大值查询。首先，使用 <code>preprocess</code> 函数构建 ST 表，预处理时间复杂度为 O(N log N)。<br>对于每个查询，我们利用对数表 <code>log_table</code> 预计算查询范围的最优分块，使得查询复杂度降为 O(1)。<br>通过 <code>read()</code> 进行高效输入，减少 IO 时间，适用于大数据量场景。</p><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 100000;</span><br><span class="line">const int LOG = 17;</span><br><span class="line">int st[MAX_N][LOG];</span><br><span class="line">int log_table[MAX_N + 1];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;) f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preprocess(const vector&lt;int&gt;&amp; arr, int n) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        st[i][0] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">        for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i++) &#123;</span><br><span class="line">            st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log_table[1] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        log_table[i] = log_table[i / 2] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int l, int r) &#123;</span><br><span class="line">    int j = log_table[r - l + 1];</span><br><span class="line">    return max(st[l][j], st[r - (1 &lt;&lt; j) + 1][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = read(), m = read();</span><br><span class="line">    vector&lt;int&gt; arr(n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line">    preprocess(arr, n);</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int l = read() - 1, r = read() - 1;</span><br><span class="line">        printf(&quot;%d\n&quot;, query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>ST 表适用于静态查询，预处理代价较高，但查询极快。</li><li>利用 <code>log_table</code> 预计算对数值可以减少 <code>log</code> 函数调用，提高查询效率。</li><li>快速输入 <code>read()</code> 可有效减少时间开销，适用于高强度数据。</li><li>ST 表的核心思想是利用区间的重叠性，通过 <code>dp</code> 方式高效存储区间信息</li></ol><h2 id="合并果子"><a href="#合并果子" class="headerlink" title="合并果子"></a>合并果子</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题可以通过哈夫曼树（Huffman Tree）的思想来解决，使用最小堆（优先队列）进行贪心合并。<br>每次取出当前最小的两堆果子进行合并，合并的代价是两者之和，并将新堆重新加入优先队列。<br>这个过程持续 n-1 次，最终优先队列中只剩下一堆，累加所有合并的代价，即为最小的体力耗费。<br>由于使用了最小堆，每次插入与删除的复杂度是 O(log n)，整体复杂度为 O(n log n)。</p><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;) f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = read();</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        pq.push(read());</span><br><span class="line">    &#125;</span><br><span class="line">    int total_cost = 0;</span><br><span class="line">    while (pq.size() &gt; 1) &#123;</span><br><span class="line">        int a = pq.top(); pq.pop();</span><br><span class="line">        int b = pq.top(); pq.pop();</span><br><span class="line">        int cost = a + b;</span><br><span class="line">        total_cost += cost;</span><br><span class="line">        pq.push(cost);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, total_cost);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>本题是典型的贪心算法应用，通过局部最优（每次合并最小的两堆）达到全局最优。</li><li>最小堆（优先队列）是一种有效的数据结构，适用于处理动态集合中的最小值问题。</li><li>哈夫曼树的构造与本题类似，它用于最优前缀编码问题，具有广泛应用。</li><li>由于 n 最大为 10000，使用 O(n log n) 复杂度的方法是合理可行的，若用 O(n^2) 的方法会超时。</li><li>通过 <code>priority_queue</code> 的 <code>greater&lt;int&gt;</code> 实现最小堆，提高代码可读性和效率。</li></ol><h2 id="四-约瑟夫问题"><a href="#四-约瑟夫问题" class="headerlink" title="四.约瑟夫问题"></a>四.约瑟夫问题</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该题是经典的约瑟夫环问题。我们通过模拟报数过程来解决，使用双端队列（<code>deque</code>）来模拟每次出圈的操作。首先将所有人的编号依次加入队列，每次将前 mmm 个人报数，第 mmm 个人出列，再从下一个人开始继续报数。该过程重复直到所有人都出列。通过队列的 <code>push_back</code> 和 <code>pop_front</code> 操作来模拟循环报数，保证每个出圈人的编号按顺序输出。</p><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    deque&lt;int&gt; people;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        people.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    while (!people.empty()) &#123;</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            people.push_back(people.front());</span><br><span class="line">            people.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        cout &lt;&lt; people.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">        people.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h3><p><strong>约瑟夫环问题</strong>：是经典的动态结构问题，使用队列模拟能够有效解决。</p><p><strong>队列操作</strong>：队列的 <code>push_back</code> 和 <code>pop_front</code> 操作时间复杂度为 O(1)，适合进行循环模拟。</p><p><strong>循环过程理解</strong>：通过理解每次从队列中移除第 mmm 个人，并将下一个人重新从头开始报数，可以轻松解决问题。</p><p><strong>时间复杂度</strong>：对于 n 和 m 较小的情况，O(n * m) 的时间复杂度是可行的。</p><p><strong>应用范围</strong>：这种方法适用于类似的循环排列问题，理解其实现方式对于解决其他类似问题非常有帮助。</p><h2 id="五-Look-Up-S"><a href="#五-Look-Up-S" class="headerlink" title="五.Look Up S"></a>五.Look Up S</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题的核心在于查找每个奶牛的右侧第一个比她高的奶牛。通过使用栈（stack）数据结构，可以高效地维护一个递减的序列。每次遇到一个奶牛时，将其与栈顶的奶牛进行比较，如果栈顶奶牛的身高不大于当前奶牛，就将其弹出，直到栈顶奶牛的身高大于当前奶牛或栈为空。此时栈顶元素即为当前奶牛的仰望对象。</p><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1e5 + 5;</span><br><span class="line">int h[MAXN];</span><br><span class="line">int ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; stk;</span><br><span class="line">    for (int i = n; i &gt;= 1; --i) &#123;</span><br><span class="line">        while (!stk.empty() &amp;&amp; h[stk.back()] &lt;= h[i]) &#123;</span><br><span class="line">            stk.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = stk.empty() ? 0 : stk.back();</span><br><span class="line">        stk.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>栈的应用</strong>：本题运用了栈来解决查找“右侧第一个更大元素”的问题。栈非常适合解决递增&#x2F;递减问题，能够避免不必要的重复计算。</p><p><strong>时间复杂度优化</strong>：通过栈的方式，每个奶牛的身高最多入栈和出栈一次，整体时间复杂度为 O(N)，满足大规模数据的需求。</p><p><strong>贪心策略</strong>：栈的使用体现了贪心策略，通过逐步找出最优解。每次都保证栈中的奶牛按递减顺序排列，能快速找到每个奶牛的第一个仰望对象。</p><p><strong>解决类似问题</strong>：掌握栈的应用可以解决许多类似的“寻找下一个更大&#x2F;小元素”类型的问题。</p><h2 id="五-国旗计划"><a href="#五-国旗计划" class="headerlink" title="五.国旗计划"></a>五.国旗计划</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p><strong>区间转化</strong>：</p><ul><li>每个边防战士常驻两个边防站 <code>C_i</code> 和 <code>D_i</code>，其奔袭区间为从 <code>C_i</code> 到 <code>D_i</code>。如果 <code>C_i &gt; D_i</code>，说明该区间跨越了边境，需要加上边境的总长度 <code>M</code>，这样就能确保所有区间都是线性区间，方便后续处理。</li></ul><p><strong>排序</strong>：</p><ul><li>由于区间覆盖问题通常需要按顺序处理，所有边防战士的奔袭区间按照左端点 <code>l</code> 排序。排序后的数组使得我们可以方便地逐一处理每个边防战士，并计算出最少需要多少战士来覆盖边境。</li></ul><p><strong>动态规划和跳跃法</strong>：</p><ul><li>采用动态规划来解决每个边防战士覆盖的最远区间问题。通过二分查找，找到每个战士能覆盖的最远位置，记录在二维数组 <code>go</code> 中。<code>go[i][0]</code> 存储战士 <code>i</code> 覆盖区间的最远战士 <code>k</code> 的下标。为了更高效地查询最大覆盖，代码通过多级跳跃的方式，构建了 <code>go</code> 数组，并通过动态规划实现快速查询。</li></ul><p><strong>查询最小战士数量</strong>：</p><ul><li>在查询每个战士必须参与的前提下，我们从该战士的起始位置开始，依次找到能够覆盖区间的最远战士，通过二分查找的方式迭代跳跃，最后计算出最少需要的战士数量。</li></ul><p><strong>输出结果</strong>：</p><ul><li>对于每个战士，输出必须参与的前提下，最少需要多少个战士来覆盖整个边境线。</li></ul></li></ol><h3 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, res[200005];</span><br><span class="line">struct soldier &#123;</span><br><span class="line">int id, l, r;</span><br><span class="line">&#125; s[400005];</span><br><span class="line">int cmp(soldier a, soldier b)</span><br><span class="line">&#123;</span><br><span class="line">return a.l &lt; b.l; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int go[400005][20];</span><br><span class="line"></span><br><span class="line">void pre()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1, p = i; i &lt;= 2 * n; i++) &#123;</span><br><span class="line">while(p &lt;= 2 * n &amp;&amp; s[p].l &lt;= s[i].r)</span><br><span class="line">p++;</span><br><span class="line">int pos = p - 1;</span><br><span class="line">go[i][0] = pos;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">for(int j = 1; j &lt;= 2 * n; j++) &#123;</span><br><span class="line">go[j][i] = go[go[j][i - 1]][i - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void search(int k)</span><br><span class="line">&#123;</span><br><span class="line">int lmt = s[k].l + m, ans = 1, p = k;</span><br><span class="line">for(int i = 19; i &gt;= 0; i--) &#123;</span><br><span class="line">if(go[k][i] != 0 &amp;&amp; s[go[k][i]].r &lt; lmt) &#123;</span><br><span class="line">ans += (1 &lt;&lt; i);</span><br><span class="line">k = go[k][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res[s[p].id] = ans + 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s[i].l &gt;&gt; s[i].r;</span><br><span class="line">if(s[i].r &lt; s[i].l)</span><br><span class="line">s[i].r += m;</span><br><span class="line">s[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(s + 1, s + 1 + n, cmp);</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">s[i + n] = s[i];</span><br><span class="line">s[i + n].l = s[i].l + m;</span><br><span class="line">s[i + n].r = s[i].r + m;</span><br><span class="line">&#125;</span><br><span class="line">pre();</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">search(i);</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="学习总结-1"><a href="#学习总结-1" class="headerlink" title="学习总结"></a>学习总结</h3><p>这段代码实现了一个经典的区间覆盖问题，核心思想是通过排序和动态规划来高效地解决覆盖区间的最小边防战士数量。具体做法是将所有的区间转化成线性区间，使用排序保证覆盖的顺序性，再通过二分查找和动态规划的结合，优化查询效率。这个思路对于解决类似的区间覆盖问题非常有效，尤其是在大规模数据输入时，能够显著减少计算复杂度。通过合理使用跳跃表和二分查找，代码实现了较高的效率，是学习算法设计和优化的重要案例。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task 2</title>
      <link href="/2025/02/06/Task-2/"/>
      <url>/2025/02/06/Task-2/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第二讲-“二分”"><a href="#寒假第二讲-“二分”" class="headerlink" title="寒假第二讲:“二分”"></a>寒假第二讲:“二分”</h1><h2 id="一-二分查找"><a href="#一-二分查找" class="headerlink" title="一.二分查找"></a>一.二分查找</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这个问题的要求是通过二分查找，在一个已经按升序排列的整数序列中查找是否包含查询的整数。对于每次查询，若该整数在序列中出现，则输出 “Yes”，否则输出 “No”。</p><ol><li><strong>输入处理</strong>：<ul><li>输入一个整数 nnn，表示数组的大小。</li><li>接下来输入 nnn 个整数，这些整数已排序。</li><li>接着输入一个整数 qqq，表示查询次数。</li><li>对于每次查询，输入一个整数 mmm，需要判断 mmm 是否出现在排序数组中。</li></ul></li><li><strong>二分查找</strong>：<ul><li>二分查找是一种高效的查找方法，在一个已排序的数组中查找某个元素的时间复杂度为 O(log⁡n)O(\log n)O(logn)。</li><li>使用标准库的 <code>lower_bound</code> 函数来实现二分查找。它会返回一个指向数组中第一个大于或等于查询值的迭代器。如果迭代器指向的元素与查询值相同，则表示该元素存在。</li></ul></li><li><strong>输出</strong>：<ul><li>如果查询值在数组中存在，则输出 “Yes”；否则输出 “No”。</li></ul></li></ol><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;  // For lower_bound</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; arr(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class="line">        int m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">      </span><br><span class="line">        auto it = lower_bound(arr.begin(), arr.end(), m);</span><br><span class="line">  </span><br><span class="line">        if (it != arr.end() &amp;&amp; *it == m) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>该问题要求在已排序的数组中进行多个查找操作，最直观的做法是使用二分查找。二分查找能够将查找时间从 O(n)O(n)O(n) 降低到 O(log⁡n)O(\log n)O(logn)，因此对于大规模数据，能够显著提高效率。利用 C++ STL 提供的 <code>lower_bound</code> 函数，可以高效地实现二分查找，避免手动实现查找算法。通过这种方法，每次查询的时间复杂度为 O(log⁡n)O(\log n)O(logn)，因此总的时间复杂度为 O(qlog⁡n)O(q \log n)O(qlogn)，适合处理较大规模的输入数据。</p><p>这个解法对于最大值 n&#x3D;100000n &#x3D; 100000n&#x3D;100000 和 q&#x3D;100000q &#x3D; 100000q&#x3D;100000 的情况也是可行的，满足时间限制。</p><h2 id="二-A-B数对"><a href="#二-A-B数对" class="headerlink" title="二.A-B数对"></a>二.A-B数对</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>给定数列以及常数 CCC，要求计算满足条件 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C 的数对个数。这个问题要求判断在数列中，存在多少对 (A,B)(A, B)(A,B)，使得 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C，即 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C。</p><h4 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h4><ol><li><strong>数学转换</strong>：<ul><li>给定条件 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C，可转化为 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C。因此，对于每个 BBB，我们只需要判断 B+CB + CB+C 是否出现在数列中。</li></ul></li><li><strong>使用哈希表</strong>：<ul><li>使用哈希表（<code>unordered_map</code>）来记录数列中每个数字的出现次数。遍历数列，对于每个数 BBB，计算 B+CB + CB+C，然后检查哈希表中是否有这个数。如果有，则计数增加。</li></ul></li><li><strong>效率问题</strong>：<ul><li>用哈希表统计数列中各个数字的出现次数，查找某个数是否存在的操作是 O(1)O(1)O(1)，所以该算法的时间复杂度是 O(N)O(N)O(N)，适用于大规模数据。</li></ul></li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, C;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; C;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; arr(N);</span><br><span class="line">    unordered_map&lt;int, int&gt; freq;  </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        ++freq[arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    long long count = 0; </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        int B = arr[i];</span><br><span class="line">        int A = B + C;  // 计算A = B + C</span><br><span class="line">       </span><br><span class="line">        if (freq.find(A) != freq.end()) &#123;</span><br><span class="line">            count += freq[A];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>哈希表</strong>： 哈希表在处理需要快速查找的场景中非常有用。在本题中，哈希表帮助我们在 O(1)O(1)O(1) 的时间复杂度内查找某个元素是否存在，使得整体复杂度从 O(N2)O(N^2)O(N2) 降低到 O(N)O(N)O(N)。</p><p><strong>优化思维</strong>： 通过将问题转化为查找数列中是否存在某个数 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C，我们避免了枚举所有数对的低效方法。这是典型的通过数学转化优化问题的思路。</p><p><strong>时间与空间复杂度</strong>： 学习如何平衡时间和空间复杂度。通过使用哈希表，虽然增加了额外的空间开销，但极大地提高了算法效率，适应了问题的大数据规模。</p><p><strong>实际应用</strong>： 哈希表和集合操作在实际开发中有着广泛应用，例如数据库的索引、缓存系统等，了解并掌握这些基本数据结构对解决实际问题至关重要。</p><h2 id="三-分巧克力"><a href="#三-分巧克力" class="headerlink" title="三.分巧克力"></a>三.分巧克力</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求我们从 <code>N</code> 块巧克力中切出 <code>K</code> 块正方形巧克力，且每块正方形的边长尽可能大。我们需要通过切割巧克力的长方形，得到大小相同的正方形。</p><h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><ol><li><strong>正方形的大小</strong>：<ul><li>对于每一块巧克力 Hi×WiH_i \times W_iHi×Wi，我们能够从中切出多少个 S×SS \times SS×S 的正方形（其中 SSS 为正方形的边长）？</li><li>我们可以通过将 HiH_iHi 和 WiW_iWi 分别除以 SSS，计算每个长方形可以切出的正方形数量： 个数&#x3D;⌊HiS⌋×⌊WiS⌋\text{个数} &#x3D; \left\lfloor \frac{H_i}{S} \right\rfloor \times \left\lfloor \frac{W_i}{S} \right\rfloor个数&#x3D;⌊SHi⌋×⌊SWi⌋</li><li>我们需要找到一个 SSS，使得从所有 NNN 块巧克力中切出的正方形总数至少为 KKK。</li></ul></li><li><strong>二分查找</strong>：<ul><li>由于我们希望切出的正方形边长尽可能大，最直观的办法是使用二分查找来确定边长 SSS 的最大值。范围从 1 到每块巧克力的最大边长（即 min⁡(Hi,Wi)\min(H_i, W_i)min(Hi,Wi)）。</li></ul></li><li><strong>检查条件</strong>：<ul><li>对于每个 SSS，我们计算出所有巧克力切出的正方形数量，并判断是否能够满足至少有 KKK 块巧克力。如果能满足，说明 SSS 是一个可能的解，我们可以继续尝试更大的 SSS；否则，尝试更小的 SSS。</li></ul></li></ol><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 判断给定边长 S 能否从所有巧克力中切出至少 K 块正方形</span><br><span class="line">bool canCutSquares(const vector&lt;pair&lt;int, int&gt;&gt;&amp; chocolates, int S, int K) &#123;</span><br><span class="line">    long long totalCount = 0;  // 记录切出的正方形总数</span><br><span class="line">    for (const auto&amp; chocolate : chocolates) &#123;</span><br><span class="line">        int H = chocolate.first;</span><br><span class="line">        int W = chocolate.second;</span><br><span class="line">        totalCount += (H / S) * (W / S);  // 计算该巧克力能切出多少个 S * S 的正方形</span><br><span class="line">        if (totalCount &gt;= K) return true;  // 如果已达到要求的数量，提前返回</span><br><span class="line">    &#125;</span><br><span class="line">    return totalCount &gt;= K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, K;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; chocolates(N);</span><br><span class="line">    int maxSide = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; chocolates[i].first &gt;&gt; chocolates[i].second;</span><br><span class="line">        maxSide = max(maxSide, min(chocolates[i].first, chocolates[i].second));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int low = 1, high = maxSide, bestSide = 0;</span><br><span class="line"></span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (canCutSquares(chocolates, mid, K)) &#123;</span><br><span class="line">            bestSide = mid;  </span><br><span class="line">            low = mid + 1;  </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            high = mid - 1;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bestSide &lt;&lt; endl; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>二分查找的应用</strong>：通过二分查找可以高效地求解正方形的最大边长，尤其是在边长空间较大时，能够显著降低时间复杂度。</p><p><strong>空间利用</strong>：通过使用哈希表和二分查找，我们在时间和空间上达到了较优的平衡，能够处理最大规模的数据。</p><p><strong>问题的数学转化</strong>：通过将切割问题转化为数目判断问题，利用二分查找可以有效避免暴力破解的高时间复杂度。</p><h2 id="四-卡牌"><a href="#四-卡牌" class="headerlink" title="四.卡牌"></a>四.卡牌</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p><strong>减少重复计算</strong>：</p><ul><li>在 <code>canMakeKSets</code> 函数中，我们每次都需要计算空白卡牌的数量。考虑到 <code>a[i]</code> 和 <code>b[i]</code> 对于每个卡牌是固定的，我们可以提前计算每种卡牌的补充量，然后直接通过前缀和计算每个 <code>k</code> 的所需补充卡牌数。</li></ul><p><strong>通过前缀和优化卡牌需求计算</strong>：</p><ul><li>计算需要补充的空白卡牌数时，如果我们能提前计算出每种卡牌在每个 <code>k</code> 值下需要多少空白卡牌，可以加速查找。</li><li>我们可以使用 <strong>贪心策略</strong> 或者 <strong>扫描算法</strong>，避免每次都全量扫描 <code>n</code> 个卡牌。</li></ul><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n, m, a[N + 5], b[N + 5];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    bool f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    for (; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) f ^= (ch == &#x27;-&#x27;);</span><br><span class="line">    for (; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool check(int mid) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cnt += max(0LL, mid - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt &lt;= m;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Kafka() &#123;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line">    </span><br><span class="line">    int L = 1, R = n * 2;</span><br><span class="line"> </span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i] = read();</span><br><span class="line">        R = min(a[i] + b[i], R);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二分查找最大套牌数</span><br><span class="line">    while (L &lt; R) &#123;</span><br><span class="line">        int mid = (L + R + 1) &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) &#123;</span><br><span class="line">            L = mid;  </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            R = mid - 1; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; L &lt;&lt; &#x27;\n&#x27;;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>提前计算补充数量</strong>：通过一次遍历计算每个 <code>k</code> 需要的补充卡牌数量，可以减少时间复杂度，避免重复计算。</p><p><strong>二分查找的技巧</strong>：通过二分查找可以有效缩小搜索范围，每次判断可以集中判断某个 <code>k</code> 是否可行。</p><p><strong>空间优化</strong>：只使用简单的数组来存储卡牌数量和补充限制，空间复杂度为 <code>O(n)</code>，符合题目要求。</p><h2 id="五-书的复制"><a href="#五-书的复制" class="headerlink" title="五.书的复制"></a>五.书的复制</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题目要求将 <code>m</code> 本有顺序的书分给 <code>k</code> 个人复制，每个人抄写的书是连续的，并且需要尽可能最短的复制时间。复制时间指的是抄写页数最多的人所用的时间，目标是尽可能减少这个时间。</p><p>为了解决这个问题，采用了 <strong>二分查找</strong> 和 <strong>贪心算法</strong> 结合的策略：</p><ol><li><strong>二分查找</strong>：<ul><li>对于复制时间的最大值 <code>max_time</code>（即抄写页数最多的人的时间），我们可以进行二分查找。</li><li>初始时，设置 <code>L = 1</code>（最小值）和 <code>R = sum(a)</code>（最大值，所有书页加起来）。</li><li>对于每个中间值 <code>mid</code>，我们要判断是否能在 <code>mid</code> 的最大时间限制下，合理分配书籍给 <code>k</code> 个人。</li></ul></li><li><strong>贪心算法</strong>：<ul><li>每次尝试用当前的 <code>mid</code> 来分配书籍：从书籍列表中依次分配，如果当前人的已分配页数超过 <code>mid</code>，就开始分配给下一个人。</li><li>通过这种方式，我们可以确定在当前的 <code>mid</code> 时间下，能分配给 <code>k</code> 个人。</li></ul></li><li><strong>过程描述</strong>：<ul><li>对于每次二分查找的 <code>mid</code>，我们从第 1 个人开始，贪心地分配书籍。如果当前书籍无法分配给当前人（超出了 <code>mid</code> 时间），就换给下一个人，直到所有书籍分配完。</li><li>如果我们能够在 <code>k</code> 个人内完成分配，那么说明当前的 <code>mid</code> 值是可行的，我们尝试缩小 <code>mid</code>；否则，增大 <code>mid</code>。</li></ul></li><li><strong>结果输出</strong>：<ul><li>二分查找结束后，最终的最优时间就是 <code>L</code>，然后根据该时间输出每个人抄写的书籍区间。</li></ul></li></ol><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int K=500;</span><br><span class="line">int m,k,a[K+5];</span><br><span class="line">int st[K+5],ed[K+5];</span><br><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int x=0;bool f=1;char ch=getchar();</span><br><span class="line">    for(;ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;;ch=getchar())f^=(ch==&#x27;-&#x27;);</span><br><span class="line">    for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar())x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);</span><br><span class="line">    return f?x:-x;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int mid)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt=1,now=mid;</span><br><span class="line">    for(int i=1;i&lt;=m&amp;&amp;cnt&lt;=k;++i) </span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&gt;now) ++cnt,--i,now=mid;</span><br><span class="line">        else now-=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line">void Kafka()</span><br><span class="line">&#123;</span><br><span class="line">    m=read(),k=read();</span><br><span class="line">    int L=1,R=0;</span><br><span class="line">    for(int i=1;i&lt;=m;++i) a[i]=read(),R+=a[i];</span><br><span class="line">    for(int mid=L+R&gt;&gt;1;L&lt;R;check(mid)?R=mid:L=mid+1)mid=L+R&gt;&gt;1;</span><br><span class="line">    ed[k]=m,st[1]=1;</span><br><span class="line">    for(int i=k,j=m,now=L;i;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        for(;now&gt;=a[j]&amp;&amp;j;--j) now-=a[j];</span><br><span class="line">        st[i]=j+1,ed[i-1]=j,now=L;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=k;++i) cout&lt;&lt;st[i]&lt;&lt;&#x27; &#x27;&lt;&lt;ed[i]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-4"><a href="#3-学习总结-4" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>本题考察了 <strong>二分查找</strong> 和 <strong>贪心算法</strong> 的结合使用。通过二分查找高效地探索最优解空间，再结合贪心算法快速判断是否能在指定时间内完成分配，使得问题得以高效解决。这种类型的问题不仅能够加深对算法思维的理解，还能帮助解决实际中遇到的类似最优化问题。</p><h2 id="六-青蛙过河"><a href="#六-青蛙过河" class="headerlink" title="六.青蛙过河"></a>六.青蛙过河</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求小青蛙在河对岸和学校之间来回跳跃，以最小化跳跃的能力（即最小的跳跃距离）。每次小青蛙必须从一块石头起跳，并且跳跃的距离不能超过某个值。为了确保小青蛙能够完成指定的跳跃次数（2x次），我们需要找到一个合适的跳跃距离，使得它能够在有限的跳跃次数内成功完成任务。</p><ul><li><p>首先我们需要确定最小跳跃能力的范围。最小值为 <code>1</code>，最大值为 <code>n-1</code>（即河宽度），即从河的起点到终点的最大跳跃距离。</p></li><li><p>我们可以使用二分查找来缩小跳跃能力的范围。通过不断尝试不同的跳跃能力 <code>mid</code>，并判断是否能够完成 <code>2x</code> 次跳跃。</p></li><li><p>为了判断某个跳跃能力是否合适，模拟小青蛙的跳跃过程：从起点开始，每次尝试跳跃尽可能远的石头（跳跃的距离不超过当前的 <code>mid</code>），并尽量减少跳跃的次数。</p></li><li><p>如果跳跃次数小于或等于 <code>2x</code>，则当前跳跃能力 <code>mid</code> 是可行的。</p></li><li><p>否则，当前跳跃能力 <code>mid</code> 太小，不能完成任务。</p></li><li><p>通过二分查找不断调整跳跃能力的范围，直到找到最小的可行跳跃能力。</p></li></ul><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n, x, H[N + 5], sum[N + 5];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0; bool f = 1; char ch = getchar();</span><br><span class="line">    for (; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) f ^= (ch == &#x27;-&#x27;);</span><br><span class="line">    for (; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check(int mid) &#123;</span><br><span class="line">    int cnt = 0, last = 0;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        if (i - last &gt; mid) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            last = i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n - last &gt; mid) cnt++;</span><br><span class="line">    return cnt &lt;= 2 * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Kafka() &#123;</span><br><span class="line">    n = read(), x = read();</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        H[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int L = 1, R = n, ans = n;</span><br><span class="line">    while (L &lt;= R) &#123;</span><br><span class="line">        int mid = (L + R) &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            R = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            L = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-5"><a href="#3-学习总结-5" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>二分查找的应用</strong><br>二分查找通常用来在有序区间中查找某个满足条件的值。在本题中，我们通过二分查找来找到最小的跳跃能力，这种问题通常被称为“最小最大化问题”。</p><p><strong>模拟问题的实现</strong><br>本题中模拟了小青蛙的跳跃过程，模拟的关键是如何判断是否能在有限的跳跃次数内完成任务。通过检查每个 <code>mid</code> 跳跃能力是否能够完成 <code>2x</code> 次跳跃，判断当前跳跃能力的可行性。</p><p><strong>问题求解中的二分查找优化</strong><br>由于本题的跳跃能力是一个整数范围，且通过验证跳跃能力的可行性可以在常数时间内完成，所以二分查找在这个问题中是一种高效的求解方法。</p><p><strong>复杂度分析</strong></p><ul><li>二分查找的时间复杂度是 <code>O(log n)</code>。</li><li>对每个 <code>mid</code> 值，我们需要遍历石头进行一次跳跃模拟，最坏情况下是 <code>O(n)</code>。</li><li>因此，总的时间复杂度是 <code>O(n log n)</code>，对于 <code>n</code> 最大为 <code>10^5</code> 的数据，能够有效地在时间限制内完成计算。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task 1</title>
      <link href="/2025/02/06/Task-1/"/>
      <url>/2025/02/06/Task-1/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第一讲：C-基础"><a href="#寒假第一讲：C-基础" class="headerlink" title="寒假第一讲：C++ 基础"></a>寒假第一讲：C++ 基础</h1><h2 id="一-Long-Loong"><a href="#一-Long-Loong" class="headerlink" title="一.Long Loong"></a>一.Long Loong</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>思路较为简单，就是先固定输出L，再根据输入的N得到应该输出多少o，最后再固定输出ng。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; &#x27;L&#x27;;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">cout &lt;&lt; &#x27;o&#x27;;</span><br><span class="line">cout &lt;&lt; &quot;ng&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>学到了for循环的基本用法，对我帮助极大，受益良多。</p><h2 id="二-YES-or-YES"><a href="#二-YES-or-YES" class="headerlink" title="二.YES or YES?"></a>二.YES or YES?</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>思路就是将输入的字符串全部大写，然后判断是否等于YES，如果等于就输出YES，不等于就输出NO。</p><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t; </span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        transform(s.begin(), s.end(), s.begin(), ::toupper);</span><br><span class="line">        if (s == &quot;YES&quot;) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>字符串处理：通过 <code>transform</code> 配合 <code>tolower</code> 或 <code>toupper</code>，可以快速将字符串统一为小写或大写，便于比较。</li><li>循环与分支：利用 <code>while (t--)</code> 循环高效处理多组输入，结合 <code>if-else</code> 判断分类处理逻辑。</li><li>时间复杂度：转换大小写或比较字符串的复杂度为 O(字符串长度)O(\text{字符串长度})O(字符串长度)。整体复杂度为 O(t)O(t)O(t)，适用于测试用例较多的情况。</li><li>STL 使用：标准库函数如 <code>transform</code> 和字符串直接比较提升了代码简洁性和可靠性。</li></ol><h2 id="三-Even-Odd-G"><a href="#三-Even-Odd-G" class="headerlink" title="三.Even? Odd? G"></a>三.Even? Odd? G</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这个程序的主要任务是根据输入的一组超大整数，判断每个整数的奇偶性（即最后一位数字是偶数还是奇数）。由于数的范围可能非常大（高达 106010^{60}1060），无法直接使用普通整数类型（如 <code>int</code> 或 <code>long long</code>），所以采用字符串处理的方式。</p><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    int N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; results;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        string number;</span><br><span class="line">        cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">        char lastDigit = number[number.length() - 1];</span><br><span class="line">        if ((lastDigit - &#x27;0&#x27;) % 2 == 0) &#123;</span><br><span class="line">            results.push_back(&quot;even&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            results.push_back(&quot;odd&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (const string&amp; result : results) &#123;</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>字符串处理大数</strong>：</p><ul><li>当数字的范围超过内置类型的支持时，可以用字符串表示并处理。</li><li>判断奇偶性只需关注数字的最后一位，简化了大数的操作。</li></ul><p><strong>模运算的应用</strong>：</p><ul><li>奇偶性的本质是看数字能否被 222 整除，通过 mod  2\mod 2mod2 运算即可实现。</li></ul><h2 id="四-Problem-Generator"><a href="#四-Problem-Generator" class="headerlink" title="四.Problem Generator"></a>四.Problem Generator</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li>输入处理</li></ol><ul><li>读取测试用例数量 <code>t</code>。</li><li>对于每个测试用例，读取两个整数 <code>n</code>（题库题目数量）和 <code>m</code>（比赛轮次），以及一个字符串 <code>a</code> 表示题库中的题目难度。</li></ul><ol start="2"><li>统计题目数量</li></ol><ul><li>使用7个变量 <code>n1</code> 到 <code>n7</code> 分别记录每种难度（A到G）的题目数量。</li><li>遍历字符串 <code>a</code>，通过比较字符 <code>c</code> 是否为 ‘A’ 到 ‘G’ 来对每种难度的题目计数。</li></ul><ol start="3"><li>每种难度的最大需求</li></ol><ul><li>每轮比赛需要一个完整的难度级别（A到G），即每种难度最多需要 mmm 道题。</li></ul><ol start="4"><li>计算需要补充的题目数量</li></ol><ul><li><p>每轮比赛需要7种难度的题目，因此总需求为 7×m7 \times m7×m。</p></li><li><p>当前已有的题目总量为 n1+n2+⋯+n7n1 + n2 + \dots + n7n1+n2+⋯+n7。</p></li><li><p>需要补充的题目数量为： 需要补充&#x3D;max⁡(0,7×m−当前已有的题目总量)\text{需要补充} &#x3D; \max(0, 7 \times m - \text{当前已有的题目总量})需要补充&#x3D;max(0,7×m−当前已有的题目总量)</p></li><li><p>如果已有题目足够，则补充为0；否则补充缺少的题目数量。</p></li></ul><ol start="5"><li>输出结果</li></ol><ul><li>将每个测试用例的结果输出在单独的一行。</li></ul><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;   </span><br><span class="line"> </span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        string a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        int n1 = 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0, n6 = 0, n7 = 0;</span><br><span class="line">        for (char c : a)</span><br><span class="line">        &#123;</span><br><span class="line">            if (c == &#x27;A&#x27;)</span><br><span class="line">                n1++;</span><br><span class="line">            if (c == &#x27;B&#x27;)</span><br><span class="line">                n2++;</span><br><span class="line">            if (c == &#x27;C&#x27;)</span><br><span class="line">                n3++;</span><br><span class="line">            if (c == &#x27;D&#x27;)</span><br><span class="line">                n4++;</span><br><span class="line">            if (c == &#x27;E&#x27;)</span><br><span class="line">                n5++;</span><br><span class="line">            if (c == &#x27;F&#x27;)</span><br><span class="line">                n6++;</span><br><span class="line">            if (c == &#x27;G&#x27;)</span><br><span class="line">                n7++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n1 &gt; m)</span><br><span class="line">            n1 = m;</span><br><span class="line">        if (n2 &gt; m)</span><br><span class="line">            n2 = m;</span><br><span class="line">        if (n3 &gt; m)</span><br><span class="line">            n3 = m;</span><br><span class="line">        if (n4 &gt; m)</span><br><span class="line">            n4 = m;</span><br><span class="line">        if (n5 &gt; m)</span><br><span class="line">            n5 = m;</span><br><span class="line">        if (n6 &gt; m)</span><br><span class="line">            n6 = m;</span><br><span class="line">        if (n7 &gt; m)</span><br><span class="line">            n7 = m;</span><br><span class="line">        cout &lt;&lt; max(0, 7 * m - n1 - n2 - n3 - n4 - n5 - n6 - n7) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ul><li><p>本题通过统计每种难度题目的数量解决问题。这是字符频率统计的典型应用。</p></li><li><p>通过遍历字符串并比较字符，可以有效统计各类别出现次数。</p></li></ul><h2 id="五-rules"><a href="#五-rules" class="headerlink" title="五.rules"></a>五.rules</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这段代码解决的问题是考察规则是否符合民意，主要步骤如下：</p><ol><li><p>输入数据：首先读取居民总数 <code>n</code>、记录天数 <code>m</code> 以及规则代号 <code>k</code>。</p></li><li><p>统计符合民意的天数：</p><p>循环 <code>m</code> 次，表示逐天处理记录。</p><p>对每一天，统计有多少居民遵守了规则 <code>k</code>（计数器 <code>c2</code>）。</p><p>如果遵守规则 <code>k</code> 的人数大于等于一半 (<code>c2 * 2 &gt;= n</code>)，则该天规则符合民意，符合民意的天数计数器 <code>c1</code> 加一。</p></li><li><p>判断规则正确性</p><p>：如果符合民意的天数大于等于记录天数的一半 (<code>c1 * 2 &gt;= m</code>)，输出 “YES” 表示规则正确，否则输出 “NO”。</p></li></ol><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m, n, k;</span><br><span class="line">int c1 = 0, c2 = 0;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">for (int i = 0; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">c2 = 0;</span><br><span class="line">for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">if (t == k)</span><br><span class="line">&#123;</span><br><span class="line">c2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if ( c2*2 &gt;=  n)</span><br><span class="line">&#123;</span><br><span class="line">c1++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;if ( c1*2 &gt;=  m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;YES&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-4"><a href="#3-学习总结-4" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>这道题目涉及多重循环的处理，是学习数组与条件判断的重要练习。通过这段代码可以总结如下：</p><ol><li><p>理解核心逻辑</p><p>问题的核心在于两层判断：一是某天规则是否符合民意，二是统计符合民意的天数是否达到要求。这种多层嵌套条件是常见的编程模式。</p></li><li><p>优化循环效率</p><p>本代码通过双重循环按天和按人处理问题，时间复杂度为 O(m×n)O(m \times n)O(m×n)。这种结构在处理范围较大时可能需要优化。</p></li><li><p>掌握计数逻辑</p><p>使用计数器 <code>c2</code> 和 <code>c1</code> 逐步累积数据，并通过条件判断更新状态。这种逻辑清晰、简洁，适合复杂问题分步解决。</p></li></ol><h2 id="六-Many-Replacement"><a href="#六-Many-Replacement" class="headerlink" title="六.Many Replacement"></a>六.Many Replacement</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p>初始化映射表：</p><p>创建一个 <code>mapping</code> 数组，长度为 26（表示字母表），初始化为 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 的对应字母。这个表将用于记录字母替换关系。</p></li><li><p>处理替换操作：</p><p>对每个替换指令 <code>(c, d)</code>，遍历 <code>mapping</code> 数组，将所有值等于 <code>c</code> 的项替换为 <code>d</code>。</p><p>这种方式确保了间接替换链条也能正确生效。例如，如果先将 <code>a</code> 替换为 <code>b</code>，再将 <code>b</code> 替换为 <code>c</code>，最终 <code>a</code> 也会被替换为 <code>c</code>。</p></li><li><p>修改字符串：</p><p>遍历字符串 <code>S</code> 的每个字符，根据 <code>mapping</code> 数组中的映射关系，将字符替换为最终映射的目标字符。</p></li><li><p>输出结果：</p><p>输出修改后的字符串 <code>S</code>。</p></li></ol><p>通过使用 <code>mapping</code> 数组记录全局映射关系，避免直接修改字符串多次，提高了处理效率。</p><h3 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, Q;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    string S;</span><br><span class="line">    cin &gt;&gt; S;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    vector&lt;char&gt; mapping(26);</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">        mapping[i] = &#x27;a&#x27; + i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; Q; i++) &#123;</span><br><span class="line">        char c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        for (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">            if (mapping[j] == c) &#123;</span><br><span class="line">                mapping[j] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (char &amp;ch : S) &#123;</span><br><span class="line">        ch = mapping[ch - &#x27;a&#x27;]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-5"><a href="#3-学习总结-5" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>1.高效处理替换链：</p><p>  使用一个映射表 (<code>mapping</code> 数组) 将字符替换逻辑统一管理，避免了直接在字符串中进行多次替换操作，降低了时间复杂度。</p><p>2.间接替换链的处理：</p><p>  通过在处理替换指令时遍历整个映射表，确保链式替换得到正确结果。这种方法适用于有依赖关系的替换问题。</p><p>3.复杂度优化：</p><p>  替换操作遍历 <code>mapping</code> 的复杂度为 O(Q×26)O(Q \times 26)O(Q×26)，字符串替换为 O(N)O(N)O(N)，整体复杂度约为 O(Q+N)O(Q + N)O(Q+N)，足以处理较大输入规模。</p><p>4.边界条件考虑：</p><p>  替换字符可以是相同的（<code>c = d</code>），这种情况不会影响映射表。</p><p>  某些字符可能不存在于字符串中，但替换逻辑依然可以正常处理。</p><h2 id="更好的交换"><a href="#更好的交换" class="headerlink" title="更好的交换"></a>更好的交换</h2><h3 id="1-对应思路-6"><a href="#1-对应思路-6" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p>输入与初始化：</p><p>读取矩阵大小 <code>n</code> 和操作次数 <code>m</code>。</p><p>读取矩阵内容并存储在 <code>matrix</code> 中。</p><p>初始化两个数组 <code>row_map</code> 和 <code>col_map</code>，分别记录行和列的映射关系，初始值为 <code>[0, 1, 2, ..., n-1]</code>。</p></li><li><p>操作处理：</p><p>遍历每个操作，根据操作类型：</p><p>  若 <code>op == 1</code>（交换行），则交换 <code>row_map[x]</code> 和 <code>row_map[y]</code>。</p><p>  若 <code>op == 0</code>（交换列），则交换 <code>col_map[x]</code> 和 <code>col_map[y]</code>。</p><p>通过修改 <code>row_map</code> 和 <code>col_map</code> 的映射关系，而非直接修改矩阵，节省了时间复杂度。</p></li><li><p>输出矩阵：</p><p>根据最终的 <code>row_map</code> 和 <code>col_map</code>，重新按映射顺序输出矩阵。<code>matrix[row_map[i]][col_map[j]]</code> 得到正确的映射值。</p></li></ol><p>通过这种间接映射法，避免了每次交换直接操作矩阵，提高了效率，适合大规模输入。</p><h3 id="2-代码-6"><a href="#2-代码-6" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n));</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; row_map(n), col_map(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        row_map[i] = i; </span><br><span class="line">        col_map[i] = i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        --x; </span><br><span class="line">        --y;</span><br><span class="line">        if (op == 1) &#123;</span><br><span class="line">            swap(row_map[x], row_map[y]); </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            swap(col_map[x], col_map[y]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; matrix[row_map[i]][col_map[j]] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-6"><a href="#3-学习总结-6" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>间接映射优化：</p><p>​    直接交换矩阵行列会带来高昂的时间复杂度，间接通过映射数组调整顺序是一种高效的解决方式。</p><p>空间与时间的平衡：</p><p>​    增加两个映射数组 <code>row_map</code> 和 <code>col_map</code>，用空间换取了时间的优化。</p><p>​    在 mmm 次操作和 n2n^2n2 次矩阵访问中，复杂度降低为 O(n2+m)O(n^2 + m)O(n2+m)，适合处理大规模 n,mn, mn,m。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog用法</title>
      <link href="/2025/02/06/blog%E7%94%A8%E6%B3%95/"/>
      <url>/2025/02/06/blog%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h1 id="本地网站"><a href="#本地网站" class="headerlink" title="本地网站"></a>本地网站</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/06/hello-world/"/>
      <url>/2025/02/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
