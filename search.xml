<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQLite用法</title>
      <link href="/2025/03/15/SQLite%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/SQLite%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>SQLite 是一种轻量级的嵌入式数据库，在 Android 中用于存储结构化数据。你可以通过 <code>SQLiteOpenHelper</code> 来管理数据库的创建、升级、和版本管理。以下是使用 SQLite 的基本步骤：</p><h2 id="1-创建数据库和表"><a href="#1-创建数据库和表" class="headerlink" title="1. 创建数据库和表"></a><strong>1. 创建数据库和表</strong></h2><p>使用 <code>SQLiteOpenHelper</code> 创建数据库以及表结构。这个类会帮助你创建数据库、执行表的升级、降级等操作。</p><h3 id="创建-SQLiteOpenHelper-类"><a href="#创建-SQLiteOpenHelper-类" class="headerlink" title="创建 SQLiteOpenHelper 类"></a><strong>创建 SQLiteOpenHelper 类</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑import android.content.Context</span><br><span class="line">import android.database.sqlite.SQLiteDatabase</span><br><span class="line">import android.database.sqlite.SQLiteOpenHelper</span><br><span class="line"></span><br><span class="line">class MyDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private const val DATABASE_NAME = &quot;my_database.db&quot; // 数据库名称</span><br><span class="line">        private const val DATABASE_VERSION = 1 // 数据库版本号</span><br><span class="line">        private const val TABLE_NAME = &quot;users&quot; // 表名称</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase) &#123;</span><br><span class="line">        // 创建数据库表</span><br><span class="line">        val createTableQuery = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE $TABLE_NAME (</span><br><span class="line">                id INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                name TEXT NOT NULL,</span><br><span class="line">                age INTEGER</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;.trimIndent()</span><br><span class="line">        db.execSQL(createTableQuery)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        // 如果数据库版本变化时，删除旧表并创建新表</span><br><span class="line">        db.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NAME&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>onCreate</code></strong>：当数据库首次创建时执行。通常在这里创建表和初始化数据。</li><li><strong><code>onUpgrade</code></strong>：当数据库版本发生变化时执行。你可以在这里进行表的迁移或删除。</li></ul><h2 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2. 插入数据"></a><strong>2. 插入数据</strong></h2><p>插入数据需要通过 <code>SQLiteDatabase.insert()</code> 方法来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑import android.content.ContentValues</span><br><span class="line"></span><br><span class="line">fun insertUser(context: Context, name: String, age: Int) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val values = ContentValues().apply &#123;</span><br><span class="line">        put(&quot;name&quot;, name)</span><br><span class="line">        put(&quot;age&quot;, age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    db.insert(&quot;users&quot;, null, values)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>ContentValues</code></strong>：是用于存储要插入的数据的容器。通过 <code>put</code> 方法将列名和值添加到 <code>ContentValues</code> 中。</li><li><strong><code>insert</code></strong>：插入数据的方法，第一个参数是表名，第二个参数是列为空时插入的默认值，第三个参数是 <code>ContentValues</code>。</li></ul><h2 id="3-查询数据"><a href="#3-查询数据" class="headerlink" title="3. 查询数据"></a><strong>3. 查询数据</strong></h2><p>查询数据使用 <code>SQLiteDatabase.query()</code> 或 <code>SQLiteDatabase.rawQuery()</code> 方法。</p><h3 id="使用-query-方法"><a href="#使用-query-方法" class="headerlink" title="使用 query() 方法"></a>使用 <code>query()</code> 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑import android.database.Cursor</span><br><span class="line"></span><br><span class="line">fun queryUsers(context: Context): List&lt;User&gt; &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.readableDatabase</span><br><span class="line"></span><br><span class="line">    val cursor: Cursor = db.query(</span><br><span class="line">        &quot;users&quot;, // 表名</span><br><span class="line">        arrayOf(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;), // 列名</span><br><span class="line">        null, // WHERE 子句</span><br><span class="line">        null, // WHERE 子句的参数</span><br><span class="line">        null, // GROUP BY 子句</span><br><span class="line">        null, // HAVING 子句</span><br><span class="line">        null // ORDER BY 子句</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val users = mutableListOf&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    while (cursor.moveToNext()) &#123;</span><br><span class="line">        val id = cursor.getLong(cursor.getColumnIndexOrThrow(&quot;id&quot;))</span><br><span class="line">        val name = cursor.getString(cursor.getColumnIndexOrThrow(&quot;name&quot;))</span><br><span class="line">        val age = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;age&quot;))</span><br><span class="line"></span><br><span class="line">        users.add(User(id, name, age))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    return users</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data class User(val id: Long, val name: String, val age: Int)</span><br></pre></td></tr></table></figure><ul><li><strong><code>query</code></strong>：用于查询数据库，返回一个 <code>Cursor</code> 对象。你可以通过 <code>Cursor</code> 遍历结果集。</li><li><strong><code>getColumnIndexOrThrow()</code></strong>：根据列名获取列的索引，<code>getString()</code>, <code>getInt()</code> 等方法用于提取数据。</li></ul><h3 id="使用-rawQuery-方法"><a href="#使用-rawQuery-方法" class="headerlink" title="使用 rawQuery() 方法"></a>使用 <code>rawQuery()</code> 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑fun queryUsersRaw(context: Context): List&lt;User&gt; &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.readableDatabase</span><br><span class="line"></span><br><span class="line">    val cursor: Cursor = db.rawQuery(&quot;SELECT * FROM users&quot;, null)</span><br><span class="line"></span><br><span class="line">    val users = mutableListOf&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    while (cursor.moveToNext()) &#123;</span><br><span class="line">        val id = cursor.getLong(cursor.getColumnIndex(&quot;id&quot;))</span><br><span class="line">        val name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;))</span><br><span class="line">        val age = cursor.getInt(cursor.getColumnIndex(&quot;age&quot;))</span><br><span class="line"></span><br><span class="line">        users.add(User(id, name, age))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    return users</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>rawQuery()</code></strong>：执行原始的 SQL 查询语句，返回一个 <code>Cursor</code>。</li></ul><h2 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4. 更新数据"></a><strong>4. 更新数据</strong></h2><p>更新数据使用 <code>SQLiteDatabase.update()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑import android.content.ContentValues</span><br><span class="line"></span><br><span class="line">fun updateUser(context: Context, id: Long, name: String, age: Int) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val values = ContentValues().apply &#123;</span><br><span class="line">        put(&quot;name&quot;, name)</span><br><span class="line">        put(&quot;age&quot;, age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val selection = &quot;id = ?&quot;</span><br><span class="line">    val selectionArgs = arrayOf(id.toString())</span><br><span class="line"></span><br><span class="line">    db.update(&quot;users&quot;, values, selection, selectionArgs)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>update()</code></strong>：更新数据的方法。第一个参数是表名，第二个参数是更新的值，第三个参数是 <code>WHERE</code> 子句，第四个参数是 <code>WHERE</code> 子句的参数。</li></ul><h2 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5. 删除数据"></a><strong>5. 删除数据</strong></h2><p>删除数据使用 <code>SQLiteDatabase.delete()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑fun deleteUser(context: Context, id: Long) &#123;</span><br><span class="line">    val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">    val db = dbHelper.writableDatabase</span><br><span class="line"></span><br><span class="line">    val selection = &quot;id = ?&quot;</span><br><span class="line">    val selectionArgs = arrayOf(id.toString())</span><br><span class="line"></span><br><span class="line">    db.delete(&quot;users&quot;, selection, selectionArgs)</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>delete()</code></strong>：删除数据的方法，类似于 <code>update()</code> 方法，传入 <code>WHERE</code> 子句来指定删除条件。</li></ul><h2 id="6-关闭数据库连接"><a href="#6-关闭数据库连接" class="headerlink" title="6. 关闭数据库连接"></a><strong>6. 关闭数据库连接</strong></h2><p>每次操作完数据库后，记得关闭数据库连接，防止内存泄漏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kotlin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><strong>创建数据库和表</strong>：通过继承 <code>SQLiteOpenHelper</code> 类来创建数据库及表。</li><li><strong>插入数据</strong>：使用 <code>ContentValues</code> 结合 <code>insert()</code> 方法插入数据。</li><li><strong>查询数据</strong>：通过 <code>query()</code> 或 <code>rawQuery()</code> 查询数据，返回 <code>Cursor</code> 对象进行遍历。</li><li><strong>更新数据</strong>：使用 <code>update()</code> 方法更新数据。</li><li><strong>删除数据</strong>：使用 <code>delete()</code> 方法删除数据。</li><li><strong>关闭数据库连接</strong>：操作完成后记得关闭数据库。</li></ol><p>SQLite 提供了强大的本地数据存储能力，适合用于需要存储结构化数据的应用。</p><p><strong>完整示例</strong></p><p>假设我们有一个应用需要保存用户信息，每个用户包含 <code>id</code>、<code>name</code> 和 <code>email</code>。我们可以在数据库中创建一个表并对数据进行增删改查操作。</p><h4 id="1-数据库助手类"><a href="#1-数据库助手类" class="headerlink" title="1. 数据库助手类"></a>1. 数据库助手类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MyDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val DATABASE_NAME = &quot;my_database.db&quot;</span><br><span class="line">        const val DATABASE_VERSION = 1</span><br><span class="line">        const val TABLE_NAME = &quot;users&quot;</span><br><span class="line">        const val COLUMN_ID = &quot;id&quot;</span><br><span class="line">        const val COLUMN_NAME = &quot;name&quot;</span><br><span class="line">        const val COLUMN_EMAIL = &quot;email&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(db: SQLiteDatabase?) &#123;</span><br><span class="line">        val createTableQuery = &quot;&quot;&quot;</span><br><span class="line">            CREATE TABLE $TABLE_NAME (</span><br><span class="line">                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="line">                $COLUMN_NAME TEXT,</span><br><span class="line">                $COLUMN_EMAIL TEXT</span><br><span class="line">            )</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        db?.execSQL(createTableQuery)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NAME&quot;)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-插入数据-1"><a href="#2-插入数据-1" class="headerlink" title="2. 插入数据"></a>2. 插入数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val dbHelper = MyDatabaseHelper(context)</span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_NAME, &quot;John Doe&quot;)</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_EMAIL, &quot;john.doe@example.com&quot;)</span><br><span class="line">&#125;</span><br><span class="line">db.insert(MyDatabaseHelper.TABLE_NAME, null, values)</span><br></pre></td></tr></table></figure><h4 id="3-查询数据-1"><a href="#3-查询数据-1" class="headerlink" title="3. 查询数据"></a>3. 查询数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val db = dbHelper.readableDatabase</span><br><span class="line">val cursor = db.query(</span><br><span class="line">    MyDatabaseHelper.TABLE_NAME,</span><br><span class="line">    arrayOf(MyDatabaseHelper.COLUMN_ID, MyDatabaseHelper.COLUMN_NAME, MyDatabaseHelper.COLUMN_EMAIL),</span><br><span class="line">    null, null, null, null, null</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">while (cursor.moveToNext()) &#123;</span><br><span class="line">    val id = cursor.getLong(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_ID))</span><br><span class="line">    val name = cursor.getString(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_NAME))</span><br><span class="line">    val email = cursor.getString(cursor.getColumnIndex(MyDatabaseHelper.COLUMN_EMAIL))</span><br><span class="line">    println(&quot;User: $id, $name, $email&quot;)</span><br><span class="line">&#125;</span><br><span class="line">cursor.close()</span><br></pre></td></tr></table></figure><h4 id="4-更新数据-1"><a href="#4-更新数据-1" class="headerlink" title="4. 更新数据"></a>4. 更新数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val values = ContentValues().apply &#123;</span><br><span class="line">    put(MyDatabaseHelper.COLUMN_NAME, &quot;John Smith&quot;)</span><br><span class="line">&#125;</span><br><span class="line">val selection = &quot;$&#123;MyDatabaseHelper.COLUMN_ID&#125; = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">db.update(MyDatabaseHelper.TABLE_NAME, values, selection, selectionArgs)</span><br></pre></td></tr></table></figure><h4 id="5-删除数据-1"><a href="#5-删除数据-1" class="headerlink" title="5. 删除数据"></a>5. 删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val selection = &quot;$&#123;MyDatabaseHelper.COLUMN_ID&#125; = ?&quot;</span><br><span class="line">val selectionArgs = arrayOf(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">val db = dbHelper.writableDatabase</span><br><span class="line">db.delete(MyDatabaseHelper.TABLE_NAME, selection, selectionArgs)</span><br></pre></td></tr></table></figure><h4 id="6-关闭数据库"><a href="#6-关闭数据库" class="headerlink" title="6. 关闭数据库"></a>6. 关闭数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.close()</span><br></pre></td></tr></table></figure><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>SQLiteOpenHelper</strong>：管理数据库的创建、升级等操作。</li><li><strong>SQLiteDatabase</strong>：用于执行数据库操作，如插入、查询、更新、删除。</li><li><strong>ContentValues</strong>：用于存储要插入或更新的数据。</li><li><strong>Cursor</strong>：用于访问查询结果。</li></ul><p>SQLite 是一种非常有效的方式来在 Android 上进行本地数据存储，尤其适用于存储小型结构化数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Room+ViewModel+LiveData一起使用的用法</title>
      <link href="/2025/03/15/Room-ViewModel-LiveData%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/Room-ViewModel-LiveData%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 <code>Android</code> 开发中，<code>Room</code>、<code>ViewModel</code> 和 <code>LiveData</code> 经常一起使用，以实现 <strong>MVVM 架构</strong>，并提供持久化数据存储、生命周期感知的数据管理和自动更新 UI 的能力。</p><hr><h1 id="📌-1-主要作用"><a href="#📌-1-主要作用" class="headerlink" title="📌 1. 主要作用"></a><strong>📌 1. 主要作用</strong></h1><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>Room（数据库）</strong></td><td>提供 SQLite 的抽象层，管理本地数据存储</td></tr><tr><td><strong>ViewModel</strong></td><td>管理 UI 相关的数据，确保数据在配置变更（如旋转屏幕）时不会丢失</td></tr><tr><td><strong>LiveData</strong></td><td>观察数据变化，并在 UI 组件生命周期内自动更新</td></tr></tbody></table><hr><h1 id="🚀-2-使用-Room-ViewModel-LiveData-的完整示例"><a href="#🚀-2-使用-Room-ViewModel-LiveData-的完整示例" class="headerlink" title="🚀 2. 使用 Room + ViewModel + LiveData 的完整示例"></a><strong>🚀 2. 使用 <code>Room + ViewModel + LiveData</code> 的完整示例</strong></h1><h3 id="📌-功能："><a href="#📌-功能：" class="headerlink" title="📌 功能："></a><strong>📌 功能</strong>：</h3><p>我们实现一个<strong>简单的待办事项（ToDo List）应用</strong>，可以：</p><ul><li><strong>增删查改任务</strong>，数据存储在 <code>Room</code> 数据库中。</li><li><strong>使用 <code>LiveData</code></strong> 让 UI <strong>自动更新</strong>，而不需要手动刷新。</li><li><strong><code>ViewModel</code> 负责管理数据</strong>，避免 <code>Activity</code> 直接操作数据库。</li></ul><hr><h2 id="📌-3-创建-Room-数据库"><a href="#📌-3-创建-Room-数据库" class="headerlink" title="📌 3. 创建 Room 数据库"></a><strong>📌 3. 创建 Room 数据库</strong></h2><h3 id="（1）定义-Entity（数据库表）"><a href="#（1）定义-Entity（数据库表）" class="headerlink" title="（1）定义 Entity（数据库表）"></a><strong>（1）定义 <code>Entity</code>（数据库表）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.Entity</span><br><span class="line">import androidx.room.PrimaryKey</span><br><span class="line"></span><br><span class="line">@Entity(tableName = &quot;todo_table&quot;)</span><br><span class="line">data class Todo(</span><br><span class="line">    @PrimaryKey(autoGenerate = true) val id: Int = 0,</span><br><span class="line">    val task: String,</span><br><span class="line">    val isCompleted: Boolean</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>@Entity</code>：表示这是一个数据库表，表名是 <code>todo_table</code>。</li><li><code>@PrimaryKey(autoGenerate = true)</code>：<code>id</code> 是主键，<code>Room</code> 会自动生成。</li></ul><hr><h3 id="（2）创建-DAO（数据访问对象）"><a href="#（2）创建-DAO（数据访问对象）" class="headerlink" title="（2）创建 DAO（数据访问对象）"></a><strong>（2）创建 DAO（数据访问对象）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line">import androidx.room.*</span><br><span class="line"></span><br><span class="line">@Dao</span><br><span class="line">interface TodoDao &#123;</span><br><span class="line">    @Insert(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    suspend fun insert(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    suspend fun update(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    suspend fun delete(todo: Todo)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM todo_table ORDER BY id DESC&quot;)</span><br><span class="line">    fun getAllTodos(): LiveData&lt;List&lt;Todo&gt;&gt; // 使用 LiveData 让 UI 自动更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Dao</code>：数据访问对象，定义数据库操作。</li><li><code>@Insert</code> &#x2F; <code>@Update</code> &#x2F; <code>@Delete</code>：操作数据库的基本增、删、改。</li><li><code>getAllTodos()</code> 返回 <code>LiveData&lt;List&lt;Todo&gt;&gt;</code>，<strong>Room 会自动监听数据变化，并更新 UI</strong>。</li></ul><hr><h3 id="（3）创建-Room-数据库"><a href="#（3）创建-Room-数据库" class="headerlink" title="（3）创建 Room 数据库"></a><strong>（3）创建 Room 数据库</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import androidx.room.Database</span><br><span class="line">import androidx.room.Room</span><br><span class="line">import androidx.room.RoomDatabase</span><br><span class="line"></span><br><span class="line">@Database(entities = [Todo::class], version = 1, exportSchema = false)</span><br><span class="line">abstract class TodoDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun todoDao(): TodoDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile</span><br><span class="line">        private var INSTANCE: TodoDatabase? = null</span><br><span class="line"></span><br><span class="line">        fun getDatabase(context: Context): TodoDatabase &#123;</span><br><span class="line">            return INSTANCE ?: synchronized(this) &#123;</span><br><span class="line">                val instance = Room.databaseBuilder(</span><br><span class="line">                    context.applicationContext,</span><br><span class="line">                    TodoDatabase::class.java,</span><br><span class="line">                    &quot;todo_database&quot;</span><br><span class="line">                ).build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Database(entities = [Todo::class], version = 1)</code>：定义数据库，包含 <code>Todo</code> 表。</li><li><code>synchronized(this)</code>：保证数据库实例的线程安全。</li><li><code>Room.databaseBuilder()</code>：构建 <code>Room</code> 数据库实例。</li></ul><hr><h2 id="📌-4-创建-Repository"><a href="#📌-4-创建-Repository" class="headerlink" title="📌 4. 创建 Repository"></a><strong>📌 4. 创建 Repository</strong></h2><p><code>Repository</code> 负责处理 <code>DAO</code> 操作，避免 <code>ViewModel</code> 直接操作数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line"></span><br><span class="line">class TodoRepository(private val todoDao: TodoDao) &#123;</span><br><span class="line">    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt; = todoDao.getAllTodos()</span><br><span class="line"></span><br><span class="line">    suspend fun insert(todo: Todo) &#123;</span><br><span class="line">        todoDao.insert(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun update(todo: Todo) &#123;</span><br><span class="line">        todoDao.update(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun delete(todo: Todo) &#123;</span><br><span class="line">        todoDao.delete(todo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Repository</code> 封装 <code>DAO</code>，<strong>ViewModel 只需要调用 <code>Repository</code>，而不直接操作 <code>Room</code></strong>。</li></ul><hr><h2 id="📌-5-创建-ViewModel"><a href="#📌-5-创建-ViewModel" class="headerlink" title="📌 5. 创建 ViewModel"></a><strong>📌 5. 创建 ViewModel</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.*</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">class TodoViewModel(private val repository: TodoRepository) : ViewModel() &#123;</span><br><span class="line">    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt; = repository.allTodos</span><br><span class="line"></span><br><span class="line">    fun insert(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.insert(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun update(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.update(todo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun delete(todo: Todo) = viewModelScope.launch &#123;</span><br><span class="line">        repository.delete(todo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>viewModelScope.launch &#123;&#125;</code> 让数据库操作在 <strong>后台线程执行</strong>（<code>suspend</code> 需要 <code>Coroutine</code>）。</li><li><code>LiveData&lt;List&lt;Todo&gt;&gt;</code> 确保 UI 自动更新。</li></ul><hr><h2 id="📌-6-创建-ViewModelFactory"><a href="#📌-6-创建-ViewModelFactory" class="headerlink" title="📌 6. 创建 ViewModelFactory"></a><strong>📌 6. 创建 ViewModelFactory</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import androidx.lifecycle.ViewModelProvider</span><br><span class="line"></span><br><span class="line">class TodoViewModelFactory(private val repository: TodoRepository) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(TodoViewModel::class.java)) &#123;</span><br><span class="line">            @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">            return TodoViewModel(repository) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ViewModelFactory</code> 用于 <strong>传递 <code>Repository</code></strong>，让 <code>ViewModel</code> 使用 <code>Room</code>。</li></ul><hr><h2 id="📌-7-在-Activity-里使用"><a href="#📌-7-在-Activity-里使用" class="headerlink" title="📌 7. 在 Activity 里使用"></a><strong>📌 7. 在 <code>Activity</code> 里使用</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var todoViewModel: TodoViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        // 获取数据库实例和 DAO</span><br><span class="line">        val database = TodoDatabase.getDatabase(this)</span><br><span class="line">        val repository = TodoRepository(database.todoDao())</span><br><span class="line"></span><br><span class="line">        // 创建 ViewModel</span><br><span class="line">        val factory = TodoViewModelFactory(repository)</span><br><span class="line">        todoViewModel = ViewModelProvider(this, factory).get(TodoViewModel::class.java)</span><br><span class="line"></span><br><span class="line">        // 监听 LiveData，更新 UI</span><br><span class="line">        todoViewModel.allTodos.observe(this) &#123; todos -&gt;</span><br><span class="line">            // 更新 RecyclerView 或 UI</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 添加任务</span><br><span class="line">        buttonAdd.setOnClickListener &#123;</span><br><span class="line">            val newTodo = Todo(task = &quot;New Task&quot;, isCompleted = false)</span><br><span class="line">            todoViewModel.insert(newTodo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getDatabase(this)</code> 获取数据库实例。</li><li><code>ViewModelProvider(this, factory)</code> 创建 <code>ViewModel</code>。</li><li><code>LiveData.observe()</code> 监听数据变化，<strong>UI 自动更新</strong>。</li></ul><hr><h1 id="📌-8-总结"><a href="#📌-8-总结" class="headerlink" title="📌 8. 总结"></a><strong>📌 8. 总结</strong></h1><p>✅ <strong>Room 负责存储数据</strong>，<code>DAO</code> 负责数据库操作。<br> ✅ <strong>ViewModel 负责持久化数据</strong>，避免因屏幕旋转导致数据丢失。<br> ✅ <strong>LiveData 让 UI 自动更新</strong>，不需要手动刷新数据。<br> ✅ <strong>Repository 作为数据中介</strong>，避免 <code>ViewModel</code> 直接操作 <code>Room</code>。</p><p>📌 <strong>最终效果</strong>：</p><ol><li><strong>数据库变更时，UI 自动更新</strong>（<code>LiveData</code>）。</li><li><strong>ViewModel 让数据在 Activity&#x2F;Fragment 生命周期内持久化</strong>。</li><li><strong>Repository 让数据管理更清晰</strong>，避免 <code>ViewModel</code> 直接访问数据库。</li></ol><p>💡 <strong>这样，我们的 <code>MVVM + Room</code> 架构更加清晰，可维护性更强！</strong> 🚀</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewModel用法</title>
      <link href="/2025/03/15/ViewModel%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/ViewModel%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>ViewModel</code> 是 Android 架构组件之一，<strong>用于管理 UI 相关的数据</strong>，并在 <strong>配置更改（如屏幕旋转）时保持数据不丢失</strong>。</p><hr><h2 id="🔹-1-添加-ViewModel-依赖"><a href="#🔹-1-添加-ViewModel-依赖" class="headerlink" title="🔹 1. 添加 ViewModel 依赖"></a><strong>🔹 1. 添加 ViewModel 依赖</strong></h2><p>在 <code>build.gradle.kts</code>（模块级）中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-2-创建-ViewModel"><a href="#🔹-2-创建-ViewModel" class="headerlink" title="🔹 2. 创建 ViewModel"></a><strong>🔹 2. 创建 ViewModel</strong></h2><h3 id="（1）基础-ViewModel"><a href="#（1）基础-ViewModel" class="headerlink" title="（1）基础 ViewModel"></a><strong>（1）基础 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line">class CounterViewModel : ViewModel() &#123;</span><br><span class="line">    var count = 0 // ViewModel 变量（Activity 重建后不会丢失）</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-3-在-Activity-Fragment-中使用"><a href="#🔹-3-在-Activity-Fragment-中使用" class="headerlink" title="🔹 3. 在 Activity&#x2F;Fragment 中使用"></a><strong>🔹 3. 在 Activity&#x2F;Fragment 中使用</strong></h2><h3 id="（1）Activity-获取-ViewModel"><a href="#（1）Activity-获取-ViewModel" class="headerlink" title="（1）Activity 获取 ViewModel"></a><strong>（1）Activity 获取 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import android.widget.TextView</span><br><span class="line">import androidx.activity.viewModels</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels() // 通过 viewModels() 获取 ViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        // 显示当前计数</span><br><span class="line">        textView.text = counterViewModel.count.toString()</span><br><span class="line"></span><br><span class="line">        // 点击按钮增加计数</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">            textView.text = counterViewModel.count.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>即使旋转屏幕，<code>count</code> 也不会重置</strong>。</p><hr><h2 id="🔹-4-ViewModel-LiveData-监听数据变化"><a href="#🔹-4-ViewModel-LiveData-监听数据变化" class="headerlink" title="🔹 4. ViewModel + LiveData 监听数据变化"></a><strong>🔹 4. ViewModel + LiveData 监听数据变化</strong></h2><p>使用 <code>LiveData</code>，<strong>UI 会自动更新</strong>：</p><h3 id="（1）ViewModel（使用-LiveData）"><a href="#（1）ViewModel（使用-LiveData）" class="headerlink" title="（1）ViewModel（使用 LiveData）"></a><strong>（1）ViewModel（使用 <code>LiveData</code>）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.LiveData</span><br><span class="line">import androidx.lifecycle.MutableLiveData</span><br><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line">class CounterViewModel : ViewModel() &#123;</span><br><span class="line">    private val _count = MutableLiveData(0) // 可变 LiveData</span><br><span class="line">    val count: LiveData&lt;Int&gt; = _count // 只暴露不可变 LiveData</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        _count.value = (_count.value ?: 0) + 1 // 更新数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）Activity-观察-LiveData"><a href="#（2）Activity-观察-LiveData" class="headerlink" title="（2）Activity 观察 LiveData"></a><strong>（2）Activity 观察 LiveData</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels()</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        // 观察 LiveData，自动更新 UI</span><br><span class="line">        counterViewModel.count.observe(this) &#123; newCount -&gt;</span><br><span class="line">            textView.text = newCount.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong><code>LiveData</code> 确保数据变化时，UI 会自动更新</strong>。</p><hr><h2 id="🔹-5-处理-ViewModel-依赖（带参数的-ViewModel）"><a href="#🔹-5-处理-ViewModel-依赖（带参数的-ViewModel）" class="headerlink" title="🔹 5. 处理 ViewModel 依赖（带参数的 ViewModel）"></a><strong>🔹 5. 处理 ViewModel 依赖（带参数的 ViewModel）</strong></h2><h3 id="（1）ViewModel-需要参数"><a href="#（1）ViewModel-需要参数" class="headerlink" title="（1）ViewModel 需要参数"></a><strong>（1）ViewModel 需要参数</strong></h3><p>如果 <code>ViewModel</code> 需要参数（如 <code>Repository</code>），需要创建 <code>ViewModelProvider.Factory</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class CounterViewModel(private val startValue: Int) : ViewModel() &#123;</span><br><span class="line">    private val _count = MutableLiveData(startValue)</span><br><span class="line">    val count: LiveData&lt;Int&gt; = _count</span><br><span class="line"></span><br><span class="line">    fun increment() &#123;</span><br><span class="line">        _count.value = (_count.value ?: 0) + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义 ViewModelFactory</span><br><span class="line">class CounterViewModelFactory(private val startValue: Int) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(CounterViewModel::class.java)) &#123;</span><br><span class="line">            @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">            return CounterViewModel(startValue) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）Activity-获取带参数的-ViewModel"><a href="#（2）Activity-获取带参数的-ViewModel" class="headerlink" title="（2）Activity 获取带参数的 ViewModel"></a><strong>（2）Activity 获取带参数的 ViewModel</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val counterViewModel: CounterViewModel by viewModels &#123;</span><br><span class="line">        CounterViewModelFactory(5) // 传入初始值 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val textView: TextView = findViewById(R.id.counterText)</span><br><span class="line">        val button: Button = findViewById(R.id.incrementButton)</span><br><span class="line"></span><br><span class="line">        counterViewModel.count.observe(this) &#123; newCount -&gt;</span><br><span class="line">            textView.text = newCount.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            counterViewModel.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>支持带参数的 ViewModel（如从数据库或网络获取初始数据）</strong>。</p><hr><h2 id="🔹-6-ViewModel-Room-持久化数据库数据"><a href="#🔹-6-ViewModel-Room-持久化数据库数据" class="headerlink" title="🔹 6. ViewModel + Room 持久化数据库数据"></a><strong>🔹 6. ViewModel + Room 持久化数据库数据</strong></h2><p>如果你使用 <code>Room</code> 存储数据，<code>ViewModel</code> 可以直接从 <code>Room</code> 获取 <code>LiveData</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface DiaryDao &#123;</span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">    fun getAllDiaries(): LiveData&lt;List&lt;DiaryEntry&gt;&gt; // LiveData 监听数据库</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val diaryList: LiveData&lt;List&lt;DiaryEntry&gt;&gt; = diaryDao.getAllDiaries()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Fragment</code> 观察数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diaryViewModel.diaryList.observe(viewLifecycleOwner) &#123; diaryList -&gt;</span><br><span class="line">    diaryAdapter.submitList(diaryList) // 更新 UI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>Room + ViewModel + LiveData 确保数据持久化，并自动更新 UI</strong>。</p><hr><h2 id="🔹-7-ViewModel-Kotlin-Flow（协程）"><a href="#🔹-7-ViewModel-Kotlin-Flow（协程）" class="headerlink" title="🔹 7. ViewModel + Kotlin Flow（协程）"></a><strong>🔹 7. ViewModel + Kotlin Flow（协程）</strong></h2><p>如果你用 <code>Flow</code>，可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val diaryListFlow = diaryDao.getAllDiariesFlow()</span><br><span class="line">        .stateIn(viewModelScope, SharingStarted.Lazily, emptyList()) // 转为 StateFlow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Fragment</code> 中 <code>collect</code> 数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    viewModel.diaryListFlow.collect &#123; diaryList -&gt;</span><br><span class="line">        diaryAdapter.submitList(diaryList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong><code>Flow</code> 更适合复杂数据流（如数据库、网络请求）</strong>。</p><hr><h2 id="🔹-8-ViewModel-生命周期"><a href="#🔹-8-ViewModel-生命周期" class="headerlink" title="🔹 8. ViewModel 生命周期"></a><strong>🔹 8. ViewModel 生命周期</strong></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>ViewModel 作用</strong></th></tr></thead><tbody><tr><td>旋转屏幕</td><td>保持数据不丢失</td></tr><tr><td>App 进后台</td><td>ViewModel 可能被销毁（可用 <code>SavedStateHandle</code> 处理）</td></tr><tr><td>Fragment 切换</td><td>共享 <code>ViewModel</code> 以保留数据</td></tr></tbody></table><hr><h2 id="🔹-总结"><a href="#🔹-总结" class="headerlink" title="🔹 总结"></a><strong>🔹 总结</strong></h2><p>✅ <code>ViewModel</code> <strong>用于管理 UI 相关数据，避免因屏幕旋转导致数据丢失</strong>。<br> ✅ 搭配 <code>LiveData</code> <strong>自动通知 UI 变化</strong>。<br> ✅ <code>ViewModel</code> + <code>Room</code> <strong>可以自动监听数据库变化</strong>。<br> ✅ <code>ViewModel</code> + <code>Flow</code> <strong>适合复杂数据流处理</strong>。<br> ✅ <code>ViewModelFactory</code> <strong>用于创建带参数的 ViewModel</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Room用法</title>
      <link href="/2025/03/15/Room%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/15/Room%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Room 是 Android 官方推荐的数据库框架，它是 SQLite 的抽象封装，提供了更便捷的数据库操作方式，支持 Kotlin 协程和 LiveData。以下是 Room 的基本使用方法：</p><hr><h2 id="1-添加-Room-依赖"><a href="#1-添加-Room-依赖" class="headerlink" title="1. 添加 Room 依赖"></a><strong>1. 添加 Room 依赖</strong></h2><p>在 <code>build.gradle.kts</code>（模块级）中添加 Room 相关依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    val room_version = &quot;2.6.1&quot; // 确保使用最新版本</span><br><span class="line"></span><br><span class="line">    implementation(&quot;androidx.room:room-runtime:$room_version&quot;)</span><br><span class="line">    kapt(&quot;androidx.room:room-compiler:$room_version&quot;) // 用于注解处理器</span><br><span class="line"></span><br><span class="line">    implementation(&quot;androidx.room:room-ktx:$room_version&quot;) // 支持 Kotlin 协程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果项目使用 Kotlin Symbol Processing (KSP) 代替 kapt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ksp(&quot;androidx.room:room-compiler:$room_version&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="2-创建数据库实体（Entity）"><a href="#2-创建数据库实体（Entity）" class="headerlink" title="2. 创建数据库实体（Entity）"></a><strong>2. 创建数据库实体（Entity）</strong></h2><p>使用 <code>@Entity</code> 注解定义数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.Entity</span><br><span class="line">import androidx.room.PrimaryKey</span><br><span class="line"></span><br><span class="line">@Entity(tableName = &quot;diary_entries&quot;) // 指定表名</span><br><span class="line">data class DiaryEntry(</span><br><span class="line">    @PrimaryKey(autoGenerate = true) val id: Int = 0, // 主键，自动生成</span><br><span class="line">    val title: String,</span><br><span class="line">    val content: String,</span><br><span class="line">    val date: Long, // 以时间戳形式存储日期</span><br><span class="line">    val weather: String? = null</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="3-创建-DAO（数据访问对象）"><a href="#3-创建-DAO（数据访问对象）" class="headerlink" title="3. 创建 DAO（数据访问对象）"></a><strong>3. 创建 DAO（数据访问对象）</strong></h2><p>DAO 负责数据库的 CRUD 操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import androidx.room.*</span><br><span class="line"></span><br><span class="line">@Dao</span><br><span class="line">interface DiaryDao &#123;</span><br><span class="line">    @Insert(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    suspend fun insertDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    suspend fun updateDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    suspend fun deleteDiary(entry: DiaryEntry)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">    fun getAllDiaries(): List&lt;DiaryEntry&gt; // 直接返回列表（不推荐，建议使用 Flow）</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries WHERE id = :id&quot;)</span><br><span class="line">    suspend fun getDiaryById(id: Int): DiaryEntry?</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM diary_entries WHERE title LIKE &#x27;%&#x27; || :query || &#x27;%&#x27;&quot;)</span><br><span class="line">    fun searchDiaries(query: String): List&lt;DiaryEntry&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要监听数据变化，可以用 <code>Flow</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;SELECT * FROM diary_entries ORDER BY date DESC&quot;)</span><br><span class="line">fun getAllDiariesFlow(): Flow&lt;List&lt;DiaryEntry&gt;&gt; // 使用 Flow 以支持实时监听</span><br></pre></td></tr></table></figure><hr><h2 id="4-创建数据库（Database）"><a href="#4-创建数据库（Database）" class="headerlink" title="4. 创建数据库（Database）"></a><strong>4. 创建数据库（Database）</strong></h2><p>使用 <code>@Database</code> 注解创建 Room 数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context</span><br><span class="line">import androidx.room.Database</span><br><span class="line">import androidx.room.Room</span><br><span class="line">import androidx.room.RoomDatabase</span><br><span class="line"></span><br><span class="line">@Database(entities = [DiaryEntry::class], version = 1, exportSchema = false)</span><br><span class="line">abstract class DiaryDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun diaryDao(): DiaryDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile</span><br><span class="line">        private var INSTANCE: DiaryDatabase? = null</span><br><span class="line"></span><br><span class="line">        fun getDatabase(context: Context): DiaryDatabase &#123;</span><br><span class="line">            return INSTANCE ?: synchronized(this) &#123;</span><br><span class="line">                val instance = Room.databaseBuilder(</span><br><span class="line">                    context.applicationContext,</span><br><span class="line">                    DiaryDatabase::class.java,</span><br><span class="line">                    &quot;diary_database&quot;</span><br><span class="line">                ).build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：</p><ul><li><code>@Volatile</code> 确保多个线程能正确访问 <code>INSTANCE</code>。</li><li><code>synchronized(this)</code> 确保数据库实例的单例模式。</li></ul></blockquote><hr><h2 id="5-在-ViewModel-中使用"><a href="#5-在-ViewModel-中使用" class="headerlink" title="5. 在 ViewModel 中使用"></a><strong>5. 在 ViewModel 中使用</strong></h2><p>在 <code>ViewModel</code> 里封装数据库操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import kotlinx.coroutines.flow.Flow</span><br><span class="line"></span><br><span class="line">class DiaryViewModel(private val diaryDao: DiaryDao) : ViewModel() &#123;</span><br><span class="line">    val allDiaries: Flow&lt;List&lt;DiaryEntry&gt;&gt; = diaryDao.getAllDiariesFlow()</span><br><span class="line"></span><br><span class="line">    suspend fun addDiary(entry: DiaryEntry) &#123;</span><br><span class="line">        diaryDao.insertDiary(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suspend fun deleteDiary(entry: DiaryEntry) &#123;</span><br><span class="line">        diaryDao.deleteDiary(entry)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>viewmodel</code> 目录下新建 <code>DiaryViewModelFactory.kt</code> 文件，并写入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import androidx.lifecycle.ViewModel</span><br><span class="line">import androidx.lifecycle.ViewModelProvider</span><br><span class="line">import com.example.uibestpractice.data.DiaryDao // 替换为你的包名</span><br><span class="line"></span><br><span class="line">class DiaryViewModelFactory(private val diaryDao: DiaryDao) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        if (modelClass.isAssignableFrom(DiaryViewModel::class.java)) &#123;</span><br><span class="line">            return DiaryViewModel(diaryDao) as T</span><br><span class="line">        &#125;</span><br><span class="line">        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-在-Activity-Fragment-中使用"><a href="#6-在-Activity-Fragment-中使用" class="headerlink" title="6. 在 Activity&#x2F;Fragment 中使用"></a><strong>6. 在 Activity&#x2F;Fragment 中使用</strong></h2><p>在 <code>Activity</code> 或 <code>Fragment</code> 里使用 ViewModel：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.activity.viewModels</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val diaryViewModel: DiaryViewModel by viewModels &#123;</span><br><span class="line">        DiaryViewModelFactory(DiaryDatabase.getDatabase(this).diaryDao())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        // 监听数据库变化</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            diaryViewModel.allDiaries.collect &#123; diaryList -&gt;</span><br><span class="line">                // 更新 UI</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun addDiaryEntry() &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            val newEntry = DiaryEntry(title = &quot;新日记&quot;, content = &quot;今天很开心！&quot;, date = System.currentTimeMillis())</span><br><span class="line">            diaryViewModel.addDiary(newEntry)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="7-线程调度（协程）"><a href="#7-线程调度（协程）" class="headerlink" title="7. 线程调度（协程）"></a><strong>7. 线程调度（协程）</strong></h2><p>Room 允许在 <code>suspend</code> 函数中调用数据库操作，Kotlin 协程会自动切换到 IO 线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun insertDiary(entry: DiaryEntry) &#123;</span><br><span class="line">    diaryDao.insertDiary(entry) // Room 在 IO 线程执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <strong>不支持协程的函数</strong>（如 <code>getAllDiaries()</code>），应使用 <code>withContext(Dispatchers.IO)</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun getAllDiariesBlocking(): List&lt;DiaryEntry&gt; &#123;</span><br><span class="line">    return runBlocking &#123; withContext(Dispatchers.IO) &#123; diaryDao.getAllDiaries() &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Room 提供了 <strong>简单、安全、高效</strong> 的数据库管理：</p><ol><li><strong>Entity</strong>（表） → <code>@Entity</code></li><li><strong>DAO</strong>（数据操作） → <code>@Dao</code></li><li><strong>Database</strong>（数据库实例） → <code>@Database</code></li><li><strong>ViewModel</strong>（封装业务逻辑）</li><li><strong>Activity&#x2F;Fragment</strong>（UI 层使用数据库）</li></ol><p>你可以结合 <code>Flow</code> 进行 <strong>实时监听</strong>，结合 <strong>Kotlin 协程</strong> 进行 <strong>异步处理</strong>，使数据库操作更加流畅高效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>startActivity和registerForActivityResult的用法</title>
      <link href="/2025/03/14/startActivity%E5%92%8CregisterForActivityResult%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/14/startActivity%E5%92%8CregisterForActivityResult%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 Android Kotlin 开发中，<code>startActivity</code> 和 <code>registerForActivityResult</code> 是启动新 Activity 并处理返回结果的两种方式。</p><hr><h2 id="1-使用-startActivity"><a href="#1-使用-startActivity" class="headerlink" title="1. 使用 startActivity"></a>1. 使用 <code>startActivity</code></h2><p><code>startActivity</code> 适用于 <strong>不需要获取返回值</strong> 的情况，例如从 <code>MainActivity</code> 跳转到 <code>SecondActivity</code>：</p><h3 id="示例：启动新-Activity"><a href="#示例：启动新-Activity" class="headerlink" title="示例：启动新 Activity"></a><strong>示例：启动新 Activity</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>如果你需要传递数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java).apply &#123;</span><br><span class="line">    putExtra(&quot;key&quot;, &quot;Hello, SecondActivity!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>在 <code>SecondActivity</code> 中获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val data = intent.getStringExtra(&quot;key&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="2-使用-registerForActivityResult"><a href="#2-使用-registerForActivityResult" class="headerlink" title="2. 使用 registerForActivityResult"></a>2. 使用 <code>registerForActivityResult</code></h2><p><code>registerForActivityResult</code> 适用于 <strong>需要从子 Activity 返回数据</strong> 的情况，比如用户选择了一个文件或拍照后返回图片。</p><h3 id="示例：启动-Activity-并获取返回值"><a href="#示例：启动-Activity-并获取返回值" class="headerlink" title="示例：启动 Activity 并获取返回值"></a><strong>示例：启动 Activity 并获取返回值</strong></h3><p>先在主 Activity 中注册一个 <code>ActivityResultLauncher</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private val launcher=registerForActivityResult(ActivityResultContracts.StartActivityForResult())&#123; result -&gt;</span><br><span class="line">    if (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        val data = result.data?.getStringExtra(&quot;result_key&quot;)</span><br><span class="line">        Toast.makeText(this, &quot;收到返回值: $data&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 <code>launcher.launch(intent)</code> 启动新 Activity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this, SecondActivity::class.java)</span><br><span class="line">launcher.launch(intent)</span><br></pre></td></tr></table></figure><h3 id="在-SecondActivity-处理返回数据"><a href="#在-SecondActivity-处理返回数据" class="headerlink" title="在 SecondActivity 处理返回数据"></a><strong>在 SecondActivity 处理返回数据</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val resultIntent = Intent().apply &#123;</span><br><span class="line">    putExtra(&quot;result_key&quot;, &quot;返回的数据&quot;)</span><br><span class="line">&#125;</span><br><span class="line">setResult(Activity.RESULT_OK, resultIntent)</span><br><span class="line">finish()</span><br></pre></td></tr></table></figure><hr><h2 id="3-startActivityForResult-已废弃"><a href="#3-startActivityForResult-已废弃" class="headerlink" title="3. startActivityForResult 已废弃"></a>3. <code>startActivityForResult</code> 已废弃</h2><p><code>startActivityForResult</code> 在 API 30（Android 11）开始被 <strong>弃用</strong>，官方推荐使用 <code>registerForActivityResult</code> 代替。</p><p>如果你的代码仍然使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">startActivityForResult(intent, REQUEST_CODE)</span><br></pre></td></tr></table></figure><p>则应改用 <code>registerForActivityResult</code>。</p><hr><h2 id="4-其他-ActivityResultContracts"><a href="#4-其他-ActivityResultContracts" class="headerlink" title="4. 其他 ActivityResultContracts"></a>4. 其他 <code>ActivityResultContracts</code></h2><p><code>registerForActivityResult</code> 还支持多种 <code>ActivityResultContracts</code>，如：</p><ul><li><code>ActivityResultContracts.RequestPermission()</code>（请求单个权限）</li><li><code>ActivityResultContracts.GetContent()</code>（选择文件）</li><li><code>ActivityResultContracts.TakePicture()</code>（拍照）</li></ul><h3 id="示例：获取图片"><a href="#示例：获取图片" class="headerlink" title="示例：获取图片"></a><strong>示例：获取图片</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private val getImage = registerForActivityResult(ActivityResultContracts.GetContent()) &#123; uri: Uri? -&gt;</span><br><span class="line">    uri?.let &#123;</span><br><span class="line">        imageView.setImageURI(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    getImage.launch(&quot;image/*&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>总结：</strong></p><ul><li><code>startActivity()</code> 适用于无返回值的跳转。</li><li><code>registerForActivityResult()</code> 适用于需要获取返回值的情况，并且比 <code>startActivityForResult()</code> 更推荐。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit用法示例</title>
      <link href="/2025/03/14/Retrofit%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/03/14/Retrofit%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<ol start="5"><li><ul><li><h1 id="Retrofit-使用指南"><a href="#Retrofit-使用指南" class="headerlink" title="Retrofit 使用指南"></a><strong>Retrofit 使用指南</strong></h1><p><code>Retrofit</code> 是 Android 上最常用的网络请求库之一，它简化了 HTTP 请求的处理，支持 <strong>GET、POST、PUT、DELETE</strong> 等请求方式，并且可以配合 <code>Gson</code>、<code>Moshi</code> 等解析 JSON 数据。</p><hr><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a><strong>1. 添加依赖</strong></h2><p>在 <code>build.gradle</code>（Module 级）中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span><br><span class="line">    implementation &#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27; // Gson 解析 JSON</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-创建-API-接口"><a href="#2-创建-API-接口" class="headerlink" title="2. 创建 API 接口"></a><strong>2. 创建 API 接口</strong></h2><p>定义 API 接口，例如获取用户信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import retrofit2.Call</span><br><span class="line">import retrofit2.http.GET</span><br><span class="line">import retrofit2.http.Path</span><br><span class="line"></span><br><span class="line">interface ApiService &#123;</span><br><span class="line">    @GET(&quot;users/&#123;id&#125;&quot;)  // 定义 GET 请求，&#123;id&#125; 是动态路径参数</span><br><span class="line">    fun getUser(@Path(&quot;id&quot;) userId: Int): Call&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-定义数据模型"><a href="#3-定义数据模型" class="headerlink" title="3. 定义数据模型"></a><strong>3. 定义数据模型</strong></h2><p>Retrofit 需要解析服务器返回的 JSON 数据，因此要创建一个 <code>data class</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class User(</span><br><span class="line">    val id: Int,</span><br><span class="line">    val name: String,</span><br><span class="line">    val email: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="4-创建-Retrofit-实例"><a href="#4-创建-Retrofit-实例" class="headerlink" title="4. 创建 Retrofit 实例"></a><strong>4. 创建 Retrofit 实例</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import retrofit2.Retrofit</span><br><span class="line">import retrofit2.converter.gson.GsonConverterFactory</span><br><span class="line"></span><br><span class="line">object RetrofitClient &#123;</span><br><span class="line">    private const val BASE_URL = &quot;https://api.example.com/&quot;</span><br><span class="line"></span><br><span class="line">    val instance: ApiService by lazy &#123;</span><br><span class="line">        Retrofit.Builder()</span><br><span class="line">            .baseUrl(BASE_URL)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create()) // 自动解析 JSON</span><br><span class="line">            .build()</span><br><span class="line">            .create(ApiService::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-发起网络请求"><a href="#5-发起网络请求" class="headerlink" title="5. 发起网络请求"></a><strong>5. 发起网络请求</strong></h2><h3 id="方式-1：传统的同步请求"><a href="#方式-1：传统的同步请求" class="headerlink" title="方式 1：传统的同步请求"></a><strong>方式 1：传统的同步请求</strong></h3><p>在传统的同步请求中，我们会创建一个 <code>Call</code> 对象并使用 <code>execute()</code> 或 <code>enqueue()</code> 方法发起请求。</p><h4 id="同步请求代码-不推荐-："><a href="#同步请求代码-不推荐-：" class="headerlink" title="同步请求代码(不推荐)："></a>同步请求代码(不推荐)：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取 ApiService 实例</span><br><span class="line">val call = RetrofitClient.instance.getUser(1)  // 创建 Call 对象</span><br><span class="line"></span><br><span class="line">// 发起同步请求</span><br><span class="line">val response = call.execute()  // 使用 execute() 进行同步请求</span><br><span class="line"></span><br><span class="line">if (response.isSuccessful) &#123;</span><br><span class="line">    val user = response.body()</span><br><span class="line">    println(&quot;用户信息：$&#123;user?.name&#125;, $&#123;user?.email&#125;&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;请求失败: $&#123;response.code()&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execute()</code> 方法会同步阻塞线程，直到请求完成。通常情况下，<em><strong>不建议</strong></em>在主线程中使用这种方式，因为它可能导致应用的卡顿。</p><h4 id="异步请求代码："><a href="#异步请求代码：" class="headerlink" title="异步请求代码："></a>异步请求代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 获取 ApiService 实例</span><br><span class="line">val call = RetrofitClient.instance.getUser(1)  // 创建 Call 对象</span><br><span class="line"></span><br><span class="line">// 使用 enqueue() 发起异步请求</span><br><span class="line">call.enqueue(object : retrofit2.Callback&lt;User&gt; &#123;</span><br><span class="line">    override fun onResponse(call: Call&lt;User&gt;, response: retrofit2.Response&lt;User&gt;) &#123;</span><br><span class="line">        if (response.isSuccessful) &#123;</span><br><span class="line">            val user = response.body()</span><br><span class="line">            println(&quot;用户信息：$&#123;user?.name&#125;, $&#123;user?.email&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onFailure(call: Call&lt;User&gt;, t: Throwable) &#123;</span><br><span class="line">        println(&quot;请求失败: $&#123;t.message&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <code>enqueue()</code> 中使用回调来处理响应，它不会阻塞主线程，适合在 UI 线程中使用。</p><hr><h3 id="方式-2：使用协程-suspend（推荐方式）"><a href="#方式-2：使用协程-suspend（推荐方式）" class="headerlink" title="方式 2：使用协程 + suspend（推荐方式）"></a><strong>方式 2：使用协程 + <code>suspend</code>（推荐方式）</strong></h3><p>Retrofit 也支持 Kotlin <strong>协程</strong>，这样可以避免 <code>enqueue()</code> 回调写法：</p><h4 id="修改-API-接口："><a href="#修改-API-接口：" class="headerlink" title="修改 API 接口："></a>修改 API 接口：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ApiService &#123;</span><br><span class="line">    @GET(&quot;users/&#123;id&#125;&quot;)</span><br><span class="line">    suspend fun getUser(@Path(&quot;id&quot;) userId: Int): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在-ViewModel-里使用-suspend-请求："><a href="#在-ViewModel-里使用-suspend-请求：" class="headerlink" title="在 ViewModel 里使用 suspend 请求："></a>在 ViewModel 里使用 <code>suspend</code> 请求：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.CoroutineScope</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line"></span><br><span class="line">fun fetchUserData() &#123;</span><br><span class="line">    CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            val user = RetrofitClient.instance.getUser(1)</span><br><span class="line">            println(&quot;用户信息: $&#123;user.name&#125;, $&#123;user.email&#125;&quot;)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            println(&quot;请求失败: $&#123;e.message&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>无回调地狱</strong>，代码更简洁。</li><li><strong>自动处理异步任务</strong>，适用于现代 Android 开发。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><p><strong>添加依赖</strong> (<code>Retrofit + Gson</code>)。</p></li><li><p><strong>创建 API 接口</strong> (<code>interface ApiService</code>)。</p></li><li><p><strong>定义数据模型</strong> (<code>data class User</code>)。</p></li><li><p><strong>创建 Retrofit 实例</strong> (<code>RetrofitClient</code>)。</p></li><li><p>发起请求</p><p>：</p><ul><li><strong>方式 1</strong>：使用 <code>Call</code> 对象 + <code>execute()</code> 或 <code>enqueue()</code>（传统方式）。</li><li><strong>方式 2</strong>：使用 <code>suspend</code> 函数 + 协程（推荐现代写法）。</li></ul></li></ol></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓知识类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD命令大全</title>
      <link href="/2025/03/13/CMD%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2025/03/13/CMD%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CMD-命令大全：从入门到精通"><a href="#CMD-命令大全：从入门到精通" class="headerlink" title="CMD 命令大全：从入门到精通"></a>CMD 命令大全：从入门到精通</h1><p>命令提示符（CMD）是 Windows 操作系统中的命令行界面，允许用户通过输入命令来执行各种任务。它是一个强大的工具，适用于系统管理、网络配置、文件操作等多种场景。本文详细介绍了常用的 CMD 命令，帮助你从入门到精通 CMD。<strong>不过也可以直接打help寻找命令的。</strong></p><p>[参考来源](<a href="https://blog.csdn.net/m0_70474954/article/details/143496800">CMD 命令大全：从入门到精通_cmd命令-CSDN博客</a>)</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#cmd-%E5%9F%BA%E7%A1%80">CMD 基础</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">文件和目录操作命令</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4">系统信息获取命令</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4">网络配置命令</a></li><li><a href="#%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">磁盘和文件系统操作命令</a></li><li><a href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6">批处理文件</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li><li><a href="#cmd-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7">CMD 高级技巧</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">常见问题与解决方案</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ol><hr><h2 id="CMD-基础"><a href="#CMD-基础" class="headerlink" title="CMD 基础"></a>CMD 基础</h2><h3 id="1-1-打开-CMD"><a href="#1-1-打开-CMD" class="headerlink" title="1.1 打开 CMD"></a>1.1 打开 CMD</h3><p>在 Windows 中，可通过以下方式打开命令提示符：</p><ul><li>按 <code>Win + R</code>，输入 <code>cmd</code>，然后按 <code>Enter</code>。</li><li>在开始菜单中搜索 “cmd” 或 “命令提示符”。</li></ul><h3 id="1-2-常用命令格式"><a href="#1-2-常用命令格式" class="headerlink" title="1.2 常用命令格式"></a>1.2 常用命令格式</h3><p>CMD 命令通常遵循以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 [参数]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /w</span><br></pre></td></tr></table></figure><p>其中 <code>dir</code> 是命令，<code>/w</code> 是参数。</p><hr><h2 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h2><h3 id="2-1-查看当前目录"><a href="#2-1-查看当前目录" class="headerlink" title="2.1 查看当前目录"></a>2.1 查看当前目录</h3><p>使用 <code>cd</code> 命令显示当前工作目录的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure><h3 id="2-2-列出目录中的文件"><a href="#2-2-列出目录中的文件" class="headerlink" title="2.2 列出目录中的文件"></a>2.2 列出目录中的文件</h3><p>使用 <code>dir</code> 命令列出当前目录中的所有文件和子目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><h3 id="2-3-进入目录"><a href="#2-3-进入目录" class="headerlink" title="2.3 进入目录"></a>2.3 进入目录</h3><p>使用 <code>cd [目录路径]</code> 进入指定目录。例如，进入 <code>D:\Documents</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd D:\Documents</span><br></pre></td></tr></table></figure><h3 id="2-4-返回上一级目录"><a href="#2-4-返回上一级目录" class="headerlink" title="2.4 返回上一级目录"></a>2.4 返回上一级目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><h3 id="2-5-创建新目录"><a href="#2-5-创建新目录" class="headerlink" title="2.5 创建新目录"></a>2.5 创建新目录</h3><p>使用 <code>mkdir [目录名]</code> 创建新目录。例如，创建一个名为 <code>NewFolder</code> 的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir NewFolder</span><br></pre></td></tr></table></figure><h3 id="2-6-删除目录"><a href="#2-6-删除目录" class="headerlink" title="2.6 删除目录"></a>2.6 删除目录</h3><p>使用 <code>rmdir [目录名]</code> 删除空目录。如果要删除非空目录，请使用 <code>/s</code> 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /s [目录名]</span><br></pre></td></tr></table></figure><h3 id="2-7-复制文件"><a href="#2-7-复制文件" class="headerlink" title="2.7 复制文件"></a>2.7 复制文件</h3><p>使用 <code>copy [源文件路径] [目标路径]</code> 复制文件。例如，将 <code>file.txt</code> 复制到 <code>D:\Backup</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy file.txt D:\Backup</span><br></pre></td></tr></table></figure><h3 id="2-8-移动文件"><a href="#2-8-移动文件" class="headerlink" title="2.8 移动文件"></a>2.8 移动文件</h3><p>使用 <code>move [源文件路径] [目标路径]</code> 移动文件。例如，将 <code>file.txt</code> 移动到 <code>D:\Documents</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move file.txt D:\Documents</span><br></pre></td></tr></table></figure><h3 id="2-9-删除文件"><a href="#2-9-删除文件" class="headerlink" title="2.9 删除文件"></a>2.9 删除文件</h3><p>使用 <code>del [文件名]</code> 删除文件。例如，删除 <code>file.txt</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del file.txt</span><br></pre></td></tr></table></figure><h3 id="2-10-重命名文件"><a href="#2-10-重命名文件" class="headerlink" title="2.10 重命名文件"></a>2.10 重命名文件</h3><p>使用 <code>ren [旧文件名] [新文件名]</code> 重命名文件。例如，将 <code>oldfile.txt</code> 重命名为 <code>newfile.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren oldfile.txt newfile.txt</span><br></pre></td></tr></table></figure><hr><h2 id="系统信息获取命令"><a href="#系统信息获取命令" class="headerlink" title="系统信息获取命令"></a>系统信息获取命令</h2><h3 id="3-1-查看系统信息"><a href="#3-1-查看系统信息" class="headerlink" title="3.1 查看系统信息"></a>3.1 查看系统信息</h3><p>使用 <code>systeminfo</code> 显示计算机的详细信息（操作系统版本、内存、网络适配器等）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><h3 id="3-2-查看当前用户"><a href="#3-2-查看当前用户" class="headerlink" title="3.2 查看当前用户"></a>3.2 查看当前用户</h3><p>使用 <code>whoami</code> 显示当前登录的用户名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><h3 id="3-3-查看计算机名"><a href="#3-3-查看计算机名" class="headerlink" title="3.3 查看计算机名"></a>3.3 查看计算机名</h3><p>使用 <code>hostname</code> 显示计算机的主机名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure><h3 id="3-4-查看进程列表"><a href="#3-4-查看进程列表" class="headerlink" title="3.4 查看进程列表"></a>3.4 查看进程列表</h3><p>使用 <code>tasklist</code> 列出当前运行的所有进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><h3 id="3-5-结束进程"><a href="#3-5-结束进程" class="headerlink" title="3.5 结束进程"></a>3.5 结束进程</h3><p>使用 <code>taskkill /IM [进程名] /F</code> 强制结束指定进程。例如，结束 <code>notepad.exe</code> 进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /IM notepad.exe /F</span><br></pre></td></tr></table></figure><hr><h2 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h2><h3 id="4-1-查看-IP-配置"><a href="#4-1-查看-IP-配置" class="headerlink" title="4.1 查看 IP 配置"></a>4.1 查看 IP 配置</h3><p>使用 <code>ipconfig</code> 显示计算机的 IP 地址、子网掩码和默认网关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><h3 id="4-2-刷新-IP-地址"><a href="#4-2-刷新-IP-地址" class="headerlink" title="4.2 刷新 IP 地址"></a>4.2 刷新 IP 地址</h3><p>使用以下命令释放并更新 DHCP 分配的 IP 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /release</span><br><span class="line">ipconfig /renew</span><br></pre></td></tr></table></figure><h3 id="4-3-查看网络连接"><a href="#4-3-查看网络连接" class="headerlink" title="4.3 查看网络连接"></a>4.3 查看网络连接</h3><p>使用 <code>netstat</code> 显示当前所有网络连接和监听端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br></pre></td></tr></table></figure><h3 id="4-4-测试网络连接"><a href="#4-4-测试网络连接" class="headerlink" title="4.4 测试网络连接"></a>4.4 测试网络连接</h3><p>使用 <code>ping [IP 地址或域名]</code> 测试网络连接。例如，测试与 Google 的连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.google.com</span><br></pre></td></tr></table></figure><h3 id="4-5-追踪路由"><a href="#4-5-追踪路由" class="headerlink" title="4.5 追踪路由"></a>4.5 追踪路由</h3><p>使用 <code>tracert [IP 地址或域名]</code> 追踪网络路由。例如，追踪到 Google 的路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert www.google.com</span><br></pre></td></tr></table></figure><hr><h2 id="磁盘和文件系统操作命令"><a href="#磁盘和文件系统操作命令" class="headerlink" title="磁盘和文件系统操作命令"></a>磁盘和文件系统操作命令</h2><h3 id="5-1-查看磁盘使用情况"><a href="#5-1-查看磁盘使用情况" class="headerlink" title="5.1 查看磁盘使用情况"></a>5.1 查看磁盘使用情况</h3><p>使用以下命令显示每个逻辑磁盘的总大小和可用空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic logicaldisk get size,freespace,caption</span><br></pre></td></tr></table></figure><h3 id="5-2-格式化磁盘"><a href="#5-2-格式化磁盘" class="headerlink" title="5.2 格式化磁盘"></a>5.2 格式化磁盘</h3><p>使用 <code>format [驱动器:] /FS:[文件系统]</code> 格式化磁盘。例如，将 D 盘格式化为 NTFS 文件系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format D: /FS:NTFS</span><br></pre></td></tr></table></figure><h3 id="5-3-检查磁盘错误"><a href="#5-3-检查磁盘错误" class="headerlink" title="5.3 检查磁盘错误"></a>5.3 检查磁盘错误</h3><p>使用 <code>chkdsk [驱动器:]</code> 检查磁盘错误。例如，检查 C 盘错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkdsk C:</span><br></pre></td></tr></table></figure><h3 id="5-4-显示磁盘分区信息"><a href="#5-4-显示磁盘分区信息" class="headerlink" title="5.4 显示磁盘分区信息"></a>5.4 显示磁盘分区信息</h3><p>使用 <code>diskpart</code> 进入 DiskPart 工具，然后在提示符下输入 <code>list disk</code> 查看所有磁盘信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskpart</span><br></pre></td></tr></table></figure><hr><h2 id="批处理文件"><a href="#批处理文件" class="headerlink" title="批处理文件"></a>批处理文件</h2><p>批处理文件是包含多个 CMD 命令的文本文件，便于一次性执行一系列命令。</p><h3 id="6-1-创建批处理文件"><a href="#6-1-创建批处理文件" class="headerlink" title="6.1 创建批处理文件"></a>6.1 创建批处理文件</h3><p>使用文本编辑器（如 Notepad）创建一个 <code>.bat</code> 文件，并输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo Hello, World!</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="6-2-运行批处理文件"><a href="#6-2-运行批处理文件" class="headerlink" title="6.2 运行批处理文件"></a>6.2 运行批处理文件</h3><p>双击 <code>.bat</code> 文件，或在 CMD 中输入文件路径来运行该文件。</p><hr><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="7-1-查看环境变量"><a href="#7-1-查看环境变量" class="headerlink" title="7.1 查看环境变量"></a>7.1 查看环境变量</h3><p>使用 <code>set</code> 命令显示所有环境变量及其值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure><h3 id="7-2-设置环境变量"><a href="#7-2-设置环境变量" class="headerlink" title="7.2 设置环境变量"></a>7.2 设置环境变量</h3><p>使用 <code>set [变量名]=[值]</code> 设置环境变量。例如，设置名为 <code>MY_VAR</code> 的环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MY_VAR=Hello</span><br></pre></td></tr></table></figure><h3 id="7-3-删除环境变量"><a href="#7-3-删除环境变量" class="headerlink" title="7.3 删除环境变量"></a>7.3 删除环境变量</h3><p>将环境变量值设为空即可删除。例如，删除 <code>MY_VAR</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MY_VAR=</span><br></pre></td></tr></table></figure><hr><h2 id="CMD-高级技巧"><a href="#CMD-高级技巧" class="headerlink" title="CMD 高级技巧"></a>CMD 高级技巧</h2><h3 id="8-1-使用管道"><a href="#8-1-使用管道" class="headerlink" title="8.1 使用管道"></a>8.1 使用管道</h3><p>管道符号 <code>|</code> 可将一个命令的输出传递给另一个命令。例如，查找进程列表中包含 “chrome” 的进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | find &quot;chrome&quot;</span><br></pre></td></tr></table></figure><h3 id="8-2-使用重定向"><a href="#8-2-使用重定向" class="headerlink" title="8.2 使用重定向"></a>8.2 使用重定向</h3><p>重定向符 <code>&gt;</code> 可将命令的输出保存到文件中。例如，将 <code>dir</code> 命令的输出保存到 <code>output.txt</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir &gt; output.txt</span><br></pre></td></tr></table></figure><h3 id="8-3-批量重命名文件"><a href="#8-3-批量重命名文件" class="headerlink" title="8.3 批量重命名文件"></a>8.3 批量重命名文件</h3><p>使用 <code>for</code> 循环批量重命名文件。例如，将当前目录下的所有 <code>.txt</code> 文件重命名为 <code>.bak</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for %f in (*.txt) do ren &quot;%f&quot; &quot;*.bak&quot;</span><br></pre></td></tr></table></figure><p><em>注：在批处理文件中使用 for 循环时，需将 <code>%f</code> 替换为 <code>%%f</code>。</em></p><hr><h2 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h2><h3 id="9-1-CMD-无法识别命令"><a href="#9-1-CMD-无法识别命令" class="headerlink" title="9.1 CMD 无法识别命令"></a>9.1 CMD 无法识别命令</h3><ul><li>如果 CMD 提示 “不是内部或外部命令”，可能是因为命令输入错误或相应程序未安装。</li></ul><h3 id="9-2-权限不足"><a href="#9-2-权限不足" class="headerlink" title="9.2 权限不足"></a>9.2 权限不足</h3><ul><li>某些命令需要管理员权限。请右键点击 CMD 图标，选择“以管理员身份运行”。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了 CMD 的基本命令、文件和目录操作、系统信息获取、网络配置等内容。通过具体示例和操作说明，帮助你更好地理解和掌握 CMD 的使用。希望这份 CMD 命令大全能帮助你提高工作效率，成为 CMD 使用的高手！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task3 Android Diary</title>
      <link href="/2025/03/05/Task3-Diary/"/>
      <url>/2025/03/05/Task3-Diary/</url>
      
        <content type="html"><![CDATA[<h1 id="MY-API-KEY-和风"><a href="#MY-API-KEY-和风" class="headerlink" title="MY API KEY(和风)"></a>MY API KEY(和风)</h1><p>670ca929136a456992608cd2e794df24</p><h1 id="Mainactivity"><a href="#Mainactivity" class="headerlink" title="Mainactivity"></a>Mainactivity</h1><h2 id="超级好的Mainactivity"><a href="#超级好的Mainactivity" class="headerlink" title="超级好的Mainactivity"></a>超级好的Mainactivity</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line"></span><br><span class="line">import androidx.core.widget.addTextChangedListener</span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.BroadcastReceiver</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.IntentFilter</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line">import androidx.appcompat.app.AlertDialog</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.Observer</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import com.example.diary_3.adapter.DiaryAdapter</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityMainBinding</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var binding: ActivityMainBinding</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line">    private val addDiaryLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">        when (result.resultCode) &#123;</span><br><span class="line">            Activity.RESULT_OK -&gt; loadAllDiaries()</span><br><span class="line">            Activity.RESULT_CANCELED -&gt; &#123;&#125;</span><br><span class="line">            else -&gt; Log.d(&quot;MainActivity&quot;, &quot;未知的返回结果: $&#123;result.resultCode&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private val diarySavedReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            if (intent?.action == &quot;SAVED&quot;) &#123;</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        binding.recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line">        diaryAdapter = DiaryAdapter(this, emptyList())</span><br><span class="line">        binding.recyclerView.adapter = diaryAdapter</span><br><span class="line"></span><br><span class="line">        val filter = IntentFilter(&quot;SAVED&quot;)</span><br><span class="line">        registerReceiver(diarySavedReceiver, filter)</span><br><span class="line"></span><br><span class="line">        loadAllDiaries()</span><br><span class="line"></span><br><span class="line">        // 监听搜索框</span><br><span class="line">        binding.searchBox.addTextChangedListener &#123; text -&gt;</span><br><span class="line">            searchDiaries(text.toString())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 启动添加日记页面</span><br><span class="line">        binding.addDiaryButton.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this, AddDiaryActivity::class.java)</span><br><span class="line">            addDiaryLauncher.launch(intent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 绑定删除按钮</span><br><span class="line">        binding.deleteDiaryButton.setOnClickListener &#123;</span><br><span class="line">            deleteDiary()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除日记的方法</span><br><span class="line">    private fun deleteDiary() &#123;</span><br><span class="line">        val diaries = diaryAdapter.getCurrentDiaries()</span><br><span class="line">        if (diaries.isEmpty()) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;当前没有日记可删除&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val diaryTitles = diaries.map &#123; it.title &#125;.toTypedArray()</span><br><span class="line">        var selectedIndex = 0</span><br><span class="line"></span><br><span class="line">        AlertDialog.Builder(this)</span><br><span class="line">            .setTitle(&quot;选择要删除的日记&quot;)</span><br><span class="line">            .setSingleChoiceItems(diaryTitles, 0) &#123; _, which -&gt;</span><br><span class="line">                selectedIndex = which</span><br><span class="line">            &#125;</span><br><span class="line">            .setPositiveButton(&quot;删除&quot;) &#123; _, _ -&gt;</span><br><span class="line">                val diaryToDelete = diaries[selectedIndex]</span><br><span class="line">                lifecycleScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">                    diaryDatabase.diaryDao().deleteDiary(diaryToDelete)</span><br><span class="line">                    withContext(Dispatchers.Main) &#123;</span><br><span class="line">                        loadAllDiaries()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .setNegativeButton(&quot;取消&quot;, null)</span><br><span class="line">            .show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加载所有日记</span><br><span class="line">    private fun loadAllDiaries() &#123;</span><br><span class="line">        diaryDatabase.diaryDao().getDiaries().observe(this, Observer &#123; diaries -&gt;</span><br><span class="line">            diaryAdapter.updateData(diaries) // 更新数据</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 搜索日记</span><br><span class="line">    private fun searchDiaries(query: String) &#123;</span><br><span class="line">        diaryDatabase.diaryDao().searchDiaries(&quot;%$query%&quot;)</span><br><span class="line">            .observe(this, Observer &#123; diaries -&gt;</span><br><span class="line">                diaryAdapter.updateData(diaries)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        unregisterReceiver(diarySavedReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line">import androidx.core.widget.addTextChangedListener</span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.BroadcastReceiver</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.IntentFilter</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.text.Editable</span><br><span class="line">import android.text.TextWatcher</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line">import androidx.annotation.RequiresApi</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.lifecycle.lifecycleScope</span><br><span class="line">import androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line">import androidx.room.InvalidationTracker</span><br><span class="line">import com.example.diary_3.adapter.DiaryAdapter</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityMainBinding</span><br><span class="line">import java.util.concurrent.Executors</span><br><span class="line">import kotlinx.coroutines.CoroutineScope</span><br><span class="line">import kotlinx.coroutines.Dispatchers</span><br><span class="line">import kotlinx.coroutines.launch</span><br><span class="line">import kotlinx.coroutines.withContext</span><br><span class="line">import androidx.lifecycle.Observer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var binding: ActivityMainBinding</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var diaryAdapter: DiaryAdapter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private val addDiaryLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">        when (result.resultCode) &#123;</span><br><span class="line">            Activity.RESULT_OK -&gt; &#123;</span><br><span class="line">                // 如果有返回结果，刷新数据</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">            Activity.RESULT_CANCELED -&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; &#123;</span><br><span class="line">                // 处理其他可能的返回情况</span><br><span class="line">                Log.d(&quot;MainActivity&quot;, &quot;未知的返回结果: $&#123;result.resultCode&#125;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private val diarySavedReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            if (intent?.action == &quot;SAVED&quot;) &#123;</span><br><span class="line">                loadAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//gl gd</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        binding.recyclerView.layoutManager = LinearLayoutManager(this)</span><br><span class="line">        diaryAdapter = DiaryAdapter(this, emptyList())</span><br><span class="line">        binding.recyclerView.adapter = diaryAdapter</span><br><span class="line">        val filter = IntentFilter(&quot;SAVED&quot;)</span><br><span class="line">        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) &#123;</span><br><span class="line">            registerReceiver(diarySavedReceiver, filter, Context.RECEIVER_NOT_EXPORTED)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            registerReceiver(diarySavedReceiver, filter, RECEIVER_NOT_EXPORTED)</span><br><span class="line">        &#125;//ys5 gd</span><br><span class="line">        loadAllDiaries()</span><br><span class="line">        binding.searchBox.addTextChangedListener &#123; text -&gt;</span><br><span class="line">            searchDiaries(text.toString())</span><br><span class="line">        &#125;//ys3 gd</span><br><span class="line">        // 使用 ActivityResultLauncher 启动 AddDiaryActivity</span><br><span class="line">        binding.addDiaryButton.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this, AddDiaryActivity::class.java)</span><br><span class="line">            addDiaryLauncher.launch(intent)</span><br><span class="line">        &#125;//ys4 gd</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun loadAllDiaries() &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            val diaries = withContext(Dispatchers.IO) &#123;</span><br><span class="line">                diaryDatabase.diaryDao().getAllDiaries()</span><br><span class="line">            &#125;</span><br><span class="line">            diaryAdapter.updateData(diaries) // 更新数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//ys8 gd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun searchDiaries(query: String) &#123;</span><br><span class="line">        diaryDatabase.diaryDao().searchDiaries(&quot;%$query%&quot;)</span><br><span class="line">            .observe(this, object : Observer&lt;List&lt;Diary&gt;&gt; &#123;</span><br><span class="line">                override fun onChanged(diaries: List&lt;Diary&gt;) &#123;</span><br><span class="line">                    diaryAdapter = DiaryAdapter(this@MainActivity, diaries)</span><br><span class="line">                    binding.recyclerView.adapter = diaryAdapter</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;//ys9 gd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        unregisterReceiver(diarySavedReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="AddDiaryActivity"><a href="#AddDiaryActivity" class="headerlink" title="AddDiaryActivity"></a>AddDiaryActivity</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_3.activity</span><br><span class="line">import androidx.appcompat.app.AlertDialog</span><br><span class="line">import android.view.View</span><br><span class="line">import android.widget.EditText</span><br><span class="line">import com.example.diary_3.utils.DateUtils</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.content.pm.PackageManager</span><br><span class="line">import android.net.Uri</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.os.Looper</span><br><span class="line">import android.provider.MediaStore</span><br><span class="line">import android.util.Log</span><br><span class="line">import android.widget.Toast</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity</span><br><span class="line">import androidx.core.app.ActivityCompat</span><br><span class="line">import androidx.core.content.ContextCompat</span><br><span class="line">import com.bumptech.glide.Glide</span><br><span class="line">import com.bumptech.glide.request.RequestOptions</span><br><span class="line">import com.example.diary_3.R</span><br><span class="line">import com.example.diary_3.database.Diary</span><br><span class="line">import com.example.diary_3.database.DiaryDatabase</span><br><span class="line">import com.example.diary_3.databinding.ActivityAddDiaryBinding</span><br><span class="line">import com.example.diary_3.model.CityResponse</span><br><span class="line">import com.example.diary_3.model.WeatherResponse</span><br><span class="line">import com.example.diary_3.network.RetrofitClient</span><br><span class="line">import com.example.diary_3.network.WeatherApi</span><br><span class="line">import com.example.diary_3.utils.LocationUtils</span><br><span class="line">import retrofit2.Call</span><br><span class="line">import retrofit2.Callback</span><br><span class="line">import retrofit2.Response</span><br><span class="line">import java.util.Calendar</span><br><span class="line">import java.util.concurrent.Executors</span><br><span class="line"></span><br><span class="line">class AddDiaryActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val selectedLocalImageUris = mutableListOf&lt;Uri&gt;()</span><br><span class="line">    private val networkImageUrls = mutableListOf&lt;String&gt;()</span><br><span class="line">    private val API_KEY = &quot;670ca929136a456992608cd2e794df24&quot;</span><br><span class="line">    private lateinit var binding: ActivityAddDiaryBinding</span><br><span class="line">    private var selectedDate: Calendar = Calendar.getInstance()</span><br><span class="line">    private lateinit var diaryDatabase: DiaryDatabase</span><br><span class="line">    private lateinit var locationUtils: LocationUtils</span><br><span class="line">    private val PERMISSION_REQUEST_CODE = 1</span><br><span class="line">    private var selectedLocalImageUri: Uri? = null</span><br><span class="line">    private var networkImageUrl: String? = null</span><br><span class="line"></span><br><span class="line">    private fun hasPermission(permission: String): Boolean &#123;</span><br><span class="line">        return ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityAddDiaryBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        diaryDatabase = DiaryDatabase.getInstance(this)</span><br><span class="line">        locationUtils = LocationUtils(this)</span><br><span class="line"></span><br><span class="line">        binding.selectImageButton.setOnClickListener &#123;</span><br><span class="line">            pickLocalImage()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binding.addNetworkImageButton.setOnClickListener &#123;</span><br><span class="line">            // 创建一个输入框</span><br><span class="line">            val input = EditText(this)</span><br><span class="line">            input.hint = &quot;请输入有效的图片链接&quot;</span><br><span class="line"></span><br><span class="line">            // 构建对话框</span><br><span class="line">            AlertDialog.Builder(this)</span><br><span class="line">                .setTitle(&quot;输入图片URL&quot;)</span><br><span class="line">                .setView(input)</span><br><span class="line">                .setPositiveButton(&quot;确定&quot;) &#123; dialog, which -&gt;</span><br><span class="line">                    val url = input.text.toString().trim()</span><br><span class="line">                    if (url.isNotBlank()) &#123;</span><br><span class="line">                        networkImageUrl = url</span><br><span class="line">                        Glide.with(this)</span><br><span class="line">                            .load(url)</span><br><span class="line">                            .placeholder(R.drawable.loading_placeholder) // 加载过程中的占位符图片</span><br><span class="line">                            .apply(RequestOptions.circleCropTransform())</span><br><span class="line">                            .error(R.drawable.no) // 加载失败时显示的图片</span><br><span class="line">                            .into(binding.selectedImageView)</span><br><span class="line">                        binding.selectedImageView.visibility = View.VISIBLE</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Toast.makeText(this, &quot;请输入有效的图片链接&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                        binding.selectedImageView.visibility = View.GONE</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .setNegativeButton(&quot;取消&quot;) &#123; dialog, which -&gt;</span><br><span class="line">                    dialog.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">                .show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binding.saveDiaryButton.setOnClickListener &#123;</span><br><span class="line">            saveDiary()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 新增按钮：点击刷新地点和天气</span><br><span class="line">        binding.refreshWeatherLocationButton.setOnClickListener &#123;</span><br><span class="line">            getLocation()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val permissionsToRequest = mutableListOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        if (!hasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION)) &#123;</span><br><span class="line">            permissionsToRequest.add(android.Manifest.permission.ACCESS_FINE_LOCATION)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!hasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">            permissionsToRequest.add(android.Manifest.permission.READ_EXTERNAL_STORAGE)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (permissionsToRequest.isNotEmpty()) &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(</span><br><span class="line">                this,</span><br><span class="line">                permissionsToRequest.toTypedArray(),</span><br><span class="line">                PERMISSION_REQUEST_CODE</span><br><span class="line">            )</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            getLocation()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun pickLocalImage() &#123;</span><br><span class="line">        val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)</span><br><span class="line">        startActivityForResult(intent, 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123;</span><br><span class="line">        super.onActivityResult(requestCode, resultCode, data)</span><br><span class="line"></span><br><span class="line">        if (requestCode == 1 &amp;&amp; resultCode == RESULT_OK &amp;&amp; data != null) &#123;</span><br><span class="line">            selectedLocalImageUri = data.data</span><br><span class="line">            Glide.with(this)</span><br><span class="line">                .load(selectedLocalImageUri)</span><br><span class="line">                .into(binding.selectedImageView)</span><br><span class="line">            binding.selectedImageView.visibility = android.view.View.VISIBLE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getLocation() &#123;</span><br><span class="line">        locationUtils.getLocation &#123; location -&gt;</span><br><span class="line">            if (location != null) &#123;</span><br><span class="line">                val latitude = location.latitude</span><br><span class="line">                val longitude = location.longitude</span><br><span class="line">                Log.d(&quot;AddDiaryActivity&quot;, &quot;获取到的经纬度: 纬度 $latitude, 经度 $longitude&quot;)</span><br><span class="line">                // 格式化经纬度字符串，注意这里 longitude 和 latitude 的顺序可以根据接口要求调整</span><br><span class="line">                val loc = String.format(&quot;%.2f,%.2f&quot;, location.longitude, location.latitude)</span><br><span class="line">                Executors.newSingleThreadExecutor().execute &#123;</span><br><span class="line">                    runOnUiThread &#123;</span><br><span class="line">                        binding.locationTextView.text = loc</span><br><span class="line">                        getCityId(loc)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                runOnUiThread &#123;</span><br><span class="line">                    Toast.makeText(this, &quot;无法获取当前位置&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun showToastOnUiThread(message: String) &#123;</span><br><span class="line">        if (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                Toast.makeText(this, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getCityId(cityName: String) &#123;</span><br><span class="line">        val weatherApi = RetrofitClient.geoInstance.create(WeatherApi::class.java)</span><br><span class="line">        weatherApi.getCityInfo(API_KEY, cityName).enqueue(object : Callback&lt;CityResponse&gt; &#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;CityResponse&gt;, response: Response&lt;CityResponse&gt;) &#123;</span><br><span class="line">                if (response.isSuccessful &amp;&amp; response.body()?.code == &quot;200&quot;) &#123;</span><br><span class="line">                    val cityLocation = response.body()?.location?.firstOrNull()</span><br><span class="line">                    if (cityLocation != null) &#123;</span><br><span class="line">                        binding.locationTextView.text = cityLocation.name</span><br><span class="line">                        getWeatherInfo(cityLocation.id)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.e(&quot;AddDiaryActivity&quot;, &quot;获取城市 ID 失败: $&#123;response.message()&#125;, 响应代码: $&#123;response.code()&#125;, 响应体: $&#123;response.errorBody()?.string()&#125;&quot;)</span><br><span class="line">                    showToastOnUiThread(&quot;获取城市 ID 失败&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;CityResponse&gt;, t: Throwable) &#123;</span><br><span class="line">                Log.e(&quot;AddDiaryActivity&quot;, &quot;获取城市 ID 网络请求失败: $&#123;t.message&#125;&quot;, t)</span><br><span class="line">                showToastOnUiThread(&quot;获取城市 ID 网络请求失败&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun getWeatherInfo(cityId: String) &#123;</span><br><span class="line">        val weatherApi = RetrofitClient.weatherInstance.create(WeatherApi::class.java)</span><br><span class="line">        weatherApi.getWeatherInfo(API_KEY, cityId).enqueue(object : Callback&lt;WeatherResponse&gt; &#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;WeatherResponse&gt;, response: Response&lt;WeatherResponse&gt;) &#123;</span><br><span class="line">                if (response.isSuccessful &amp;&amp; response.body()?.code == &quot;200&quot;) &#123;</span><br><span class="line">                    val today = DateUtils.formatDate(Calendar.getInstance().time)</span><br><span class="line">                    val todayWeather = response.body()?.daily?.firstOrNull &#123; it.fxDate == today &#125;</span><br><span class="line">                    if (todayWeather != null) &#123;</span><br><span class="line">                        val weatherText = todayWeather.textDay</span><br><span class="line">                        binding.weatherTextView.text = weatherText</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.e(&quot;AddDiaryActivity&quot;, &quot;获取天气信息失败: $&#123;response.message()&#125;, 响应代码: $&#123;response.code()&#125;, 响应体: $&#123;response.errorBody()?.string()&#125;&quot;)</span><br><span class="line">                    showToastOnUiThread(&quot;获取天气信息失败&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;WeatherResponse&gt;, t: Throwable) &#123;</span><br><span class="line">                Log.e(&quot;AddDiaryActivity&quot;, &quot;获取天气信息网络请求失败: $&#123;t.message&#125;&quot;, t)</span><br><span class="line">                showToastOnUiThread(&quot;获取天气信息网络请求失败&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun saveDiary() &#123;</span><br><span class="line">        Executors.newSingleThreadExecutor().execute &#123;</span><br><span class="line">            val title = binding.titleEditText.text.toString()</span><br><span class="line">            val content = binding.contentEditText.text.toString()</span><br><span class="line">            val localImagePath = selectedLocalImageUri?.toString()</span><br><span class="line">            val date = DateUtils.formatDate(Calendar.getInstance().time)</span><br><span class="line">            val weather = binding.weatherTextView.text.toString()</span><br><span class="line">            val location = binding.locationTextView.text.toString()</span><br><span class="line"></span><br><span class="line">            val diary = Diary(</span><br><span class="line">                title = title,</span><br><span class="line">                content = content,</span><br><span class="line">                localImagePath = localImagePath,</span><br><span class="line">                networkImageUrl = networkImageUrl,</span><br><span class="line">                date = date,</span><br><span class="line">                weather = weather,</span><br><span class="line">                location = location</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            diaryDatabase.diaryDao().insertDiary(diary)</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                Toast.makeText(this, &quot;日记保存成功&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">                val intent = Intent(&quot;SAVED&quot;) // 或者 &quot;com.example.app.DIARY_SAVED&quot;</span><br><span class="line">                sendBroadcast(intent)</span><br><span class="line">                finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="DetailUtils"><a href="#DetailUtils" class="headerlink" title="DetailUtils"></a>DetailUtils</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final.utils</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Date</span><br><span class="line">import java.util.Locale</span><br><span class="line"></span><br><span class="line">object DateUtils &#123;</span><br><span class="line">    private const val DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;</span><br><span class="line"></span><br><span class="line">    // 线程安全的 SimpleDateFormat 生成</span><br><span class="line">    private fun getDateFormat(pattern: String): SimpleDateFormat &#123;</span><br><span class="line">        return SimpleDateFormat(pattern, Locale.getDefault())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 格式化日期（默认格式 &quot;yyyy-MM-dd&quot;）</span><br><span class="line">    fun formatDate(date: Date, pattern: String = DEFAULT_DATE_FORMAT): String &#123;</span><br><span class="line">        return getDateFormat(pattern).format(date)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取当前日期的格式化字符串</span><br><span class="line">    fun getCurrentDate(pattern: String = DEFAULT_DATE_FORMAT): String &#123;</span><br><span class="line">        return formatDate(Date(), pattern)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LocationUtils"><a href="#LocationUtils" class="headerlink" title="LocationUtils"></a>LocationUtils</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.example.diary_final.utils</span><br><span class="line"></span><br><span class="line">import android.Manifest</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.content.pm.PackageManager</span><br><span class="line">import android.location.Location</span><br><span class="line">import android.location.LocationListener</span><br><span class="line">import android.location.LocationManager</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import androidx.core.app.ActivityCompat</span><br><span class="line"></span><br><span class="line">class LocationUtils(private val context: Context) &#123;</span><br><span class="line"></span><br><span class="line">    private val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager</span><br><span class="line">    private var locationListener: LocationListener? = null</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前位置</span><br><span class="line">     */</span><br><span class="line">    fun getLocation(onLocationReceived: (Location) -&gt; Unit) &#123;</span><br><span class="line">        // 权限检查</span><br><span class="line">        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;</span><br><span class="line">            ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">        ) &#123;</span><br><span class="line">            return // 没有权限，直接返回</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取上次已知位置（可能会加快首次获取速度）</span><br><span class="line">        val lastKnownLocation: Location? = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER)</span><br><span class="line">            ?: locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)</span><br><span class="line">        if (lastKnownLocation != null) &#123;</span><br><span class="line">            onLocationReceived(lastKnownLocation)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 监听实时位置更新</span><br><span class="line">        locationListener = object : LocationListener &#123;</span><br><span class="line">            override fun onLocationChanged(location: Location) &#123;</span><br><span class="line">                onLocationReceived(location)</span><br><span class="line">                removeLocationUpdates() // 获取到位置后移除监听</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) &#123;&#125;</span><br><span class="line">            override fun onProviderEnabled(provider: String) &#123;&#125;</span><br><span class="line">            override fun onProviderDisabled(provider: String) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 请求位置更新（优先使用 GPS，网络作为备用）</span><br><span class="line">        try &#123;</span><br><span class="line">            locationManager.requestLocationUpdates(</span><br><span class="line">                LocationManager.GPS_PROVIDER,</span><br><span class="line">                5000L, // 5秒更新一次</span><br><span class="line">                10f,   // 10米变化更新</span><br><span class="line">                locationListener!!</span><br><span class="line">            )</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            locationManager.requestLocationUpdates(</span><br><span class="line">                LocationManager.NETWORK_PROVIDER,</span><br><span class="line">                5000L,</span><br><span class="line">                10f,</span><br><span class="line">                locationListener!!</span><br><span class="line">            )</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除位置更新监听，防止内存泄漏</span><br><span class="line">     */</span><br><span class="line">    fun removeLocationUpdates() &#123;</span><br><span class="line">        locationListener?.let &#123;</span><br><span class="line">            locationManager.removeUpdates(it)</span><br><span class="line">            locationListener = null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin语法</title>
      <link href="/2025/03/03/Kotlin%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/03/Kotlin%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="apply、let、run、also、with"><a href="#apply、let、run、also、with" class="headerlink" title="apply、let、run、also、with"></a>apply、let、run、also、with</h1><p>Kotlin 提供了一些 <strong>作用域函数（Scope Functions）</strong>，比如 <code>apply</code>、<code>let</code>、<code>run</code>、<code>also</code> 和 <code>with</code>，它们可以让代码更加简洁，提高可读性。这些函数的主要作用是<strong>在对象的特定作用域内执行代码</strong>，避免重复引用对象（如 <code>this</code> 或 <code>it</code>）。</p><h2 id="1-apply：在对象自身作用域内修改对象"><a href="#1-apply：在对象自身作用域内修改对象" class="headerlink" title="1. apply：在对象自身作用域内修改对象"></a>1. apply：在对象自身作用域内修改对象</h2><p><code>apply</code> <strong>返回调用者本身（this）</strong>，适用于对对象执行一系列 <strong>修改操作</strong> 后返回自身。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li><strong>用于初始化对象</strong>，避免多次调用对象的 <code>set</code> 方法。</li><li><strong>链式调用</strong>，让代码更流畅。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑class Person &#123;</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val person = Person().apply &#123;</span><br><span class="line">    name = &quot;Alice&quot;</span><br><span class="line">    age = 20</span><br><span class="line">&#125;</span><br><span class="line">println(person.name) // Alice</span><br><span class="line">println(person.age)  // 20</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li><code>apply</code> 作用在 <code>Person</code> 对象上，<code>this</code> 代表 <code>Person</code> 本身。</li><li><strong>直接在 <code>apply</code> 的代码块内修改对象的属性</strong>，最终 <code>apply</code> <strong>返回该对象本身</strong>，所以 <code>person</code> 仍然是 <code>Person</code> 类型。</li></ul><h2 id="2-let：适用于非空值的操作"><a href="#2-let：适用于非空值的操作" class="headerlink" title="2. let：适用于非空值的操作"></a>2. let：适用于非空值的操作</h2><p><code>let</code> <strong>返回最后一行的值</strong>，<strong>适用于可空对象</strong>，可以避免 <code>NullPointerException</code>。</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li><strong>避免 <code>null</code> 检查</strong>，简化 <code>?.</code> 操作符的逻辑。</li><li><strong>链式调用</strong>，对值进行转换。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑val name: String? = &quot;Kotlin&quot;</span><br><span class="line">name?.let &#123;</span><br><span class="line">    println(it.uppercase())  // KOTLIN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li><code>name?.let &#123;&#125;</code> 只有在 <code>name</code> <strong>不为空</strong> 时才会执行 <code>let</code> 代码块，<strong>如果 <code>name</code> 为空，则不会执行</strong>。</li><li><code>it</code> 代表 <code>name</code> 这个变量的值，因此 <code>it.uppercase()</code> 把 <code>name</code> 转换为大写。</li></ul><p><strong>另一种使用场景：变量作用域控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑val number = 5</span><br><span class="line">val square = number.let &#123;</span><br><span class="line">    val result = it * it</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line">println(square) // 25</span><br></pre></td></tr></table></figure><ul><li><code>let</code> 代码块中的 <code>it</code> 代表 <code>number</code>，计算 <code>5 * 5</code> 并返回 <code>25</code>。</li></ul><h2 id="3-run：在对象作用域内执行代码并返回结果"><a href="#3-run：在对象作用域内执行代码并返回结果" class="headerlink" title="3. run：在对象作用域内执行代码并返回结果"></a>3. run：在对象作用域内执行代码并返回结果</h2><p><code>run</code> 结合了 <code>let</code> 和 <code>apply</code> 的特性，它在 <strong>对象作用域</strong> 内执行代码，并 <strong>返回最后一行的值</strong>。</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li>需要在对象上执行多个 <strong>计算操作</strong> 并返回值。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑val person = Person().run &#123;</span><br><span class="line">    name = &quot;Bob&quot;</span><br><span class="line">    age = 25</span><br><span class="line">    &quot;名字是 $name, 年龄是 $age&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(person)  // 名字是 Bob, 年龄是 25</span><br></pre></td></tr></table></figure><ul><li><code>run</code> 作用在 <code>Person</code> 对象上，<code>this</code> 代表 <code>Person</code>，代码块内可以直接修改 <code>name</code> 和 <code>age</code>。</li><li>最后一行 <code>&quot;名字是 $name, 年龄是 $age&quot;</code> 作为返回值赋给 <code>person</code>。</li></ul><h2 id="4-also：适用于对象的额外操作"><a href="#4-also：适用于对象的额外操作" class="headerlink" title="4.also：适用于对象的额外操作"></a>4.also：适用于对象的额外操作</h2><p><code>also</code> <strong>返回调用者本身（this）</strong>，但和 <code>apply</code> 不同的是，<code>also</code> <strong>更适用于执行额外的副作用操作</strong>（比如 <strong>日志、打印、调试</strong>）。</p><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li><strong>记录日志</strong> 或 <strong>调试</strong>。</li><li><strong>不会修改对象本身</strong>，只是执行额外操作。</li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑val numbers = mutableListOf(1, 2, 3).also &#123;</span><br><span class="line">    println(&quot;原始列表: $it&quot;) // 原始列表: [1, 2, 3]</span><br><span class="line">&#125;.apply &#123;</span><br><span class="line">    add(4)</span><br><span class="line">&#125;</span><br><span class="line">println(numbers) // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li><code>also</code> 代码块中的 <code>it</code> 是 <code>numbers</code>，<strong>不会改变 <code>numbers</code> 本身</strong>，只是用于打印日志。</li><li><code>apply</code> 修改了 <code>numbers</code>，最终 <code>numbers</code> 变为 <code>[1, 2, 3, 4]</code>。</li></ul><h2 id="5-with：用于非扩展对象的作用域调用"><a href="#5-with：用于非扩展对象的作用域调用" class="headerlink" title="5. with：用于非扩展对象的作用域调用"></a>5. with：用于非扩展对象的作用域调用</h2><p><code>with</code> <strong>不能直接调用</strong>，而是以普通函数的形式传递一个对象，然后在其作用域内执行代码，<strong>并返回最后一行的值</strong>。</p><h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul><li>适用于<strong>不需要返回对象本身</strong>的情况，而是要返回计算结果。</li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制编辑val person = Person()</span><br><span class="line">val result = with(person) &#123;</span><br><span class="line">    name = &quot;Charlie&quot;</span><br><span class="line">    age = 30</span><br><span class="line">    &quot;名字: $name, 年龄: $age&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(result)  // 名字: Charlie, 年龄: 30</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li><code>with(person) &#123;&#125;</code> 让 <code>person</code> 进入作用域，<code>this</code> 代表 <code>person</code>。</li><li>最后一行返回 <code>&quot;名字: Charlie, 年龄: 30&quot;</code>。</li></ul><h2 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h2><table><thead><tr><th>函数</th><th>适用场景</th><th>作用域内的 <code>this</code> 或 <code>it</code></th><th>返回值</th></tr></thead><tbody><tr><td><code>apply</code></td><td><strong>修改对象本身</strong></td><td><code>this</code></td><td><strong>对象本身</strong></td></tr><tr><td><code>let</code></td><td><strong>可空对象、临时变量作用域</strong></td><td><code>it</code></td><td><strong>Lambda 最后一行</strong></td></tr><tr><td><code>run</code></td><td><strong>需要返回计算结果</strong></td><td><code>this</code></td><td><strong>Lambda 最后一行</strong></td></tr><tr><td><code>also</code></td><td><strong>执行额外操作（日志&#x2F;调试）</strong></td><td><code>it</code></td><td><strong>对象本身</strong></td></tr><tr><td><code>with</code></td><td><strong>更传统的作用域调用</strong></td><td><code>this</code></td><td><strong>Lambda 最后一行</strong></td></tr></tbody></table><hr><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h2><ol><li><strong>如果要修改对象并返回它本身</strong> 👉 <code>apply</code></li><li><strong>如果是可空对象，避免 <code>null</code> 检查</strong> 👉 <code>let</code></li><li><strong>如果只想执行代码块后返回结果</strong> 👉 <code>run</code></li><li><strong>如果不修改对象，只是执行副作用（日志等）</strong> 👉 <code>also</code></li><li><strong>如果要在对象作用域执行代码，并返回结果</strong> 👉 <code>with</code></li></ol><p>你可以根据自己的代码需求选择合适的作用域函数，这样可以提高代码的可读性和简洁性 🚀。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2025/02/24/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/02/24/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h1><p>使用#</p><h1 id="二-字体"><a href="#二-字体" class="headerlink" title="二.字体"></a>二.字体</h1><h2 id="1-粗体"><a href="#1-粗体" class="headerlink" title="1.粗体"></a>1.粗体</h2><p>两个*</p><p><strong>M</strong></p><p><strong>M</strong></p><h2 id="2-斜体"><a href="#2-斜体" class="headerlink" title="2.斜体"></a>2.斜体</h2><p>一个*</p><p><em>M</em></p><p><em>M</em></p><h2 id="3-粗体加斜体"><a href="#3-粗体加斜体" class="headerlink" title="3.粗体加斜体"></a>3.粗体加斜体</h2><p>三个*</p><p><em><strong>M</strong></em></p><p><em><strong>M</strong></em></p><h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h2><p>使用两个波浪线</p><p><del>M</del></p><p><del>M</del></p><h1 id="三-引用"><a href="#三-引用" class="headerlink" title="三.引用"></a>三.引用</h1><p>使用大于号</p><blockquote><p>M</p></blockquote><blockquote><p>M</p></blockquote><h1 id="四-分割线"><a href="#四-分割线" class="headerlink" title="四.分割线"></a>四.分割线</h1><p>三个*或者三个-</p><h1 id="五-图片"><a href="#五-图片" class="headerlink" title="五.图片"></a>五.图片</h1><p>!+[]+()，其中[]内填写名字，()内填写图片地址</p><p><img src="/"></p><h1 id="六-超链接"><a href="#六-超链接" class="headerlink" title="六.超链接"></a>六.超链接</h1><p>[]+()，其中[]内填写名字，()内填写网址</p><p><a href="www.baidu.com">hh</a></p><h1 id="七-列表"><a href="#七-列表" class="headerlink" title="七.列表"></a>七.列表</h1><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>数字加”.”,再加空格，即生成有序列表</p><ol><li>A</li><li>B</li></ol><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>-加空格</p><ul><li>1</li><li>2</li></ul><h1 id="八-表格"><a href="#八-表格" class="headerlink" title="八.表格"></a>八.表格</h1><p>1.右键，选择插入，选择表格</p><p>2.Ctrl+T</p><p>3.原始人模式</p><p>先写好格式如下</p><p>X|Y|Z</p><p>–|–|–</p><p>1|2|3</p><p>然后点击左下角图案&lt;&#x2F;&gt;，开启源代码模式，把各行之间的空行删除，即可生成表格。</p><h1 id="九-插入代码块"><a href="#九-插入代码块" class="headerlink" title="九.插入代码块"></a>九.插入代码块</h1><p>使用三个&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据库</title>
      <link href="/2025/02/24/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2025/02/24/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>进度1:32:06</p><h1 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一.数据类型"></a>一.数据类型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INT                    --整数</span><br><span class="line">DECIMAL(3,2)   --有小数点的数</span><br><span class="line">VARCHAR(10)            --字串</span><br><span class="line">BLOB                   --(Binary Large Object) 图片 影片 档案...</span><br><span class="line">DATA                   --&#x27;YYYY-MM-DD&#x27; 日期</span><br><span class="line">TIMESTAMP              --&#x27;YYYY-MM-DD HH:MM:SS&#x27; 记录时间</span><br></pre></td></tr></table></figure><h1 id="二-简单例子"><a href="#二-简单例子" class="headerlink" title="二.简单例子"></a>二.简单例子</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> dATABASE `sql_tutorial`;</span><br><span class="line"><span class="keyword">SHOW</span> DAtABaSES;</span><br><span class="line">USE `sql_tutorial`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `student`(</span><br><span class="line">`student_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> auto_increment,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> ,  <span class="comment">-- 这是一个注释，记得是减减加空格</span></span><br><span class="line">`major` <span class="type">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">default</span> <span class="string">&#x27;历史&#x27;</span>,</span><br><span class="line">`score` <span class="type">INT</span> <span class="keyword">default</span> <span class="number">100</span> <span class="comment">-- 最后一个属性不用加逗号</span></span><br><span class="line">);      <span class="comment">/*最后有;相当于一句话的结束？*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dESCriBe</span> `student`;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">TABLE</span> `student`;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">ADD</span> gpa <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.00</span>; <span class="comment">-- 新增属性</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> gpa; <span class="comment">-- 删除属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `student`;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;历史&#x27;</span>,<span class="number">100</span>); <span class="comment">-- 插入数据，注意是用单引号’而不是`</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;小绿&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`major`,`student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小蓝&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="number">4</span>); </span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`,`major`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="keyword">NULL</span>); <span class="comment">-- 不写id是因为auto_increment自动生成id</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `student` <span class="keyword">WHERE</span> `student_id` <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">-- 删除id为4的那一行</span></span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES<span class="operator">=</span><span class="number">0</span> ;<span class="comment">-- 用于关闭安全更新模式，允许你执行 UPDATE 或 DELETE 语句，即使没有 WHERE 条件或没有主键索引。</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` </span><br><span class="line"><span class="keyword">SET</span> `major` <span class="operator">=</span><span class="string">&#x27;英语文学&#x27;</span> <span class="comment">-- 不是行列名等，要使用&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> `major` <span class="operator">=</span><span class="string">&#x27;英语&#x27;</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;小1&#x27;</span> <span class="keyword">WHERE</span> `name`<span class="operator">=</span><span class="string">&#x27;小绿&#x27;</span> <span class="keyword">or</span> `name`<span class="operator">=</span> <span class="string">&#x27;小白&#x27;</span>;  <span class="comment">-- 更新表格</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;小灰&#x27;</span>,`major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span> <span class="keyword">WHERE</span> `student_id`<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `name`<span class="operator">=</span><span class="string">&#x27;小灰&#x27;</span> <span class="keyword">and</span> `major`<span class="operator">=</span><span class="string">&#x27;物理&#x27;</span>; <span class="comment">-- where用and连接</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `score`<span class="operator">&lt;</span><span class="number">60</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` ;<span class="comment">-- 把student内数据全部删除</span></span><br><span class="line"><span class="comment">-- 取得资料</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student`;</span><br><span class="line"><span class="keyword">Select</span> `name` <span class="keyword">from</span> `student` ;</span><br><span class="line"><span class="keyword">select</span> `name` , `major` <span class="keyword">from</span> `student`; <span class="comment">-- 中间用,而不是and</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score` ; <span class="comment">-- 从低到高，或者在order by后面加上ASC</span></span><br><span class="line"><span class="keyword">selecT</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score` <span class="keyword">DESC</span>;<span class="comment">-- 从高到低</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">order</span> <span class="keyword">by</span> `score`<span class="keyword">DESC</span>,`student_id`  Limit <span class="number">3</span>; <span class="comment">-- 先根据score降序排序，若是score一样，则按student_id升序排序，只返回前三个</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> `major`<span class="operator">=</span><span class="string">&#x27;英语&#x27;</span> <span class="keyword">and</span> `student_id`<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- where用and连接</span></span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>1.<em><strong>注释</strong></em>有– 和&#x2F;**&#x2F;两种–后面要跟空格</p><p>2.一个引号是一句，比如虽然CREATE TABLE <code>student</code> 有那么多行，其实只有一句，所以cursor指向容易一行就可以执行整个语句</p><p>3.闪电只会闪电一句话，比如你没有执行USE sql_tutorial 这一句话，去执行dESCriBe <code>student</code>;就会报错，记住<em><strong>一定要先执行USE sql_tutorial这句话</strong></em></p><p>4.关键字的大小写是无所谓的，但建议关键字全用大写，上面例子只是为了体现大小写任意的特征，实际上一个全部大写，自己定义的字建议使用&#96;&#96;包括起来，并使用小写</p><p>5.&gt;大于   &lt;小于   &gt;&#x3D;大于等于   &#x3D;等于    &lt;&gt;不等于</p><p>6.where用and，or连接？</p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用AS的准备</title>
      <link href="/2025/02/16/%E4%BD%BF%E7%94%A8AS%E7%9A%84%E5%87%86%E5%A4%87/"/>
      <url>/2025/02/16/%E4%BD%BF%E7%94%A8AS%E7%9A%84%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="1-viewbinding"><a href="#1-viewbinding" class="headerlink" title="1.viewbinding"></a>1.viewbinding</h1><p>build.gradle.kts中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">...</span><br><span class="line">buildFeatures &#123;</span><br><span class="line">    viewBinding = true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-compileSdk"><a href="#2-compileSdk" class="headerlink" title="2.compileSdk"></a>2.compileSdk</h1><p>build.gradle.kts中compileSdk&#x3D;34改成compileSdk&#x3D;35</p><h1 id="3-dependencies"><a href="#3-dependencies" class="headerlink" title="3.dependencies"></a>3.dependencies</h1><p>在dependencies中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">implementation(&quot;androidx.fragment:fragment:1.6.2&quot;)</span><br><span class="line">implementation(&quot;com.squareup.okhttp3:okhttp:4.10.0&quot;)</span><br><span class="line">implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1&quot;)</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&quot;)</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.4.0&quot;)</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0&quot;)</span><br><span class="line">implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)</span><br><span class="line">kapt(&quot;androidx.room:room-compiler:2.6.1&quot;)</span><br><span class="line">implementation(&quot;androidx.work:work-runtime:2.10.0&quot;)</span><br><span class="line">implementation(&quot;com.github.bumptech.glide:glide:4.15.1&quot;)</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">implementation(&quot;androidx.fragment:fragment-ktx:1.6.2&quot;)</span><br><span class="line">implementation(&quot;com.squareup.okhttp3:okhttp:4.10.0&quot;)//引用OkHttp库</span><br><span class="line">implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)//使用gson</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)//使用Retrofit,会自动将Retrofit、OkHttp、和Okio这几个库一起下载，不用再手动引入OkHttp库。</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)//使用Retrofit，这是一个Retrofit的转换库，它是借助GSON来解析JSON数据的，所以会自动将GSON库下载下来，所以不用手动引入GSON库了</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1&quot;)//协程</span><br><span class="line">implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&quot;)//协程</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.4.0&quot;)//使用ViewModel组件</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)//使用ViewModel、livedata组件</span><br><span class="line">implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0&quot;)//使用ViewModel组件</span><br><span class="line">implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)//room</span><br><span class="line">kapt(&quot;androidx.room:room-compiler:2.6.1&quot;)//room</span><br><span class="line">implementation(&quot;androidx.work:work-runtime:2.10.0&quot;)//WorkManager</span><br><span class="line">implementation(&quot;com.github.bumptech.glide:glide:4.15.1&quot;)/*Glide,另外，Glide中需要用到网络功能，因此你还得在AndroidManifest.xml中声明一下网络权限才行：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-plugins"><a href="#4-plugins" class="headerlink" title="4.plugins"></a>4.plugins</h1><p>添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(&quot;kotlin-kapt&quot;)</span><br></pre></td></tr></table></figure><p>解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(&quot;kotlin-kapt&quot;)//为了dependencies中能使用kapt(&quot;...&quot;)这样的语法</span><br></pre></td></tr></table></figure><h1 id="5-binding"><a href="#5-binding" class="headerlink" title="5.binding"></a>5.binding</h1><p>改用binding.root</p><h1 id="6-声明网络权限"><a href="#6-声明网络权限" class="headerlink" title="6.声明网络权限"></a>6.声明网络权限</h1><p>在AndroidManifest.xml开头添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如下面例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><h1 id="7-使用HTTP"><a href="#7-使用HTTP" class="headerlink" title="7.使用HTTP"></a>7.使用HTTP</h1><p>在res-&gt;xml文件夹下，新建network_config.xml文件，然后修改文件中内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">    &lt;base-config cleartextTrafficPermitted=&quot;true&quot;&gt;</span><br><span class="line">        &lt;trust-anchors&gt;</span><br><span class="line">            &lt;certificates src=&quot;system&quot;/&gt;</span><br><span class="line">        &lt;/trust-anchors&gt;</span><br><span class="line">    &lt;/base-config&gt;</span><br><span class="line">&lt;/network-security-config&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段配置文件的意思是允许我们以明文的方式在网络上传输数据，而HTTP使用的就是明文传输方式。</p><p>接下来修改AndroidManifest.xml中的代码来启用我们刚才创建的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        android:allowBackup=&quot;true&quot;</span><br><span class="line">        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;</span><br><span class="line">        android:fullBackupContent=&quot;@xml/backup_rules&quot;</span><br><span class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;</span><br><span class="line">        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:supportsRtl=&quot;true&quot;</span><br><span class="line">        android:theme=&quot;@style/Theme.NetworkTest&quot;</span><br><span class="line">        tools:targetApi=&quot;31&quot;</span><br><span class="line">        android:networkSecurityConfig=&quot;@xml/network_config&quot;//就是添加这一行哦</span><br><span class="line">        &gt;</span><br></pre></td></tr></table></figure><h1 id="AndroidManifest-xml的权限声明"><a href="#AndroidManifest-xml的权限声明" class="headerlink" title="AndroidManifest.xml的权限声明"></a>AndroidManifest.xml的权限声明</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; </span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task-4</title>
      <link href="/2025/02/10/Task-4/"/>
      <url>/2025/02/10/Task-4/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第四讲"><a href="#寒假第四讲" class="headerlink" title="寒假第四讲"></a>寒假第四讲</h1><h2 id="一-有理数取余"><a href="#一-有理数取余" class="headerlink" title="一.有理数取余"></a>一.有理数取余</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该问题要求计算有理数 c&#x3D;ab<em>c</em>&#x3D;<em>b**a</em> 对19260817取模的值。根据模运算的性质，这相当于求解方程 bx≡amod  19260817<em>b**x</em>≡<em>a</em>mod19260817。解的存在性取决于 b<em>b</em> 是否存在模19260817的逆元。具体步骤如下：</p><ol><li><strong>大数取模</strong>：由于输入的 a<em>a</em> 和 b<em>b</em> 可能非常大（最多10001位），需要将这两个数转换为模19260817后的值。这可以通过逐位处理字符串并取模来实现。</li><li><strong>判断逆元存在性</strong>：若 b<em>b</em> 模19260817的结果为0，则方程无解，直接输出“Angry!”。否则，利用费马小定理计算 b<em>b</em> 的逆元，因为19260817是质数。</li><li><strong>计算最终结果</strong>：将 a<em>a</em> 的模值与逆元相乘后再次取模，得到最终结果。</li></ol><h3 id="2-对应代码"><a href="#2-对应代码" class="headerlink" title="2.对应代码"></a>2.对应代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MOD = 19260817;</span><br><span class="line"></span><br><span class="line">int mod(const string&amp; s, int m) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (char c : s) &#123;</span><br><span class="line">        res = (res * 10LL + (c - &#x27;0&#x27;)) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long pow_mod(long long a, long long b, int mod) &#123;</span><br><span class="line">    long long res = 1;</span><br><span class="line">    a %= mod;</span><br><span class="line">    while (b &gt; 0) &#123;</span><br><span class="line">        if (b % 2 == 1) res = (res * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string a_str, b_str;</span><br><span class="line">    cin &gt;&gt; a_str &gt;&gt; b_str;</span><br><span class="line"></span><br><span class="line">    int a_mod = mod(a_str, MOD);</span><br><span class="line">    int b_mod = mod(b_str, MOD);</span><br><span class="line"></span><br><span class="line">    if (b_mod == 0) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Angry!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        long long inv_b = pow_mod(b_mod, MOD - 2, MOD);</span><br><span class="line">        long long ans = (a_mod * inv_b) % MOD;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li><strong>大数取模技巧</strong>：处理超大数时，可以通过逐位取模的方式避免数值溢出。例如，将字符串的每一位依次转换为当前结果的10倍加上该位数字，然后立即取模。</li><li><strong>逆元计算</strong>：当模数为质数时，可以利用费马小定理快速计算逆元（即 ap−2mod  p<em>a**p</em>−2mod<em>p</em>），时间复杂度为 O(log⁡p)<em>O</em>(log<em>p</em>)。</li><li><strong>输入处理</strong>：注意输入的数值范围，使用字符串处理大数，并确保处理过程中不会溢出。</li><li><strong>边界条件</strong>：题目保证输入的 a<em>a</em> 和 b<em>b</em> 不同时是模数的倍数，因此当 b<em>b</em> 的模为0时，直接判定无解。</li></ol><p>该问题结合了数论中的模运算和逆元知识，同时考察了处理大数的技巧，综合应用了多种算法和编程技术。</p><h2 id="二-Minimal-Coprime"><a href="#二-Minimal-Coprime" class="headerlink" title="二.Minimal Coprime"></a>二.Minimal Coprime</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>对于每一个测试用例，我们需要找出区间 [l, r] 内所有的最小互质区间。由于我们要判断区间是否是最小互质，实际操作时可以考虑以下几点：</p><ol><li>如果 l &#x3D;&#x3D; r，那么只有一个单一的数，需要检查该数是否与自身互质，显然，对于任意数 a，<code>gcd(a, a) ≠ 1</code>，因此这类区间无法构成互质区间。</li><li>如果 l !&#x3D; r，则要判断区间 [l, r] 内每一个单元素子区间是否互质，同时对于更大的区间是否是最小互质区间。</li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">const int N = 1e6 + 10,mod = 19260817,INT = 1e17,M = 5e6;</span><br><span class="line"> </span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"> </span><br><span class="line">int qmi(int a,int k)&#123;</span><br><span class="line">int res = 1;</span><br><span class="line">while(k)&#123;</span><br><span class="line">if(k&amp;1) res = res * a % mod;</span><br><span class="line">a = a * a % mod; </span><br><span class="line">k &gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void slove()&#123;</span><br><span class="line">string a,b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">int na = 0,nb = 0;</span><br><span class="line">for(auto c:a)&#123;</span><br><span class="line">na = (na * 10 + c - &#x27;0&#x27;) % mod;</span><br><span class="line">&#125;</span><br><span class="line">for(auto c:b) nb = (nb * 10 + c - &#x27;0&#x27;) % mod;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; na * qmi(nb,mod - 2) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);cin.tie(nullptr);</span><br><span class="line">int T = 1;</span><br><span class="line">while(T--) slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>最大公约数 (gcd)</strong>：在这道题中，我们频繁使用 <code>gcd</code> 来判断两个数是否互质。通过辗转相除法，可以有效地求出两个数的最大公约数，进而判断它们是否互质。</p><p><strong>区间内互质判断</strong>：对于每一个子区间，需要检查它们是否互质，并且判断是否包含更小的互质子区间。这要求我们在求解时要小心处理每个区间，避免遗漏。</p><p><strong>最小互质区间的判定</strong>：最小互质区间需要满足不包含任何其他互质区间，这一点是解题的关键。通过遍历区间的所有子区间，并确保它们不含更小的互质区间，可以确保找到所有最小互质区间。</p><p><strong>优化</strong>：虽然本解法直接暴力枚举所有区间，但考虑到题目中区间范围较大，应该在实际使用中进行一些优化，如剪枝等策略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task 3</title>
      <link href="/2025/02/06/Task-3/"/>
      <url>/2025/02/06/Task-3/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第三讲"><a href="#寒假第三讲" class="headerlink" title="寒假第三讲"></a>寒假第三讲</h1><h2 id="一-priority-queue"><a href="#一-priority-queue" class="headerlink" title="一.priority queue"></a>一.priority queue</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求实现一个优先队列，支持插入操作 <code>insert(k)</code> 和提取最大元素操作 <code>extractMax</code>。在 C++ 中，我们可以使用 <code>priority_queue</code> 来实现这一结构。<code>priority_queue</code> 默认是最大堆，插入操作将元素添加到堆中，而提取操作返回并删除堆顶的元素。</p><p>首先，输入包含多个操作，每个操作可能是 <code>insert k</code>（插入整数 k）、<code>extract</code>（提取最大元素）或 <code>end</code>（结束输入）。对于每个 <code>insert k</code> 操作，我们将元素插入到优先队列中。对于每个 <code>extract</code> 操作，我们从堆中提取并输出当前最大值。</p><p>C++ 的 <code>priority_queue</code> 数据结构默认按降序排列（即最大堆），因此无需额外处理即可满足题目要求。程序通过循环读取操作，针对 <code>insert</code> 进行堆插入，针对 <code>extract</code> 进行堆顶元素提取并输出，直到遇到 <code>end</code> 操作停止。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Compare &#123;</span><br><span class="line">    bool operator()(int a, int b) &#123;</span><br><span class="line">        return a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, Compare&gt; pq; </span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    while (getline(cin, line)) &#123;</span><br><span class="line">        if (line.empty()) continue;</span><br><span class="line"></span><br><span class="line">        stringstream ss(line);</span><br><span class="line">        string command;</span><br><span class="line">        ss &gt;&gt; command;</span><br><span class="line"></span><br><span class="line">        if (command == &quot;insert&quot;) &#123;</span><br><span class="line">            int k;</span><br><span class="line">            ss &gt;&gt; k;</span><br><span class="line">            pq.push(k);</span><br><span class="line">        &#125; else if (command == &quot;extract&quot;) &#123;</span><br><span class="line">            if (!pq.empty()) &#123;</span><br><span class="line">                cout &lt;&lt; pq.top() &lt;&lt; endl; </span><br><span class="line">                pq.pop(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (command == &quot;end&quot;) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>通过实现这个优先队列，了解了 C++ 中 <code>priority_queue</code> 的基本使用方法。<code>priority_queue</code> 使用最大堆结构，自动保证每次提取的都是当前最大元素，因此插入和提取操作的时间复杂度为 <code>O(log n)</code>，非常高效。此外，使用 <code>priority_queue</code> 还可以避免手动维护堆结构，从而减少了程序复杂度。通过输入和输出流的处理，我也更深入地理解了如何高效处理大规模数据输入。特别是对于题目中限制的 200 万次操作，我们需要确保程序的输入输出效率，因此应该尽量减少不必要的操作，使用合适的输入输出方法提高程序性能。</p><h2 id="ST表-RMQ问题"><a href="#ST表-RMQ问题" class="headerlink" title="ST表&amp;&amp;RMQ问题"></a>ST表&amp;&amp;RMQ问题</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该程序利用 ST 表进行静态区间最大值查询。首先，使用 <code>preprocess</code> 函数构建 ST 表，预处理时间复杂度为 O(N log N)。<br>对于每个查询，我们利用对数表 <code>log_table</code> 预计算查询范围的最优分块，使得查询复杂度降为 O(1)。<br>通过 <code>read()</code> 进行高效输入，减少 IO 时间，适用于大数据量场景。</p><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 100000;</span><br><span class="line">const int LOG = 17;</span><br><span class="line">int st[MAX_N][LOG];</span><br><span class="line">int log_table[MAX_N + 1];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;) f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preprocess(const vector&lt;int&gt;&amp; arr, int n) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        st[i][0] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">        for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i++) &#123;</span><br><span class="line">            st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log_table[1] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        log_table[i] = log_table[i / 2] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int l, int r) &#123;</span><br><span class="line">    int j = log_table[r - l + 1];</span><br><span class="line">    return max(st[l][j], st[r - (1 &lt;&lt; j) + 1][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = read(), m = read();</span><br><span class="line">    vector&lt;int&gt; arr(n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line">    preprocess(arr, n);</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int l = read() - 1, r = read() - 1;</span><br><span class="line">        printf(&quot;%d\n&quot;, query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>ST 表适用于静态查询，预处理代价较高，但查询极快。</li><li>利用 <code>log_table</code> 预计算对数值可以减少 <code>log</code> 函数调用，提高查询效率。</li><li>快速输入 <code>read()</code> 可有效减少时间开销，适用于高强度数据。</li><li>ST 表的核心思想是利用区间的重叠性，通过 <code>dp</code> 方式高效存储区间信息</li></ol><h2 id="合并果子"><a href="#合并果子" class="headerlink" title="合并果子"></a>合并果子</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题可以通过哈夫曼树（Huffman Tree）的思想来解决，使用最小堆（优先队列）进行贪心合并。<br>每次取出当前最小的两堆果子进行合并，合并的代价是两者之和，并将新堆重新加入优先队列。<br>这个过程持续 n-1 次，最终优先队列中只剩下一堆，累加所有合并的代价，即为最小的体力耗费。<br>由于使用了最小堆，每次插入与删除的复杂度是 O(log n)，整体复杂度为 O(n log n)。</p><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0, f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">        if (ch == &#x27;-&#x27;) f = -1;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        x = x * 10 + ch - &#x27;0&#x27;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = read();</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        pq.push(read());</span><br><span class="line">    &#125;</span><br><span class="line">    int total_cost = 0;</span><br><span class="line">    while (pq.size() &gt; 1) &#123;</span><br><span class="line">        int a = pq.top(); pq.pop();</span><br><span class="line">        int b = pq.top(); pq.pop();</span><br><span class="line">        int cost = a + b;</span><br><span class="line">        total_cost += cost;</span><br><span class="line">        pq.push(cost);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, total_cost);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>本题是典型的贪心算法应用，通过局部最优（每次合并最小的两堆）达到全局最优。</li><li>最小堆（优先队列）是一种有效的数据结构，适用于处理动态集合中的最小值问题。</li><li>哈夫曼树的构造与本题类似，它用于最优前缀编码问题，具有广泛应用。</li><li>由于 n 最大为 10000，使用 O(n log n) 复杂度的方法是合理可行的，若用 O(n^2) 的方法会超时。</li><li>通过 <code>priority_queue</code> 的 <code>greater&lt;int&gt;</code> 实现最小堆，提高代码可读性和效率。</li></ol><h2 id="四-约瑟夫问题"><a href="#四-约瑟夫问题" class="headerlink" title="四.约瑟夫问题"></a>四.约瑟夫问题</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>该题是经典的约瑟夫环问题。我们通过模拟报数过程来解决，使用双端队列（<code>deque</code>）来模拟每次出圈的操作。首先将所有人的编号依次加入队列，每次将前 mmm 个人报数，第 mmm 个人出列，再从下一个人开始继续报数。该过程重复直到所有人都出列。通过队列的 <code>push_back</code> 和 <code>pop_front</code> 操作来模拟循环报数，保证每个出圈人的编号按顺序输出。</p><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    deque&lt;int&gt; people;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        people.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    while (!people.empty()) &#123;</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            people.push_back(people.front());</span><br><span class="line">            people.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        cout &lt;&lt; people.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">        people.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h3><p><strong>约瑟夫环问题</strong>：是经典的动态结构问题，使用队列模拟能够有效解决。</p><p><strong>队列操作</strong>：队列的 <code>push_back</code> 和 <code>pop_front</code> 操作时间复杂度为 O(1)，适合进行循环模拟。</p><p><strong>循环过程理解</strong>：通过理解每次从队列中移除第 mmm 个人，并将下一个人重新从头开始报数，可以轻松解决问题。</p><p><strong>时间复杂度</strong>：对于 n 和 m 较小的情况，O(n * m) 的时间复杂度是可行的。</p><p><strong>应用范围</strong>：这种方法适用于类似的循环排列问题，理解其实现方式对于解决其他类似问题非常有帮助。</p><h2 id="五-Look-Up-S"><a href="#五-Look-Up-S" class="headerlink" title="五.Look Up S"></a>五.Look Up S</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题的核心在于查找每个奶牛的右侧第一个比她高的奶牛。通过使用栈（stack）数据结构，可以高效地维护一个递减的序列。每次遇到一个奶牛时，将其与栈顶的奶牛进行比较，如果栈顶奶牛的身高不大于当前奶牛，就将其弹出，直到栈顶奶牛的身高大于当前奶牛或栈为空。此时栈顶元素即为当前奶牛的仰望对象。</p><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1e5 + 5;</span><br><span class="line">int h[MAXN];</span><br><span class="line">int ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; stk;</span><br><span class="line">    for (int i = n; i &gt;= 1; --i) &#123;</span><br><span class="line">        while (!stk.empty() &amp;&amp; h[stk.back()] &lt;= h[i]) &#123;</span><br><span class="line">            stk.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = stk.empty() ? 0 : stk.back();</span><br><span class="line">        stk.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>栈的应用</strong>：本题运用了栈来解决查找“右侧第一个更大元素”的问题。栈非常适合解决递增&#x2F;递减问题，能够避免不必要的重复计算。</p><p><strong>时间复杂度优化</strong>：通过栈的方式，每个奶牛的身高最多入栈和出栈一次，整体时间复杂度为 O(N)，满足大规模数据的需求。</p><p><strong>贪心策略</strong>：栈的使用体现了贪心策略，通过逐步找出最优解。每次都保证栈中的奶牛按递减顺序排列，能快速找到每个奶牛的第一个仰望对象。</p><p><strong>解决类似问题</strong>：掌握栈的应用可以解决许多类似的“寻找下一个更大&#x2F;小元素”类型的问题。</p><h2 id="五-国旗计划"><a href="#五-国旗计划" class="headerlink" title="五.国旗计划"></a>五.国旗计划</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p><strong>区间转化</strong>：</p><ul><li>每个边防战士常驻两个边防站 <code>C_i</code> 和 <code>D_i</code>，其奔袭区间为从 <code>C_i</code> 到 <code>D_i</code>。如果 <code>C_i &gt; D_i</code>，说明该区间跨越了边境，需要加上边境的总长度 <code>M</code>，这样就能确保所有区间都是线性区间，方便后续处理。</li></ul><p><strong>排序</strong>：</p><ul><li>由于区间覆盖问题通常需要按顺序处理，所有边防战士的奔袭区间按照左端点 <code>l</code> 排序。排序后的数组使得我们可以方便地逐一处理每个边防战士，并计算出最少需要多少战士来覆盖边境。</li></ul><p><strong>动态规划和跳跃法</strong>：</p><ul><li>采用动态规划来解决每个边防战士覆盖的最远区间问题。通过二分查找，找到每个战士能覆盖的最远位置，记录在二维数组 <code>go</code> 中。<code>go[i][0]</code> 存储战士 <code>i</code> 覆盖区间的最远战士 <code>k</code> 的下标。为了更高效地查询最大覆盖，代码通过多级跳跃的方式，构建了 <code>go</code> 数组，并通过动态规划实现快速查询。</li></ul><p><strong>查询最小战士数量</strong>：</p><ul><li>在查询每个战士必须参与的前提下，我们从该战士的起始位置开始，依次找到能够覆盖区间的最远战士，通过二分查找的方式迭代跳跃，最后计算出最少需要的战士数量。</li></ul><p><strong>输出结果</strong>：</p><ul><li>对于每个战士，输出必须参与的前提下，最少需要多少个战士来覆盖整个边境线。</li></ul></li></ol><h3 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, res[200005];</span><br><span class="line">struct soldier &#123;</span><br><span class="line">int id, l, r;</span><br><span class="line">&#125; s[400005];</span><br><span class="line">int cmp(soldier a, soldier b)</span><br><span class="line">&#123;</span><br><span class="line">return a.l &lt; b.l; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int go[400005][20];</span><br><span class="line"></span><br><span class="line">void pre()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1, p = i; i &lt;= 2 * n; i++) &#123;</span><br><span class="line">while(p &lt;= 2 * n &amp;&amp; s[p].l &lt;= s[i].r)</span><br><span class="line">p++;</span><br><span class="line">int pos = p - 1;</span><br><span class="line">go[i][0] = pos;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">for(int j = 1; j &lt;= 2 * n; j++) &#123;</span><br><span class="line">go[j][i] = go[go[j][i - 1]][i - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void search(int k)</span><br><span class="line">&#123;</span><br><span class="line">int lmt = s[k].l + m, ans = 1, p = k;</span><br><span class="line">for(int i = 19; i &gt;= 0; i--) &#123;</span><br><span class="line">if(go[k][i] != 0 &amp;&amp; s[go[k][i]].r &lt; lmt) &#123;</span><br><span class="line">ans += (1 &lt;&lt; i);</span><br><span class="line">k = go[k][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res[s[p].id] = ans + 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s[i].l &gt;&gt; s[i].r;</span><br><span class="line">if(s[i].r &lt; s[i].l)</span><br><span class="line">s[i].r += m;</span><br><span class="line">s[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(s + 1, s + 1 + n, cmp);</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">s[i + n] = s[i];</span><br><span class="line">s[i + n].l = s[i].l + m;</span><br><span class="line">s[i + n].r = s[i].r + m;</span><br><span class="line">&#125;</span><br><span class="line">pre();</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">search(i);</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="学习总结-1"><a href="#学习总结-1" class="headerlink" title="学习总结"></a>学习总结</h3><p>这段代码实现了一个经典的区间覆盖问题，核心思想是通过排序和动态规划来高效地解决覆盖区间的最小边防战士数量。具体做法是将所有的区间转化成线性区间，使用排序保证覆盖的顺序性，再通过二分查找和动态规划的结合，优化查询效率。这个思路对于解决类似的区间覆盖问题非常有效，尤其是在大规模数据输入时，能够显著减少计算复杂度。通过合理使用跳跃表和二分查找，代码实现了较高的效率，是学习算法设计和优化的重要案例。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task 2</title>
      <link href="/2025/02/06/Task-2/"/>
      <url>/2025/02/06/Task-2/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第二讲-“二分”"><a href="#寒假第二讲-“二分”" class="headerlink" title="寒假第二讲:“二分”"></a>寒假第二讲:“二分”</h1><h2 id="一-二分查找"><a href="#一-二分查找" class="headerlink" title="一.二分查找"></a>一.二分查找</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这个问题的要求是通过二分查找，在一个已经按升序排列的整数序列中查找是否包含查询的整数。对于每次查询，若该整数在序列中出现，则输出 “Yes”，否则输出 “No”。</p><ol><li><strong>输入处理</strong>：<ul><li>输入一个整数 nnn，表示数组的大小。</li><li>接下来输入 nnn 个整数，这些整数已排序。</li><li>接着输入一个整数 qqq，表示查询次数。</li><li>对于每次查询，输入一个整数 mmm，需要判断 mmm 是否出现在排序数组中。</li></ul></li><li><strong>二分查找</strong>：<ul><li>二分查找是一种高效的查找方法，在一个已排序的数组中查找某个元素的时间复杂度为 O(log⁡n)O(\log n)O(logn)。</li><li>使用标准库的 <code>lower_bound</code> 函数来实现二分查找。它会返回一个指向数组中第一个大于或等于查询值的迭代器。如果迭代器指向的元素与查询值相同，则表示该元素存在。</li></ul></li><li><strong>输出</strong>：<ul><li>如果查询值在数组中存在，则输出 “Yes”；否则输出 “No”。</li></ul></li></ol><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;  // For lower_bound</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; arr(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class="line">        int m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">      </span><br><span class="line">        auto it = lower_bound(arr.begin(), arr.end(), m);</span><br><span class="line">  </span><br><span class="line">        if (it != arr.end() &amp;&amp; *it == m) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>该问题要求在已排序的数组中进行多个查找操作，最直观的做法是使用二分查找。二分查找能够将查找时间从 O(n)O(n)O(n) 降低到 O(log⁡n)O(\log n)O(logn)，因此对于大规模数据，能够显著提高效率。利用 C++ STL 提供的 <code>lower_bound</code> 函数，可以高效地实现二分查找，避免手动实现查找算法。通过这种方法，每次查询的时间复杂度为 O(log⁡n)O(\log n)O(logn)，因此总的时间复杂度为 O(qlog⁡n)O(q \log n)O(qlogn)，适合处理较大规模的输入数据。</p><p>这个解法对于最大值 n&#x3D;100000n &#x3D; 100000n&#x3D;100000 和 q&#x3D;100000q &#x3D; 100000q&#x3D;100000 的情况也是可行的，满足时间限制。</p><h2 id="二-A-B数对"><a href="#二-A-B数对" class="headerlink" title="二.A-B数对"></a>二.A-B数对</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>给定数列以及常数 CCC，要求计算满足条件 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C 的数对个数。这个问题要求判断在数列中，存在多少对 (A,B)(A, B)(A,B)，使得 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C，即 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C。</p><h4 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h4><ol><li><strong>数学转换</strong>：<ul><li>给定条件 A−B&#x3D;CA - B &#x3D; CA−B&#x3D;C，可转化为 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C。因此，对于每个 BBB，我们只需要判断 B+CB + CB+C 是否出现在数列中。</li></ul></li><li><strong>使用哈希表</strong>：<ul><li>使用哈希表（<code>unordered_map</code>）来记录数列中每个数字的出现次数。遍历数列，对于每个数 BBB，计算 B+CB + CB+C，然后检查哈希表中是否有这个数。如果有，则计数增加。</li></ul></li><li><strong>效率问题</strong>：<ul><li>用哈希表统计数列中各个数字的出现次数，查找某个数是否存在的操作是 O(1)O(1)O(1)，所以该算法的时间复杂度是 O(N)O(N)O(N)，适用于大规模数据。</li></ul></li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, C;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; C;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; arr(N);</span><br><span class="line">    unordered_map&lt;int, int&gt; freq;  </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        ++freq[arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    long long count = 0; </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        int B = arr[i];</span><br><span class="line">        int A = B + C;  // 计算A = B + C</span><br><span class="line">       </span><br><span class="line">        if (freq.find(A) != freq.end()) &#123;</span><br><span class="line">            count += freq[A];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>哈希表</strong>： 哈希表在处理需要快速查找的场景中非常有用。在本题中，哈希表帮助我们在 O(1)O(1)O(1) 的时间复杂度内查找某个元素是否存在，使得整体复杂度从 O(N2)O(N^2)O(N2) 降低到 O(N)O(N)O(N)。</p><p><strong>优化思维</strong>： 通过将问题转化为查找数列中是否存在某个数 A&#x3D;B+CA &#x3D; B + CA&#x3D;B+C，我们避免了枚举所有数对的低效方法。这是典型的通过数学转化优化问题的思路。</p><p><strong>时间与空间复杂度</strong>： 学习如何平衡时间和空间复杂度。通过使用哈希表，虽然增加了额外的空间开销，但极大地提高了算法效率，适应了问题的大数据规模。</p><p><strong>实际应用</strong>： 哈希表和集合操作在实际开发中有着广泛应用，例如数据库的索引、缓存系统等，了解并掌握这些基本数据结构对解决实际问题至关重要。</p><h2 id="三-分巧克力"><a href="#三-分巧克力" class="headerlink" title="三.分巧克力"></a>三.分巧克力</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求我们从 <code>N</code> 块巧克力中切出 <code>K</code> 块正方形巧克力，且每块正方形的边长尽可能大。我们需要通过切割巧克力的长方形，得到大小相同的正方形。</p><h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><ol><li><strong>正方形的大小</strong>：<ul><li>对于每一块巧克力 Hi×WiH_i \times W_iHi×Wi，我们能够从中切出多少个 S×SS \times SS×S 的正方形（其中 SSS 为正方形的边长）？</li><li>我们可以通过将 HiH_iHi 和 WiW_iWi 分别除以 SSS，计算每个长方形可以切出的正方形数量： 个数&#x3D;⌊HiS⌋×⌊WiS⌋\text{个数} &#x3D; \left\lfloor \frac{H_i}{S} \right\rfloor \times \left\lfloor \frac{W_i}{S} \right\rfloor个数&#x3D;⌊SHi⌋×⌊SWi⌋</li><li>我们需要找到一个 SSS，使得从所有 NNN 块巧克力中切出的正方形总数至少为 KKK。</li></ul></li><li><strong>二分查找</strong>：<ul><li>由于我们希望切出的正方形边长尽可能大，最直观的办法是使用二分查找来确定边长 SSS 的最大值。范围从 1 到每块巧克力的最大边长（即 min⁡(Hi,Wi)\min(H_i, W_i)min(Hi,Wi)）。</li></ul></li><li><strong>检查条件</strong>：<ul><li>对于每个 SSS，我们计算出所有巧克力切出的正方形数量，并判断是否能够满足至少有 KKK 块巧克力。如果能满足，说明 SSS 是一个可能的解，我们可以继续尝试更大的 SSS；否则，尝试更小的 SSS。</li></ul></li></ol><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 判断给定边长 S 能否从所有巧克力中切出至少 K 块正方形</span><br><span class="line">bool canCutSquares(const vector&lt;pair&lt;int, int&gt;&gt;&amp; chocolates, int S, int K) &#123;</span><br><span class="line">    long long totalCount = 0;  // 记录切出的正方形总数</span><br><span class="line">    for (const auto&amp; chocolate : chocolates) &#123;</span><br><span class="line">        int H = chocolate.first;</span><br><span class="line">        int W = chocolate.second;</span><br><span class="line">        totalCount += (H / S) * (W / S);  // 计算该巧克力能切出多少个 S * S 的正方形</span><br><span class="line">        if (totalCount &gt;= K) return true;  // 如果已达到要求的数量，提前返回</span><br><span class="line">    &#125;</span><br><span class="line">    return totalCount &gt;= K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, K;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; chocolates(N);</span><br><span class="line">    int maxSide = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; chocolates[i].first &gt;&gt; chocolates[i].second;</span><br><span class="line">        maxSide = max(maxSide, min(chocolates[i].first, chocolates[i].second));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int low = 1, high = maxSide, bestSide = 0;</span><br><span class="line"></span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (canCutSquares(chocolates, mid, K)) &#123;</span><br><span class="line">            bestSide = mid;  </span><br><span class="line">            low = mid + 1;  </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            high = mid - 1;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bestSide &lt;&lt; endl; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>二分查找的应用</strong>：通过二分查找可以高效地求解正方形的最大边长，尤其是在边长空间较大时，能够显著降低时间复杂度。</p><p><strong>空间利用</strong>：通过使用哈希表和二分查找，我们在时间和空间上达到了较优的平衡，能够处理最大规模的数据。</p><p><strong>问题的数学转化</strong>：通过将切割问题转化为数目判断问题，利用二分查找可以有效避免暴力破解的高时间复杂度。</p><h2 id="四-卡牌"><a href="#四-卡牌" class="headerlink" title="四.卡牌"></a>四.卡牌</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p><strong>减少重复计算</strong>：</p><ul><li>在 <code>canMakeKSets</code> 函数中，我们每次都需要计算空白卡牌的数量。考虑到 <code>a[i]</code> 和 <code>b[i]</code> 对于每个卡牌是固定的，我们可以提前计算每种卡牌的补充量，然后直接通过前缀和计算每个 <code>k</code> 的所需补充卡牌数。</li></ul><p><strong>通过前缀和优化卡牌需求计算</strong>：</p><ul><li>计算需要补充的空白卡牌数时，如果我们能提前计算出每种卡牌在每个 <code>k</code> 值下需要多少空白卡牌，可以加速查找。</li><li>我们可以使用 <strong>贪心策略</strong> 或者 <strong>扫描算法</strong>，避免每次都全量扫描 <code>n</code> 个卡牌。</li></ul><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n, m, a[N + 5], b[N + 5];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    bool f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    for (; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) f ^= (ch == &#x27;-&#x27;);</span><br><span class="line">    for (; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool check(int mid) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cnt += max(0LL, mid - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt &lt;= m;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Kafka() &#123;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line">    </span><br><span class="line">    int L = 1, R = n * 2;</span><br><span class="line"> </span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i] = read();</span><br><span class="line">        R = min(a[i] + b[i], R);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二分查找最大套牌数</span><br><span class="line">    while (L &lt; R) &#123;</span><br><span class="line">        int mid = (L + R + 1) &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) &#123;</span><br><span class="line">            L = mid;  </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            R = mid - 1; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; L &lt;&lt; &#x27;\n&#x27;;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>提前计算补充数量</strong>：通过一次遍历计算每个 <code>k</code> 需要的补充卡牌数量，可以减少时间复杂度，避免重复计算。</p><p><strong>二分查找的技巧</strong>：通过二分查找可以有效缩小搜索范围，每次判断可以集中判断某个 <code>k</code> 是否可行。</p><p><strong>空间优化</strong>：只使用简单的数组来存储卡牌数量和补充限制，空间复杂度为 <code>O(n)</code>，符合题目要求。</p><h2 id="五-书的复制"><a href="#五-书的复制" class="headerlink" title="五.书的复制"></a>五.书的复制</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>本题目要求将 <code>m</code> 本有顺序的书分给 <code>k</code> 个人复制，每个人抄写的书是连续的，并且需要尽可能最短的复制时间。复制时间指的是抄写页数最多的人所用的时间，目标是尽可能减少这个时间。</p><p>为了解决这个问题，采用了 <strong>二分查找</strong> 和 <strong>贪心算法</strong> 结合的策略：</p><ol><li><strong>二分查找</strong>：<ul><li>对于复制时间的最大值 <code>max_time</code>（即抄写页数最多的人的时间），我们可以进行二分查找。</li><li>初始时，设置 <code>L = 1</code>（最小值）和 <code>R = sum(a)</code>（最大值，所有书页加起来）。</li><li>对于每个中间值 <code>mid</code>，我们要判断是否能在 <code>mid</code> 的最大时间限制下，合理分配书籍给 <code>k</code> 个人。</li></ul></li><li><strong>贪心算法</strong>：<ul><li>每次尝试用当前的 <code>mid</code> 来分配书籍：从书籍列表中依次分配，如果当前人的已分配页数超过 <code>mid</code>，就开始分配给下一个人。</li><li>通过这种方式，我们可以确定在当前的 <code>mid</code> 时间下，能分配给 <code>k</code> 个人。</li></ul></li><li><strong>过程描述</strong>：<ul><li>对于每次二分查找的 <code>mid</code>，我们从第 1 个人开始，贪心地分配书籍。如果当前书籍无法分配给当前人（超出了 <code>mid</code> 时间），就换给下一个人，直到所有书籍分配完。</li><li>如果我们能够在 <code>k</code> 个人内完成分配，那么说明当前的 <code>mid</code> 值是可行的，我们尝试缩小 <code>mid</code>；否则，增大 <code>mid</code>。</li></ul></li><li><strong>结果输出</strong>：<ul><li>二分查找结束后，最终的最优时间就是 <code>L</code>，然后根据该时间输出每个人抄写的书籍区间。</li></ul></li></ol><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int K=500;</span><br><span class="line">int m,k,a[K+5];</span><br><span class="line">int st[K+5],ed[K+5];</span><br><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int x=0;bool f=1;char ch=getchar();</span><br><span class="line">    for(;ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;;ch=getchar())f^=(ch==&#x27;-&#x27;);</span><br><span class="line">    for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar())x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);</span><br><span class="line">    return f?x:-x;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int mid)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt=1,now=mid;</span><br><span class="line">    for(int i=1;i&lt;=m&amp;&amp;cnt&lt;=k;++i) </span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&gt;now) ++cnt,--i,now=mid;</span><br><span class="line">        else now-=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line">void Kafka()</span><br><span class="line">&#123;</span><br><span class="line">    m=read(),k=read();</span><br><span class="line">    int L=1,R=0;</span><br><span class="line">    for(int i=1;i&lt;=m;++i) a[i]=read(),R+=a[i];</span><br><span class="line">    for(int mid=L+R&gt;&gt;1;L&lt;R;check(mid)?R=mid:L=mid+1)mid=L+R&gt;&gt;1;</span><br><span class="line">    ed[k]=m,st[1]=1;</span><br><span class="line">    for(int i=k,j=m,now=L;i;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        for(;now&gt;=a[j]&amp;&amp;j;--j) now-=a[j];</span><br><span class="line">        st[i]=j+1,ed[i-1]=j,now=L;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=k;++i) cout&lt;&lt;st[i]&lt;&lt;&#x27; &#x27;&lt;&lt;ed[i]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-4"><a href="#3-学习总结-4" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>本题考察了 <strong>二分查找</strong> 和 <strong>贪心算法</strong> 的结合使用。通过二分查找高效地探索最优解空间，再结合贪心算法快速判断是否能在指定时间内完成分配，使得问题得以高效解决。这种类型的问题不仅能够加深对算法思维的理解，还能帮助解决实际中遇到的类似最优化问题。</p><h2 id="六-青蛙过河"><a href="#六-青蛙过河" class="headerlink" title="六.青蛙过河"></a>六.青蛙过河</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>题目要求小青蛙在河对岸和学校之间来回跳跃，以最小化跳跃的能力（即最小的跳跃距离）。每次小青蛙必须从一块石头起跳，并且跳跃的距离不能超过某个值。为了确保小青蛙能够完成指定的跳跃次数（2x次），我们需要找到一个合适的跳跃距离，使得它能够在有限的跳跃次数内成功完成任务。</p><ul><li><p>首先我们需要确定最小跳跃能力的范围。最小值为 <code>1</code>，最大值为 <code>n-1</code>（即河宽度），即从河的起点到终点的最大跳跃距离。</p></li><li><p>我们可以使用二分查找来缩小跳跃能力的范围。通过不断尝试不同的跳跃能力 <code>mid</code>，并判断是否能够完成 <code>2x</code> 次跳跃。</p></li><li><p>为了判断某个跳跃能力是否合适，模拟小青蛙的跳跃过程：从起点开始，每次尝试跳跃尽可能远的石头（跳跃的距离不超过当前的 <code>mid</code>），并尽量减少跳跃的次数。</p></li><li><p>如果跳跃次数小于或等于 <code>2x</code>，则当前跳跃能力 <code>mid</code> 是可行的。</p></li><li><p>否则，当前跳跃能力 <code>mid</code> 太小，不能完成任务。</p></li><li><p>通过二分查找不断调整跳跃能力的范围，直到找到最小的可行跳跃能力。</p></li></ul><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n, x, H[N + 5], sum[N + 5];</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int x = 0; bool f = 1; char ch = getchar();</span><br><span class="line">    for (; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) f ^= (ch == &#x27;-&#x27;);</span><br><span class="line">    for (; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check(int mid) &#123;</span><br><span class="line">    int cnt = 0, last = 0;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        if (i - last &gt; mid) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            last = i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n - last &gt; mid) cnt++;</span><br><span class="line">    return cnt &lt;= 2 * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Kafka() &#123;</span><br><span class="line">    n = read(), x = read();</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        H[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int L = 1, R = n, ans = n;</span><br><span class="line">    while (L &lt;= R) &#123;</span><br><span class="line">        int mid = (L + R) &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            R = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            L = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    Kafka();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-5"><a href="#3-学习总结-5" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>二分查找的应用</strong><br>二分查找通常用来在有序区间中查找某个满足条件的值。在本题中，我们通过二分查找来找到最小的跳跃能力，这种问题通常被称为“最小最大化问题”。</p><p><strong>模拟问题的实现</strong><br>本题中模拟了小青蛙的跳跃过程，模拟的关键是如何判断是否能在有限的跳跃次数内完成任务。通过检查每个 <code>mid</code> 跳跃能力是否能够完成 <code>2x</code> 次跳跃，判断当前跳跃能力的可行性。</p><p><strong>问题求解中的二分查找优化</strong><br>由于本题的跳跃能力是一个整数范围，且通过验证跳跃能力的可行性可以在常数时间内完成，所以二分查找在这个问题中是一种高效的求解方法。</p><p><strong>复杂度分析</strong></p><ul><li>二分查找的时间复杂度是 <code>O(log n)</code>。</li><li>对每个 <code>mid</code> 值，我们需要遍历石头进行一次跳跃模拟，最坏情况下是 <code>O(n)</code>。</li><li>因此，总的时间复杂度是 <code>O(n log n)</code>，对于 <code>n</code> 最大为 <code>10^5</code> 的数据，能够有效地在时间限制内完成计算。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task 1</title>
      <link href="/2025/02/06/Task-1/"/>
      <url>/2025/02/06/Task-1/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假第一讲：C-基础"><a href="#寒假第一讲：C-基础" class="headerlink" title="寒假第一讲：C++ 基础"></a>寒假第一讲：C++ 基础</h1><h2 id="一-Long-Loong"><a href="#一-Long-Loong" class="headerlink" title="一.Long Loong"></a>一.Long Loong</h2><h3 id="1-对应思路"><a href="#1-对应思路" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>思路较为简单，就是先固定输出L，再根据输入的N得到应该输出多少o，最后再固定输出ng。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; &#x27;L&#x27;;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">cout &lt;&lt; &#x27;o&#x27;;</span><br><span class="line">cout &lt;&lt; &quot;ng&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结"><a href="#3-学习总结" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>学到了for循环的基本用法，对我帮助极大，受益良多。</p><h2 id="二-YES-or-YES"><a href="#二-YES-or-YES" class="headerlink" title="二.YES or YES?"></a>二.YES or YES?</h2><h3 id="1-对应思路-1"><a href="#1-对应思路-1" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>思路就是将输入的字符串全部大写，然后判断是否等于YES，如果等于就输出YES，不等于就输出NO。</p><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t; </span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        transform(s.begin(), s.end(), s.begin(), ::toupper);</span><br><span class="line">        if (s == &quot;YES&quot;) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-1"><a href="#3-学习总结-1" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ol><li>字符串处理：通过 <code>transform</code> 配合 <code>tolower</code> 或 <code>toupper</code>，可以快速将字符串统一为小写或大写，便于比较。</li><li>循环与分支：利用 <code>while (t--)</code> 循环高效处理多组输入，结合 <code>if-else</code> 判断分类处理逻辑。</li><li>时间复杂度：转换大小写或比较字符串的复杂度为 O(字符串长度)O(\text{字符串长度})O(字符串长度)。整体复杂度为 O(t)O(t)O(t)，适用于测试用例较多的情况。</li><li>STL 使用：标准库函数如 <code>transform</code> 和字符串直接比较提升了代码简洁性和可靠性。</li></ol><h2 id="三-Even-Odd-G"><a href="#三-Even-Odd-G" class="headerlink" title="三.Even? Odd? G"></a>三.Even? Odd? G</h2><h3 id="1-对应思路-2"><a href="#1-对应思路-2" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这个程序的主要任务是根据输入的一组超大整数，判断每个整数的奇偶性（即最后一位数字是偶数还是奇数）。由于数的范围可能非常大（高达 106010^{60}1060），无法直接使用普通整数类型（如 <code>int</code> 或 <code>long long</code>），所以采用字符串处理的方式。</p><h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    int N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; results;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">        string number;</span><br><span class="line">        cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">        char lastDigit = number[number.length() - 1];</span><br><span class="line">        if ((lastDigit - &#x27;0&#x27;) % 2 == 0) &#123;</span><br><span class="line">            results.push_back(&quot;even&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            results.push_back(&quot;odd&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (const string&amp; result : results) &#123;</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-2"><a href="#3-学习总结-2" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p><strong>字符串处理大数</strong>：</p><ul><li>当数字的范围超过内置类型的支持时，可以用字符串表示并处理。</li><li>判断奇偶性只需关注数字的最后一位，简化了大数的操作。</li></ul><p><strong>模运算的应用</strong>：</p><ul><li>奇偶性的本质是看数字能否被 222 整除，通过 mod  2\mod 2mod2 运算即可实现。</li></ul><h2 id="四-Problem-Generator"><a href="#四-Problem-Generator" class="headerlink" title="四.Problem Generator"></a>四.Problem Generator</h2><h3 id="1-对应思路-3"><a href="#1-对应思路-3" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li>输入处理</li></ol><ul><li>读取测试用例数量 <code>t</code>。</li><li>对于每个测试用例，读取两个整数 <code>n</code>（题库题目数量）和 <code>m</code>（比赛轮次），以及一个字符串 <code>a</code> 表示题库中的题目难度。</li></ul><ol start="2"><li>统计题目数量</li></ol><ul><li>使用7个变量 <code>n1</code> 到 <code>n7</code> 分别记录每种难度（A到G）的题目数量。</li><li>遍历字符串 <code>a</code>，通过比较字符 <code>c</code> 是否为 ‘A’ 到 ‘G’ 来对每种难度的题目计数。</li></ul><ol start="3"><li>每种难度的最大需求</li></ol><ul><li>每轮比赛需要一个完整的难度级别（A到G），即每种难度最多需要 mmm 道题。</li></ul><ol start="4"><li>计算需要补充的题目数量</li></ol><ul><li><p>每轮比赛需要7种难度的题目，因此总需求为 7×m7 \times m7×m。</p></li><li><p>当前已有的题目总量为 n1+n2+⋯+n7n1 + n2 + \dots + n7n1+n2+⋯+n7。</p></li><li><p>需要补充的题目数量为： 需要补充&#x3D;max⁡(0,7×m−当前已有的题目总量)\text{需要补充} &#x3D; \max(0, 7 \times m - \text{当前已有的题目总量})需要补充&#x3D;max(0,7×m−当前已有的题目总量)</p></li><li><p>如果已有题目足够，则补充为0；否则补充缺少的题目数量。</p></li></ul><ol start="5"><li>输出结果</li></ol><ul><li>将每个测试用例的结果输出在单独的一行。</li></ul><h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;   </span><br><span class="line"> </span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        string a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        int n1 = 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0, n6 = 0, n7 = 0;</span><br><span class="line">        for (char c : a)</span><br><span class="line">        &#123;</span><br><span class="line">            if (c == &#x27;A&#x27;)</span><br><span class="line">                n1++;</span><br><span class="line">            if (c == &#x27;B&#x27;)</span><br><span class="line">                n2++;</span><br><span class="line">            if (c == &#x27;C&#x27;)</span><br><span class="line">                n3++;</span><br><span class="line">            if (c == &#x27;D&#x27;)</span><br><span class="line">                n4++;</span><br><span class="line">            if (c == &#x27;E&#x27;)</span><br><span class="line">                n5++;</span><br><span class="line">            if (c == &#x27;F&#x27;)</span><br><span class="line">                n6++;</span><br><span class="line">            if (c == &#x27;G&#x27;)</span><br><span class="line">                n7++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n1 &gt; m)</span><br><span class="line">            n1 = m;</span><br><span class="line">        if (n2 &gt; m)</span><br><span class="line">            n2 = m;</span><br><span class="line">        if (n3 &gt; m)</span><br><span class="line">            n3 = m;</span><br><span class="line">        if (n4 &gt; m)</span><br><span class="line">            n4 = m;</span><br><span class="line">        if (n5 &gt; m)</span><br><span class="line">            n5 = m;</span><br><span class="line">        if (n6 &gt; m)</span><br><span class="line">            n6 = m;</span><br><span class="line">        if (n7 &gt; m)</span><br><span class="line">            n7 = m;</span><br><span class="line">        cout &lt;&lt; max(0, 7 * m - n1 - n2 - n3 - n4 - n5 - n6 - n7) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-3"><a href="#3-学习总结-3" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><ul><li><p>本题通过统计每种难度题目的数量解决问题。这是字符频率统计的典型应用。</p></li><li><p>通过遍历字符串并比较字符，可以有效统计各类别出现次数。</p></li></ul><h2 id="五-rules"><a href="#五-rules" class="headerlink" title="五.rules"></a>五.rules</h2><h3 id="1-对应思路-4"><a href="#1-对应思路-4" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><p>这段代码解决的问题是考察规则是否符合民意，主要步骤如下：</p><ol><li><p>输入数据：首先读取居民总数 <code>n</code>、记录天数 <code>m</code> 以及规则代号 <code>k</code>。</p></li><li><p>统计符合民意的天数：</p><p>循环 <code>m</code> 次，表示逐天处理记录。</p><p>对每一天，统计有多少居民遵守了规则 <code>k</code>（计数器 <code>c2</code>）。</p><p>如果遵守规则 <code>k</code> 的人数大于等于一半 (<code>c2 * 2 &gt;= n</code>)，则该天规则符合民意，符合民意的天数计数器 <code>c1</code> 加一。</p></li><li><p>判断规则正确性</p><p>：如果符合民意的天数大于等于记录天数的一半 (<code>c1 * 2 &gt;= m</code>)，输出 “YES” 表示规则正确，否则输出 “NO”。</p></li></ol><h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m, n, k;</span><br><span class="line">int c1 = 0, c2 = 0;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">for (int i = 0; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">c2 = 0;</span><br><span class="line">for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">if (t == k)</span><br><span class="line">&#123;</span><br><span class="line">c2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if ( c2*2 &gt;=  n)</span><br><span class="line">&#123;</span><br><span class="line">c1++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;if ( c1*2 &gt;=  m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;YES&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-4"><a href="#3-学习总结-4" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>这道题目涉及多重循环的处理，是学习数组与条件判断的重要练习。通过这段代码可以总结如下：</p><ol><li><p>理解核心逻辑</p><p>问题的核心在于两层判断：一是某天规则是否符合民意，二是统计符合民意的天数是否达到要求。这种多层嵌套条件是常见的编程模式。</p></li><li><p>优化循环效率</p><p>本代码通过双重循环按天和按人处理问题，时间复杂度为 O(m×n)O(m \times n)O(m×n)。这种结构在处理范围较大时可能需要优化。</p></li><li><p>掌握计数逻辑</p><p>使用计数器 <code>c2</code> 和 <code>c1</code> 逐步累积数据，并通过条件判断更新状态。这种逻辑清晰、简洁，适合复杂问题分步解决。</p></li></ol><h2 id="六-Many-Replacement"><a href="#六-Many-Replacement" class="headerlink" title="六.Many Replacement"></a>六.Many Replacement</h2><h3 id="1-对应思路-5"><a href="#1-对应思路-5" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p>初始化映射表：</p><p>创建一个 <code>mapping</code> 数组，长度为 26（表示字母表），初始化为 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 的对应字母。这个表将用于记录字母替换关系。</p></li><li><p>处理替换操作：</p><p>对每个替换指令 <code>(c, d)</code>，遍历 <code>mapping</code> 数组，将所有值等于 <code>c</code> 的项替换为 <code>d</code>。</p><p>这种方式确保了间接替换链条也能正确生效。例如，如果先将 <code>a</code> 替换为 <code>b</code>，再将 <code>b</code> 替换为 <code>c</code>，最终 <code>a</code> 也会被替换为 <code>c</code>。</p></li><li><p>修改字符串：</p><p>遍历字符串 <code>S</code> 的每个字符，根据 <code>mapping</code> 数组中的映射关系，将字符替换为最终映射的目标字符。</p></li><li><p>输出结果：</p><p>输出修改后的字符串 <code>S</code>。</p></li></ol><p>通过使用 <code>mapping</code> 数组记录全局映射关系，避免直接修改字符串多次，提高了处理效率。</p><h3 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N, Q;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    string S;</span><br><span class="line">    cin &gt;&gt; S;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    vector&lt;char&gt; mapping(26);</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">        mapping[i] = &#x27;a&#x27; + i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; Q; i++) &#123;</span><br><span class="line">        char c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        for (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">            if (mapping[j] == c) &#123;</span><br><span class="line">                mapping[j] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (char &amp;ch : S) &#123;</span><br><span class="line">        ch = mapping[ch - &#x27;a&#x27;]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-5"><a href="#3-学习总结-5" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>1.高效处理替换链：</p><p>  使用一个映射表 (<code>mapping</code> 数组) 将字符替换逻辑统一管理，避免了直接在字符串中进行多次替换操作，降低了时间复杂度。</p><p>2.间接替换链的处理：</p><p>  通过在处理替换指令时遍历整个映射表，确保链式替换得到正确结果。这种方法适用于有依赖关系的替换问题。</p><p>3.复杂度优化：</p><p>  替换操作遍历 <code>mapping</code> 的复杂度为 O(Q×26)O(Q \times 26)O(Q×26)，字符串替换为 O(N)O(N)O(N)，整体复杂度约为 O(Q+N)O(Q + N)O(Q+N)，足以处理较大输入规模。</p><p>4.边界条件考虑：</p><p>  替换字符可以是相同的（<code>c = d</code>），这种情况不会影响映射表。</p><p>  某些字符可能不存在于字符串中，但替换逻辑依然可以正常处理。</p><h2 id="更好的交换"><a href="#更好的交换" class="headerlink" title="更好的交换"></a>更好的交换</h2><h3 id="1-对应思路-6"><a href="#1-对应思路-6" class="headerlink" title="1.对应思路"></a>1.对应思路</h3><ol><li><p>输入与初始化：</p><p>读取矩阵大小 <code>n</code> 和操作次数 <code>m</code>。</p><p>读取矩阵内容并存储在 <code>matrix</code> 中。</p><p>初始化两个数组 <code>row_map</code> 和 <code>col_map</code>，分别记录行和列的映射关系，初始值为 <code>[0, 1, 2, ..., n-1]</code>。</p></li><li><p>操作处理：</p><p>遍历每个操作，根据操作类型：</p><p>  若 <code>op == 1</code>（交换行），则交换 <code>row_map[x]</code> 和 <code>row_map[y]</code>。</p><p>  若 <code>op == 0</code>（交换列），则交换 <code>col_map[x]</code> 和 <code>col_map[y]</code>。</p><p>通过修改 <code>row_map</code> 和 <code>col_map</code> 的映射关系，而非直接修改矩阵，节省了时间复杂度。</p></li><li><p>输出矩阵：</p><p>根据最终的 <code>row_map</code> 和 <code>col_map</code>，重新按映射顺序输出矩阵。<code>matrix[row_map[i]][col_map[j]]</code> 得到正确的映射值。</p></li></ol><p>通过这种间接映射法，避免了每次交换直接操作矩阵，提高了效率，适合大规模输入。</p><h3 id="2-代码-6"><a href="#2-代码-6" class="headerlink" title="2.代码"></a>2.代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n));</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; row_map(n), col_map(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        row_map[i] = i; </span><br><span class="line">        col_map[i] = i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        --x; </span><br><span class="line">        --y;</span><br><span class="line">        if (op == 1) &#123;</span><br><span class="line">            swap(row_map[x], row_map[y]); </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            swap(col_map[x], col_map[y]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; matrix[row_map[i]][col_map[j]] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-学习总结-6"><a href="#3-学习总结-6" class="headerlink" title="3.学习总结"></a>3.学习总结</h3><p>间接映射优化：</p><p>​    直接交换矩阵行列会带来高昂的时间复杂度，间接通过映射数组调整顺序是一种高效的解决方式。</p><p>空间与时间的平衡：</p><p>​    增加两个映射数组 <code>row_map</code> 和 <code>col_map</code>，用空间换取了时间的优化。</p><p>​    在 mmm 次操作和 n2n^2n2 次矩阵访问中，复杂度降低为 O(n2+m)O(n^2 + m)O(n2+m)，适合处理大规模 n,mn, mn,m。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog用法</title>
      <link href="/2025/02/06/blog%E7%94%A8%E6%B3%95/"/>
      <url>/2025/02/06/blog%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h1 id="本地网站"><a href="#本地网站" class="headerlink" title="本地网站"></a>本地网站</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/06/hello-world/"/>
      <url>/2025/02/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
